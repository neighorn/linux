#! /usr/bin/perl
#
# Copyright (c) 2012 Martin Consulting Services, Inc.
# Licensed under the Lesser Gnu Public License (LGPL).
# 
# ABSOLUTELY NO WARRENTIES EXPRESSED OR IMPLIED.  ANY USE OF THIS
# CODE IS STRICTLY AT YOUR OWN RISK.
#

#
# =====Description====
#
use strict;
use warnings;
use LogOutput;
use ProcessOptions;
use Text::ParseWords;
use FindBin qw($RealBin $RealScript);
use feature 'switch';

# Initialize variables.
our $Prog=$0; 		             	# Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
our $Errors=0;				# No errors so far.
our $Syslog='';				# Name of Syslog facility.  '' for none.
our $BaseDir=$RealBin;			# Set our base directory.
our $LogFile="";			# Name of the log file.
our $ConfigFile="$BaseDir";		# Deterimine the name of our config file.
$ConfigFile =~ s"/.[^/]*$"/etc/${Prog}.cfg";# 	Ditto.
our @Parms;				# Array of remaining cmdline parms.
our %Config;				# Our configuration options.
my $ExitCode;				# Code we'll exit with.
#
our $opt_h;				# -h (help) option.
our $opt_e;				# -e (error mail) option.
our @opt_L;				# -L List of Systemd libraries.
our $opt_m;				# -m (mail) option.
our $opt_M;				# -M (mode) option.
our $opt_p;				# -p (pager mail) option.
our $opt_P;				# -P (pager error mail) option.
our $opt_t;				# -t (test) option.
our $opt_v;				# -v (verbose) option.
#

# Note: general purpose script - don't change current directory.
#chdir $BaseDir || die "Unable to change directories to $BaseDir: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#       1) We define a new type l (lowercase L), which is a list (i.e. if
#          specified multiple times, values are concatenated & blank separated.o
#          Normal =s and =i would replace values instead of concatenate.
#       2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
my $OptSpec='e=l h L=l m=l M=s O=s p=l P=l t v';

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=~tr/[a-z]/[A-Z]/;
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}
if ($Errors) {exit $ExitCode;}      # Exit if errors were detected.
	
# Set up our logging and output filtering.
LogOutput('',$Syslog,$LogFile,$opt_m,$opt_e,$opt_p,$opt_P);

# Verify the command line.
die("No services specified on the command line.  See \"$Prog -h\" for usage")
	unless (@Parms > 0);

# Set default library list if not supplied.
@opt_L = (
	'/etc/systemd/system',
	'/lib/systemd',
) unless (@opt_L);

# Mainline code.
if ( $> != 0 ) {
	RunDangerousCmd("sudo $Prog " . join(' ',@Parms));
	exit $?;
}

# Figure out our operating mode.
my $PrettyMode;
($opt_M = $Prog) =~ s/sys$// if (! $opt_M);
given ($opt_M) {
	when ('start')		{$PrettyMode="Starting";}
	when ('stop')		{$PrettyMode="Stopping";}
	when ('restart')	{$PrettyMode="Restarting";}
	default 		{ die "Unknown operation script mode of $opt_M";}
}

# Process each service
SERVICE: foreach my $Parm (@Parms) {
	# Begin by building a list of possible names.
	# For a supplied name of abcd@xd, the possible correct names are:
	#	abcd@xd.service		-- added .service
	#	abcd@xdd.service	-- added d.service
	#	abcd@x.service		-- deleted d, added .service
	#	abcd@.service		-- template: removed instance name, added .service
	#	abcdd@.service		-- template: added d to base, removed instance name, added .service
	#	abc@.service		-- template: removed d from base, removed instance name, added .service
	#	/etc/init.d/abcd@xd	-- SysV name
	#	/etc/init.d/abcd@xdd	-- SysV name, added d
	#	/etc/init.d/abcd@x	-- SysV name, removed d
	#	/etc/init.d/elog

	my @SystemdNames;	# List of possible Systemd names.
	my @TemplateServices;	# List of possible template service names.
	my @TemplateFiles;	# List of possible template file names.
	my @SysVNames;		# List of possible SysV names.

	# First, try it as-is.  .service suffix required for Systemd.
	push @SystemdNames,($Parm =~ /.service$/?$Parm:"$Parm.service");
	push @SysVNames,$Parm;

	# Strip .service off if present for subsequent tests.
	$Parm =~ s/.service$//;

	# Now work with trailing d's, either extraneous or missing.
	push @SystemdNames, D_Variants($Parm,'.service');
	push @SysVNames, D_Variants($Parm);

	# Now work with possible templates.
	if ($Parm =~ /^(\S+)?@(\S+)$/) {
		# Looks like a template name.
		my($Base,$Instance)=($1,$2);
		# Queue the name as-is.
		push @TemplateServices,"$Parm.service";
		push @TemplateFiles,$Base . '@.service';
		# Now do the d variants.
		foreach (D_Variants($Base)) {
			push @TemplateServices,"$_\@$Instance.service";
			push @TemplateFiles,"$_\@.service";
		}
	}
	
	# Try to start the service in this order Systemd, Systemd template, SysV.
	foreach my $Name (@SystemdNames) {
		foreach my $Dir (@opt_L) {
			my $FullName = "$Dir/$Name";
			print "Checking $FullName..." if ($opt_v >= 2);
			if (-f $FullName) {
				print "........................found\n" if ($opt_v >= 2);
				print "$PrettyMode $Name\n";
				my $Status = RunDangerousCmd("systemctl $opt_M $Name");
				$Errors ++ if ($Status);
				next SERVICE;
			}
			else {
				print "\n" if ($opt_v >= 2);
			}
		}
	}

	# Nothing there.  Maybe it's a Systemd template.
	foreach my $Index (0..$#TemplateFiles) {
		foreach my $Dir (@opt_L) {
			my $FullPath = "$Dir/$TemplateFiles[$Index]";
			my $ServiceName = $TemplateServices[$Index];
			print "Checking $FullPath ($ServiceName)..." if ($opt_v >= 2);
			if (-f $FullPath) {
				print "........................found\n" if ($opt_v >= 2);
				print "$PrettyMode $ServiceName\n";
				my $Status = RunDangerousCmd("systemctl $opt_M $ServiceName");
				$Errors ++ if ($Status);
				next SERVICE;
			}
			else {
				print "\n" if ($opt_v >= 2);
			}
		}
	}

	# Not a template either.  Try SysV.
	foreach my $Name (@SysVNames) {
		my $FullPath = "/etc/init.d/$Name";
		print "Checking $FullPath..." if ($opt_v >= 2);
		if (-f $FullPath) {
			print "........................found\n" if ($opt_v >= 2);
			print "$PrettyMode $Name\n";
			my $Status = RunDangerousCmd("$FullPath $opt_M");
			$Errors ++ if ($Status);
			next SERVICE;
		}
		else {
			print "\n" if ($opt_v >= 2);
		}
	}

	print STDERR "Unable to locate $Parm -- no action taken.\n";
	$Errors++;
}

if ($ExitCode) {
	warn "$Prog failed.\n";
} else {
	#print "$Prog ended normally.\n";
}

$ExitCode=$Errors?10:0;
exit($ExitCode);


#
# D_Variants: return a list of +d and -d variants.
#
sub D_Variants {
	my ($Base,$Suffix) = @_;
	$Suffix //= '';			# Change to null string if undefined.
	my @List;
	push @List, $1 . $Suffix if ($Base =~ /^(.*)d$/);	# Strip trailing d, if present.
	push @List, $Base . 'd' . $Suffix;			# Add trailing d.
	return @List;
}
	

#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($opt_t) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($opt_v);
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_h: Usage
#
sub opt_h {

	my $Pagenater=$ENV{PAGENATER};
	$Pagenater="more" unless ($Pagenater);
	system("pod2text $RealBin/$RealScript | $Pagenater");
	exit(1);
}

=pod

=head1 startsys/stopsys/restartsys

=head3 Usage:  
        {startsys|stopsys|restartsys} [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config] [-t|-v] service...

        {startsys|stopsys|restartsys} -h

=head3 Flags:
	-e mailid:      Error: Send an execution report to this e-mail address
			if errors are detected.
	-L path		Library: systemd library search path.  May be repeated.
			Defaults to:
				/etc/systemd/system
				/lib/systemd
	-m mailid:      Mailid: Send an execution report to this e-mail address.
	-M mode:        Mode: Sets the operation mode to "start", "stop", or "restart",
			overriding the default determined from the script name.
	-p mailid:      Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:      Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-O config:      Insert the "config" configuration options from
			$ConfigFile.
			the command line at this point.
	-t	:	Test: echo commands instead of running them.
	-v	:	Verbose: echo commands before running them.
			May be repeated for more verbose output.
	-h      :       Help: display this panel

=head3 Parameters:
	service	:	one or more services to start/stop/restart

=head3 Notes:

=over 4

=item *
The same script is used to start, stop, or restart services.  It determines
the mode using the -M option if present, or else 
based on the script name ("startsys", "stopsys", "restartsys").

=item *
This script supports both systemd and /etc/init.d scripts in a manner 
consistent with systemd usage.  It determines the approach by searching
for the following items in the order indicated:

=over 4

=item -
A systemd .service file

=item -
A systemd template file, if the service name contains an @ symbol

=item -
An /etc/init.d script

=back

=item *

When searching for a systemd .service file, template file, or init.d script,
name variations are also attempted to accomodate historical inconsistencies
with appending a trailing d or not (e.g. "Is it amavis or amavisd?").

=back

=head3 Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.

=cut
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
IGNORE  /^\s*$/
IGNORE	/^\s*Job failed/
IGNORE	/^\s*Job ended normally/
IGNORE	/^\s*Unexpected messages/
IGNORE	/^\s*redirecting to systemctl\s*$/
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \d+/\d+/\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW    "^\s*Job ended normally with status 0 and signal 0$"
SHOW    "^\s*Test:"
SHOW    "^\s*Executing:"
SHOW	"^\s*debug:"
SHOW	"^\s*Checking "
SHOW	"^\s*Starting "
SHOW	"^\s*Stopping "
SHOW	"^\s*Restarting "
#
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
