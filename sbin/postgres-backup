#!/usr/bin/perl
#
# Back up the databases
#
use strict;
use warnings;
use lib '/usr/local/lib/perl5/site_perl';
use LogOutput;
use ProcessOptions;
use Text::ParseWords;
use FindBin qw($Bin);
use POSIX qw(strftime);
use File::Basename;

# Set up the environment.
$ENV{'PATH'}='/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/sbin';

# Initialize variables.
our $Prog=$0;				# Get our name, for messages.
$Prog=~s/^.*\///;			# Trim off the path, if present.
our @Args=@ARGV;			# Preserve orig command for ref.
our $ErrorFlag=0;			# No errors so far.
our $BaseDir=$ENV{HOME};		# Set our base directory.
our @parms;
our $Parms;
our %Exclude;				# Exclude list

our $opt_d;				# Debug flag.
our $opt_e;				# Error mail addresses.
our $opt_h;				# Help flag.
our $opt_l;				# Log file.
our $opt_m;				# Mail addresses.
our $opt_O;				# Option flag.
our $opt_o="/usr/local/backup/postgres";
our $opt_p;				# Normal page address.
our $opt_P;				# Error page addresses.
our $opt_r=7;				# Retention period.
our $opt_t;				# Test flag.
our $opt_U=$ENV{LOGNAME} || $ENV{USER} || getpwuid($<); # Default to our own user name.
our $opt_v;				# Verbose.
our $opt_z;				# Compress.

my $Syslog='user';			# Name of Syslog facility.  '' for no logging.
my $LogFile='';			# Log file name, or null for none.
my $ConfigDir = $Bin;
$ConfigDir =~ s"/[^/]*$"/etc";
my $ConfigFile="$ConfigDir/${Prog}.cfg";# Name of config file.
my $Subject;				# E-mail subject line.

# Set our base directory.
chdir($BaseDir) || die "Unable to cd to $BaseDir: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#	1) We define a new type l (lowercase L), which is a list (i.e. if
#	   specified multiple times, values are concatenated & blank separated.o
#	   Normal =s and =i would replace values instead of concatenate.
#	2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
my $OptSpec='d h t v z l=l m=l e=l p=l P=l o=s O=s r=s U=s';

# Load the config file.
my %Config;
if (-e $ConfigFile) {
        open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
        # Build a hash of settings found in the config file.
        while (<CONFIG>) {
                next if (/^\s*#/);      # Comment.
                next if (/^\s*$/);      # Blank line.
                my ($name,$settings)=/^\s*(\S+)\s*:\s*(.+)/;
                $name=~tr/[a-z]/[A-Z]/;
                $Config{$name}=$settings;
        }
	close CONFIG;
}

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}

if ($ErrorFlag) {exit $ErrorFlag;}	# Exit if errors were detected.
	
# Set up our logging and output filtering.
LogOutput({
        SYSLOG_FACILITY => $Syslog,
        MAIL_FILE => $opt_l,
        ALWAYS_MAIL_LIST => $opt_m,
        ERROR_MAIL_LIST => $opt_e,
        ALWAYS_PAGE_LIST => $opt_p,
        ERROR_PAGE_LIST => $opt_P,
});

# Build the backup file name.
my $DeletePattern;
$opt_o .= "/%Y-%m-%d.sql" if (-d $opt_o);	# Add file name if this is a directory.
$DeletePattern = basename($opt_o);		# Get the file name portion.
$DeletePattern =~ s/%./*/g;			# Convert substitution values to *
$opt_o=strftime($opt_o,localtime());		# Interp time vars (ours and theirs).
my $OutDir=dirname($opt_o);

# Next, delete any back-ups over $opt_r days old.  Presumably the nightly backups
# or at least the weekly back-ups have captured them.
RunDangerousCmd("find $OutDir -type f -name '$DeletePattern' -mtime +$opt_r -exec echo Deleting {} \\; -delete");

# Now back up all our databases.
RunDangerousCmd("su - postgres -c 'pg_dumpall --clean' > $opt_o");
if (-f $opt_o) {
	print commify((stat($opt_o))[7]) . " bytes written to $opt_o\n";
	RunDangerousCmd("gzip $opt_o") if ($opt_z);
}
else {
	die "Unable to locate output file $opt_o";
}

exit(0);


#
# RunDangerousCmd - run a command, unless we're testing.
#	Note: Returns status code, in which 0 (false) commonly means OK.
#
sub RunDangerousCmd {

	my($Command)=@_;		# Get our calling arguments.
	my($FH);			# Autovivified file handle.

	if ($opt_t) {
		print "test: $Command\n";
		return 0;
	} else {
		print "Executing: $Command\n" if ($opt_v);
		if (open($FH, "$Command 2>&1 |")) {
			while (<$FH>) {print;};
			close $FH;
		} else {
			
			$Command =~ s/^\s*(\S+)/$1/;
			warn "$Command failed to start with status $?: $!\n";
		}
		return $?;
	}
}



#
# Untaint  -- use very carefully!
#

sub untaint {
        local(@parms) = @_;
        foreach (@parms) {
                s/^(.*)$/$1/;
                $_=$1;
        }
        if (@parms == 1) {
                # Return scalar
                return $parms[$[];
        } else {
                # Return list
                return (@parms);
        }
}


#
# commify - insert commas in numbers.
sub commify {
	local $_ = shift;
	1 while s/^(-?\d+)(\d{3})/$1,$2/;
	return $_;
}


#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,$ENV{'PAGER'}?"| $ENV{'PAGER'}":"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Backup MySQL databases

Usage:	$Prog [-o dir] [-U username] [-r days] [-l logfile] [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config] [-v] [-t]
	$Prog [-h]

Flags:
	-e mailid:	Error: Send an execution report to this e-mail address
			if errors are detected.
	-h	:	Help: display this panel
	-l logfile:	Logfile: write a log to "logfile".  This is in addition to the
			syslog.
	-m mailid:	Mailid: Send an execution report to this e-mail address.
	-o output:	Output: Save the output in this file/directory.  If "output"
			is a directory, the default filename is yyyy-mm-dd.sql.  "Output"
			is processed by strftime, so % variables (a la `date`) are 
			interpreted.  Default value is /usr/local/backup/database.
				* See Warning below. *
	-O config:	Insert the "config" configuration options from
			$ConfigFile into
			the command line at this point.
	-p mailid:	Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:	Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-r days:	Retention: delete old backups after "days" days.  Default=7.
	-t:		Test: don't really run commands, just display them.
	-U username:	User: Log into the database as "username".  Defaults to current name.
	-v: 		Verbose: display each command before executing it.
	-z		Zip: gzip the output files when going to disk.

Examples:

Warning:  Execution of this script causes old files (per -r) in the output directory
		to be deleted.

Return codes:
	0	:	Normal termination
	1	:	Help panel displayed.
	2	:	Invalid or unrecognized command line options.
	3	:	Invalid or unrecognized command line option value.
	4	:	Incorrect command line parameters.
	5	:	Unexpected message found in output.
ENDUSAGE
close PAGENATER;
exit 1;
}


#
# opt_x: handle exclude list.
#
sub opt_r {
	my($Value) = @_;
	if ($Value =~ /^[1-9]\d*$/) {
		$opt_r = $Value;
	}
	else {
		warn "Invalid retention period: $Value\n";
		$ErrorFlag = 8;
	}
}


#
# opt_x: handle exclude list.
#
sub opt_x {
	my($Directory)=@_;
	$Exclude{$Directory}=1;
}

#
# Clean-up routine.
#
sub Cleanup {
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:	Ignore - Don't display this message, it's not interesting.
#		LogOnly - Write this message to the syslog and log file, but
#			don't display it on STDOUT.
#		Show - Display this message, but it's not an error condition.
#		# - This is a comment, ignore it.
#
#  Pattern:	an ordinary perl pattern.  All patterns for a given score
#		are joined by logical OR conditions.
#
#  Notes:
#	1) The "Type" parameter may be specified in upper, lower, or mixed case.
#	2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
IGNORE	/^\s*$/
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY	/^Command: /
#
# These are normal messages that we want to see.
#
SHOW	/^\S+ ended normally with status 0 and signal 0$/
SHOW	/^debug:/
SHOW	/^test:/
SHOW	/^Executing:/
SHOW	"^\s*Deleting /usr/local/backup/postgres/"
SHOW	"^[0-9,]+ bytes written to \S+$"
#
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
