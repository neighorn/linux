#!/usr/bin/perl
#
# =====Description====
#
use strict;
use warnings;
use LogOutput;
use ProcessOptions;
use Text::ParseWords;
use POSIX qw(strftime);
use Fcntl qw(:flock :mode :DEFAULT);
use File::Basename;

# Initialize variables.
my $Prog=$0;			# Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";		# Trim off the path, if present.
$ENV{PATH} = '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';
my @Args=@ARGV;			# Preserve orig command for ref.
my $ErrorFlag=0;		# No errors so far.
my $ConfigFile="/usr/local/etc/${Prog}.cfg";     # Name of config file.
my $JobLockFile;		# Name of our lock file.
my $JOBLOCKFH;			# Lock file handle.
our $Errors=0;
our %Config;
our $opt_d;
our $opt_e;
our $opt_m;
our $opt_p;
our $opt_P;
our $opt_t;
our $opt_v;
our @opt_x;
our @opt_X;
our $opt_D;
our $opt_C=5;		# Number of cycles to keep.
our @Parms;	
our $Parms;
my %TypeExclude = (	# Populate a default list of types to exclude.
	'binfmt_misc' 		=> 1,
	'cgroup' 		=> 1,
	'debugfs' 		=> 1,
	'devpts' 		=> 1,
	'devtmpfs' 		=> 1,
	'fusectl' 		=> 1,
	'fuse.gvfs-fuse-daemon'	=> 1,
	'nfs' 			=> 1,
	'nfsd' 			=> 1,
	'none' 			=> 1,
	'proc' 			=> 1,
	'rpc_pipefs' 		=> 1,
	'securityfs' 		=> 1,
	'subfs' 		=> 1,
	'sysfs' 		=> 1,
	'sysfs' 		=> 1,
	'tmpfs' 		=> 1,
	'usbfs' 		=> 1,
);
our $ExitCode;

my $HostName = `hostname`;
chomp $HostName;
$HostName =~ s/\..*$//;		# Strip domain.
our $BaseDir="/usr/local/backup/$Prog";	# Set our base directory.
#
# ---------------------------------------------------------
#
# Identify the output directory.  Do this early for Cleanup().
#
our $OutputDir;			# Name of directory we're creating.
if ($opt_D) {
	$OutputDir = $opt_D;
	$BaseDir = basename($OutputDir);
}
else {
	$OutputDir="$BaseDir/%m-%d";
}
$OutputDir =~ s/%C/$HostName/g;			# Interpret %C.
$OutputDir=strftime($OutputDir,localtime());	# Interpret other variables.


chdir "/usr/local/sbin" || die "Unable to change directories to /usr/local/sbin: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#       1) We define a new type l (lowercase L), which is a list (i.e. if
#          specified multiple times, values are concatenated & blank separated.o
#          Normal =s and =i would replace values instead of concatenate.
#       2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
my $OptSpec='C=s D=s h t m=l e=l O=s p=l P=l x=l X=l t v';

# ---------------------------------------------------------
#
# Load the config file.
#
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=~tr/[a-z]/[A-Z]/;
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# ---------------------------------------------------------
#
# Process the config file defaults if present.
#
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}
if ($ErrorFlag) {exit $ErrorFlag;}      # Exit if errors were detected.
	
# Set up our logging and output filtering.
LogOutput({
	ALWAYS_MAIL_LIST => $opt_m,
	ERROR_MAIL_LIST => $opt_e,
	ALWAYS_PAGE_LIST => $opt_p,
	ERROR_PAGE_LIST => $opt_P,
	CLEAN_UP => \&Cleanup,
	SYSLOG_FACILITY => 'user',
});

# Verify the command line.
die("Excess parameters on the command line.  See \"$Prog -h\" for usage.")
	if ($Parms);
die("Invalid number \"$opt_C\" for -C.  See \"$Prog -h\" for usage.")
	unless ($opt_C =~ /^\s*\d+\s*$/);

# Add any additional file type exclusions.
foreach (@opt_X) {
	$TypeExclude{$_}=1;
}


# ---------------------------------------------------------
#
# Delete any failed back-ups.
#
RunDangerousCmd("rm -rf $BaseDir/*.bad 2> /dev/null");

# ---------------------------------------------------------
#
# Keep the most recent $opt_C back-ups.
#
if (open(my $FHLS,"ls -t $BaseDir 2> /dev/null |")) {
        my $Count=0;
	while (<$FHLS>) {
		chomp;
		next unless (-d "$BaseDir/$_");	# Skip non-directories.
		$Count++;
                RunDangerousCmd("rm -rf $BaseDir/$_") if ($Count >= $opt_C);
	}
	close $FHLS;
} else {
	warn "Unable to open ls command: $!\n";
}

# ---------------------------------------------------------
#
# Create the output directory if necessary.
#
RunDangerousCmd("mkdir -p --mode=750 $OutputDir") unless (-e $OutputDir);
RunDangerousCmd("chgrp sys $OutputDir") &&
	die "Unable to set group for $OutputDir: $!\n";
if (! $opt_t ) {
	chdir $OutputDir || die "Unable to change directories to $OutputDir: $!\n";
}

# ---------------------------------------------------------
#
# Check for conflicting jobs.
#
$JobLockFile = "$OutputDir/$Prog.lock";
if (!$opt_t and !open($JOBLOCKFH,'>>',$JobLockFile)) {
        print "Unable to create/open $JobLockFile: $!\n";
        exit 11;
}
if (!$opt_t and !flock($JOBLOCKFH, LOCK_EX | LOCK_NB)) {
        my @stat = stat($JobLockFile);
        my $mdate = strftime("%Y-%m-%d",localtime($stat[8]));
        $mdate = 'today' if ($mdate eq strftime("%Y-%m-%d",localtime(time())));
        print "Skipped this job due to a conflicting job in progress per "
                . qq<"$JobLockFile" dated $mdate at >
                . strftime(
                        "%H:%M:%S",
                        localtime((stat($JobLockFile))[8]))
                . "\n"
                ;
        exit 11;
}

# ---------------------------------------------------------
#
# Use the mount command to determine what to back up.
#
if (open(my $FHMOUNT,'mount |')) {
	MOUNT: while (<$FHMOUNT>) {
		chomp;

		# Skip transient file systems based on type.
		/\stype\s+(\S+)\s/;
		next if ($TypeExclude{$1});


		# Skip anything under /mnt as being temporary.
		next if (m"^\S+ on /mnt/");

		# Skip our own output area.
		my $BackupRoot = $BaseDir;
		$BackupRoot =~ s"/[^/]*$"";		# Drop host name.
		next if (m"^\S+ on $BackupRoot");
		
		# Get the mount point, and compare to our exclude list.
		my $MountPt;
		($MountPt)=(split(/\s+/))[2];
		foreach my $ExcludedMount (@opt_x) {
			next MOUNT if ($MountPt =~ m"^$ExcludedMount(/.*)?$");
		}

		# Build the output file name.
		my $OutputFile;
		my $OutputName;
                ($OutputName="$MountPt") =~ s"^.*/"";
                $OutputName="root" if ($OutputName eq '');
                $OutputFile="$OutputName.tgz";

		# Do it.
		my $ExcludeFile = "$BaseDir/$OutputName.exclude";
		if (-f $ExcludeFile) {
			$ExcludeFile = "-X $ExcludeFile";
		} else {
			$ExcludeFile = "";
		}
			
		print "  Backing up $MountPt\n";
                RunDangerousCmd("tar -cz --one-file-system " .
			"-f $OutputDir/$OutputFile " .
			"-C $MountPt " .
                        "$ExcludeFile ."
                        );
	}
} else {
	die "Unable to issue mount command: $!\n";
}

# ---------------------------------------------------------
#
# Capture recovery information here, also.
#
RunDangerousCmd("recovery-info -o $OutputDir/recovery");

# ---------------------------------------------------------
#
# Release the job lock.
#
if ($JOBLOCKFH) {
        close $JOBLOCKFH;
        unlink $JobLockFile;
}


if ($ExitCode) {
	warn "$Prog failed.\n";
} else {
	#print "$Prog ended normally.\n";
}

$ExitCode=$Errors?10:0;
exit($ExitCode);

# ---------------------------------------------------------
#
# Cleanup - runs at end of job.
#
sub Cleanup {
	my ($ExitCode,$LogFile,$ErrorsDetected) = @_;
	if ($ExitCode && $OutputDir) {
		warn "Job failed with exit code $ExitCode -- moving $OutputDir to $OutputDir.bad\n";
		RunDangerousCmd("mv $OutputDir $OutputDir.bad");
	}
	
	return $ExitCode
}

# ---------------------------------------------------------
#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($opt_t) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($opt_v);
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


# ---------------------------------------------------------
#
# opt_h: Usage
#
sub opt_h {

	my $ExcludeTypes = join(', ',sort(keys(%TypeExclude)));
	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Back-up key file-systems

Usage:  $Prog [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config] [-t|-v] [-D output-dir] [-x mountpoint] [-C cycle-count]
	$Prog -h

Flags:
	-C cycle-count:	Cycles: Keep "cycle-count" cycles.  Default is 5.  Older
			backups will be deleted.  See cautionary note below.
	-D output-dir:	Write to "output-dir".  Default is:
			/usr/local/backup/sysbackup/%m-%d.  The output directory
			may contain % variables.  %C is replaced with the short
			host name.  Remaining % variables are interpreted by
			strftime.
	-e mailid:      Error: Send an execution report to this e-mail address
			if errors are detected.
	-h      :       Help: display this panel
	-m mailid:      Mailid: Send an execution report to this e-mail address.
	-p mailid:      Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:      Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-O config:      Insert the "config" configuration options from
			$ConfigFile.
			the command line at this point.
	-t	:	Test: echo commands instead of running them.
	-v	:	Verbose: echo commands before running them.
	-x mountpoint: 	eXclude: exclude this mount point.  May be repeated.
	-X mounttype:	eXclude: exclude any mount points of this type (e.g.
			"ext4").  May be repeated.  This list is prepopulated
			with $ExcludeTypes.

Parameters:
	(none)

Notes:
As indicated above, cycle processing implies deleting older directories.  If
cycle processing is requested with -C, then any directory in the parent is a
candidate for deletion.  For example, with the default output directory of
/usr/local/backup/sysbackup/%m-%d, any directory contained within
/usr/local/backup/sysbackup is a candidate for deletion.  Therefore, the
parent directory should only be used for holding these backups.

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# ---------------------------------------------------------
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
IGNORE	/^tar: .* socket ignored$/
IGNORE	"^\s*ls: (cannot access )?/usr/local/backup/\S+/\[01\]\[0-9\]-\[0-3\]\[0-9\]: No such file or directory$"
IGNORE	"^tar: Removing leading `/' from member names$"
IGNORE	"^tar: .*: file changed as we read it$"i
IGNORE	"^tar: .*: file removed before we read it$"i
IGNORE	"^tar: .*: File shrank by \d+ bytes"
IGNORE	"^tar: .*: Cannot stat: No such file or directory$"
IGNORE	"^tar: Error exit delayed from previous errors$"
IGNORE	"^\s*512 bytes \(512 B\) copied, \d+.\d+ s(econds)?, \d+(\.\d+)? [kmgKMG]B$"
IGNORE	"^\s*512 bytes \(512 B\) copied, \d+(\.\d+)?(e-\d+)? s(econds)?, \d+(\.\d+)? [kmgKMG]B/s$"
IGNORE	"^\s*recovery-info started on "
IGNORE  /^\s*$/
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW    "^\s*Backing up "
SHOW    /^\s*Job ended normally with status 0 and signal 0$/
SHOW    /^\s*Test:/
SHOW    /^\s*Executing:/
SHOW	/^\s*debug:/
#
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
