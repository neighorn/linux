#! /usr/bin/perl

use LogOutput;
use ProcessOptions;
use Text::ParseWords;

# Set up the environment.
$ENV{'PATH'}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';

# Initialize variables.
$Prog=$0;			# Get our name, for messages.
$Prog=~s/^.*\///;		# Trim off the path, if present.
@Args=@ARGV;			# Preserve orig command for ref.
$ErrorFlag=0;			# No errors so far.
$Syslog='user';			# Name of Syslog facility.  '' for no logging.
$LogFile='';			# Log file name, or null for none.
$BaseDir='/usr/local/etc';	# Set our base directory.
$ConfigFile="$BaseDir/${Prog}.cfg";	# Name of config file.
$Limit=21;			# Number of days to keep old versions.

# Set our base directory.
chdir($BaseDir) || die "Unable to cd to $BaseDir: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#	1) We define a new type l (lowercase L), which is a list (i.e. if
#	   specified multiple times, values are concatenated & blank separated.o
#	   Normal =s and =i would replace values instead of concatenate.
#	2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
$OptSpec='d h m=l e=l p=l P=l o=s O=s k=s t v';

# Load the config file.
if (-e $ConfigFile) {
        open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
        # Build a hash of settings found in the config file.
        while (<CONFIG>) {
                next if (/^\s*#/);      # Comment.
                next if (/^\s*$/);      # Blank line.
                ($name,$settings)=/^\s*(\S+)\s*:\s*(.+)/;
                $name=~tr/[a-z]/[A-Z]/;
                $Config{$name}=$settings;
        }
}

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}

if ($ErrorFlag) {exit $ErrorFlag;}	# Exit if errors were detected.
	
# Set up our logging and output filtering.
LogOutput('',$Syslog,$LogFile,$opt_m,$opt_e,$opt_p,$opt_P);

# If we're using the default output directory, perform clean up of prior
# default directories and assign the default output directory name.
if (!$opt_o) {
	my $Prefix="/recovery-";
	RunDangerousCmd("find $Prefix* -prune -type d -mtime +$Limit -exec echo Removing {} \\; -exec rm -rf {} \\;");
	my($day,$month,$year) = (localtime())[3..5];
	$month++;		# Convert 0-11 to 1-12.
	$year+=1900;		# Convert "years since 1900".
	$opt_o=sprintf("$Prefix%04d%02d%02d",$year,$month,$day);
}
if (! -d $opt_o) {
	RunDangerousCmd("mkdir $opt_o") &&
		die "Unable to create $opt_o: $!";
}

# Capture data for each disk present.
my $FirstDisk;		# Need a valid disk name later for parted.
open($FDISK, "fdisk -l 2> /dev/null | grep '^Disk /dev/' | grep -vE '/dev/(mapper|md|dm-)' |") ||
	die("Unable to start fdisk process: $!\n");
while (<$FDISK>) {
	chomp;
	s/^Disk\s*//;
	s/:\s.*$//;
	$InputName = $_;
	$FirstDisk=$InputName unless ($FirstDisk);
	($OutputName=$_) =~ s"^/dev/"$opt_o/";
	$OutputName .= ".sector0";
	RunDangerousCmd("mv $OutputName $OutputName.1")
		if (-f $OutputName);
	RunDangerousCmd("dd if=$InputName of=$OutputName bs=512 count=1");
	$OutputName =~ s"\.sector0"";	# Two steps make sure we don't ...
	$OutputName .= ".info";		# ... fail and overwrite sector0 file.
	RunDangerousCmd("smartctl -i $InputName > $OutputName");
	$OutputName =~ s/.info$/.parted/;
	RunDangerousCmd("parted $InputName p > $OutputName");
	$OutputName =~ s/.parted$/.gdisk/;
	RunDangerousCmd("parted $InputName p > $OutputName");
}
close $FDISK;

# Document partition maps.  Note that fdisk and sfdisk work for all disks
# if no specific disk is named.
RunDangerousCmd("fdisk -l > $opt_o/fdisk.out");
RunDangerousCmd("sfdisk -l -d > $opt_o/sfdisk.out");
RunDangerousCmd("parted -s $FirstDisk print all > $opt_o/parted.out");
RunDangerousCmd("(lsscsi -H; lsscsi -d) > $opt_o/lsscsi.out");

# Document the current mounts and sizes.
RunDangerousCmd("df -h > $opt_o/df.out");

# Capture installed packages.
RunDangerousCmd("rpm -q -a | sort > $opt_o/rpm.out");
RunDangerousCmd("yum list -q installed | sort > $opt_o/yum.out");

# Capture the normal security tables.
RunDangerousCmd("iptables -nvL > $opt_o/iptables.out");

# Capture swap space information.
RunDangerousCmd("swapon -s > $opt_o/swapon.out");

# Capture lots of system facts, if we can.
RunDangerousCmd("facter > $opt_o/facter.out");

# Capture LVM configuration information.
RunDangerousCmd("lvm vgcfgbackup -f $opt_o/vg-%s.out");
RunDangerousCmd("pvdisplay > $opt_o/pvdisplay.out");
RunDangerousCmd("vgdisplay > $opt_o/vgdisplay.out");
RunDangerousCmd("lvdisplay > $opt_o/lvdisplay.out");

# Capture network configuration.
RunDangerousCmd("ifconfig -a > $opt_o/ifconfig.out");
RunDangerousCmd("netstat -nr > $opt_o/netstat.out");

# Capture MD and DRBD configuration.
RunDangerousCmd("cp /proc/mdstat $opt_o/mdstat.out") if (-e "/proc/mdstat");
RunDangerousCmd("cp /proc/drbd $opt_o/drbd.out") if (-e "/proc/drbd");

# Capture hardware information.
RunDangerousCmd("dmidecode > $opt_o/dmidecode.out");
RunDangerousCmd("lshw > $opt_o/lshw.out");
	
exit(0);


#
# SampleSub - sample subroutine
#
sub SampleSub {

	#my($x,$y,$z,...)=@_;		# Get our calling arguments.

	# Declare local variables.
	#my($a);		# Variable description.	

}

#
# RunDangerousCmd - run a command, unless we're testing.
#	Note: Returns status code, in which 0 (false) commonly means OK.
#
sub RunDangerousCmd {

# 	This version is modified for recovery-info to test for the 
#	existence of commands before running them.

	my($Command)=@_;		# Get our calling arguments.
	my($FH);			# Autovivified file handle.

	if ($opt_t) {
		print "Test: $Command\n";
		return 0;
	} else {

		# See if this command exists on this system.
		my $CommandName = $Command;
		$CommandName =~ s/^\s*//;
		$CommandName =~ s/^\(\s*//;
		$CommandName =~ s/ .*$//;
		if (system("which $CommandName > /dev/null 2>&1")) {
			print "Not found: $Command\n" if ($opt_v);
			return 0;
		}

		# Run it.
		print "Executing: $Command\n" if ($opt_v);
		if (open($FH, "$Command 2>&1 |")) {
			while (<$FH>) {print;};
			close $FH;
		} else {
			($CmdName = $Command) =~ s/^\s*(\S+)/$1/;
			warn "$CmdName failed to start with status $?: $!\n";
		}
		return $?;
	}
}




#
# Untaint  -- use very carefully!
#

sub untaint {
        local(@parms) = @_;
        foreach (@parms) {
                s/^(.*)$/$1/;
                $_=$1;
        }
        if (@parms == 1) {
                # Return scalar
                return $parms[$[];
        } else {
                # Return list
                return (@parms);
        }
}



#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,$ENV{'PAGER'}?"| $ENV{'PAGER'}":"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - (1 line description here)

Usage:	$Prog [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config]
		[-k keyfile]
	$Prog [-h]

Flags:
	-e mailid:	Error: Send an execution report to this e-mail address
			if errors are detected.
	-m mailid:	Mailid: Send an execution report to this e-mail address.
	-p mailid:	Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:	Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-O config:	Insert the "config" configuration options from
			$ConfigFile into
			the command line at this point.
	-t	:	Test: don't really run dangerous commands
	-v	:	Verbose: show dangerous commands before executing them
	-h	:	Help: display this panel

Examples:

Return codes:
	0	:	Normal termination
	1	:	Help panel displayed.
	2	:	Invalid or unrecognized command line options.
	3	:	Invalid or unrecognized command line option value.
	4	:	Incorrect command line parameters.
	5	:	Unexpected message found in output.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:	Ignore - Don't display this message, it's not interesting.
#		LogOnly - Write this message to the syslog and log file, but
#			don't display it on STDOUT.
#		Show - Display this message, but it's not an error condition.
#		# - This is a comment, ignore it.
#
#  Pattern:	an ordinary perl pattern.  All patterns for a given score
#		are joined by logical OR conditions.
#
#  Notes:
#	1) The "Type" parameter may be specified in upper, lower, or mixed case.
#	2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
IGNORE	/^\s*$/
IGNORE	"^\s*Disk /dev/md\d+ doesn't contain a valid partition table$"
IGNORE	"^\s*1\+0 records (in|out)\s*$"
IGNORE	"^\s*Removing /"
IGNORE	"^\s*find: .*: No such file or directory$"
IGNORE	/^\s*Volume group "\S+" successfully backed up.$/
IGNORE	"^\s*No volume groups found$"
IGNORE	/^\s*File descriptor \d+ left open$/
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY	/^Command: /
#
# These are normal messages that we want to see.
#
SHOW	"^\S+ started on \S+ on \d\d/\d\d/\d\d\d\d at \d\d:\d\d:\d\d$"
SHOW	"^512 bytes \(512 B\) copied,"
SHOW	/^Job ended normally with status 0 and signal 0$/
SHOW	/^Test:/
SHOW	/^Executing:/
SHOW	/^Not found:/
#
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
