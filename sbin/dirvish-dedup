#!/usr/bin/perl -w

#
# External packages
#
use strict;
use warnings;
use Cwd;
use Digest::MD5::File qw(file_md5_hex);
use Dumpvalue;
use File::Compare qw(compare);
use File::Copy qw(cp);
use File::Find;
use File::Temp qw(tempfile);
use File::Basename;
use Getopt::Long qw(GetOptionsFromArray :config gnu_compat permute bundling);
use POSIX qw(strftime);
use Fcntl;
use FindBin qw($RealBin $RealScript $Script);
use String::ShellQuote;		# For shell_quote.
use Data::Dumper::Simple;
use Text::ParseWords;
use Sys::Syslog;
use File::Glob 'bsd_glob';
use Mail::Sendmail;

# 
# Prototype declarations.
#
sub PrintStatistics ();
sub RegisterFile ($$@);
sub RegisterInode ($@);
sub FindMatch ($@);
sub ElapsedTime ();
sub ProcessOptions (@);

#
# Global variables
#
our $Prog = $Script;       # Get our program name, for messages and work files.
our %Opt;                  # Command line options.
my $ConfigFile = "/usr/local/etc/$Prog.cfg";
our %Config;		   # Configuration file data.
our @Parms;                # Parameters found in @ARGV.
our $Cancel          = 0;  # 1 = cancel requested.
our $CancelConfirmed = 0;  # 1 = cancel confirmed.
our $Candidate;		   # Current file we're processing.  Global for stats.
our %UniqueFiles;          # Hash of known file signatures (MD5+selected inode data).
our %Inodes;               # Hash of known inodes and what to link them to.
our $Usedspc       = 0;    # Total space examined.
our $Savedspc      = 0;    # Total space recovered.
our $PrintProgress = 0;    # Set to 1 by alarm clock or SIGUSR1.
our $PrintStats    = 0;    # Set to 1 by SIGUSR1 for supplemental report.
our $ETA           = 0;    # Estimated completion.
our $LOG_FH;
our $Root;                 # Current root dir (ARGV item).
our $LastCheckpoint = time();	# Time of last checkpoint.
our $WriteCheckpoint = 0;  # 1 = time to write a checkpoint file.
our @OrigARGV = @ARGV;	   # For checkpoint.
our @Parms_Copy;		   # In case CheckInterrupt has to reuse @Parms.
our $AlarmInterval;	   # How long between alarms.
our $ParmCount;		   # How many args we have, for stats.
our $CurrentArg = 0;	   # Which arg we're on, for stats.
our $StartTime = time();   # Start time, for elapsed reports.
our $tl_dirs_total;	   # # of top level dirs in this root.
our $tl_dirs_doing;	   # Which top level dir we're on in this root.
our $td_slashes;	   # Number of slashes to our current top domain.
our $LastPrint='';	   # What we last printed (stats, progress);
our $LastStats='';         # Our most recent statistics report.
our $LastProgress = 0;	   # The last time we generated a progress report.
our $CheckpointDuration;   # The time it takes to write a checkpoint file.

#
# Signals.
#
$SIG{INT} = sub {
    warn "\nInterrupt request accepted.  Please stand-by...\n";
    $Cancel++;
};
$SIG{USR1} = sub {

    # User requested a status update.
    $PrintProgress = 1;
    $PrintStats    = 1;
};
$SIG{HUP} = $SIG{USR1};    # Don't die because the user sent the default kill.


    # Set us up for regular progress reports.
$SIG{ALRM} = sub {
    print "Alarm rang.\n" if ($Opt{debug});
    $PrintProgress = 1 if ( 
           ( $Opt{progress} or $Opt{statfile} )
       and time() - $LastProgress >= $Opt{proginterval});	# If they want progress reports, queue it up.
    $WriteCheckpoint = 1 if (time() - $LastCheckpoint >= $Opt{cpinterval}); 
    alarm($AlarmInterval - (time() % $AlarmInterval));	# Schedule the next alarm.
};

#
# Load the configuration file.
#
LoadConfig($ConfigFile);

#
# Process options.
#
exit 8 unless ProcessOptions(@ARGV);

our $DV = Dumpvalue->new(
    tick         => qq{"},
    quoteHighBit => 1,
    printUndef   => 1,
);

#
# Do some more initializing.
#

my %reported;
my $files         = 0;
openlog($Prog,'pid','user');

select(STDERR);
$| = 1;
select(STDOUT);
$| = 1;

# Initialize the statistics file if requested.
PrintStatFile(strftime("Started $Prog at %D %T\n",localtime()));

#
# Begin processing arguments.
#
die "No directories specified.  Enter $Prog -h for usage.\n" unless (@Parms);
# If we only have one argument, move into subdirectories.  This makes stats and
# --reverse more useful.
while (@Parms == 1 and -d $Parms[0]) {
	# Only one argument.  Move down one leve.
	@Parms = bsd_glob($Parms[0] . '/*');
}
if ($Opt{reverse}) {
	@Parms_Copy = reverse(@Parms);
}
else {
	@Parms_Copy = @Parms;
}
$ParmCount = 0+@Parms;		# For stats.
foreach $Root ( @Parms_Copy ) {
    $Root =~ s"/+$"";		# Strip trailing /
    $tl_dirs_total = 0;
    $tl_dirs_doing = 0;
    $CurrentArg++;		# Increment count for stats.
    if ( !cwd($Root) ) {
        warn "Unable to cd to $Root -- skipped: $!\n";
        next;
    }
    my $FirstNode = $Root;
    $FirstNode =~ s"(/?[^/]+)/"$1";
    if (-l $FirstNode) {
    	print "\n" if ($LastPrint eq 'stats');
	print strftime("%D %T $FirstNode is a symbolic link -- $Root skipped\n",localtime());
	next;
    }
    if (-l $Root) {
    	print "\n" if ($LastPrint eq 'stats');
	print strftime("%D %T $Root is a symbolic link -- $Root skipped\n",localtime());
	next;
    }
    print "\n" if ($LastPrint eq 'stats');
    print strftime("%D %T Starting $Root" . ' 'x30 . "\n",localtime())
        if (@Parms > 1);
    syslog('info',"Starting $Root");
    find(
        {
            wanted     => \&ProcessFile,
            no_chdir   => 1,
            preprocess => sub { return sort(@_); },
        },
        $Root
    );
    PrintStatistics();		# Final stats for this argv item.
    print "\n";
    if ($CancelConfirmed) {
        printf "Writing final checkpoint file.  ";
        if ($CheckpointDuration) {
       	    print "Estimated time = $CheckpointDuration seconds.\n";
	}
	else {
            print "\n";
        }
    }
    WriteCheckpoint();
    last if $Cancel and $CancelConfirmed;
}

#
# Done.  Wrap up the log file and write the elapsed time.
#
if ($LOG_FH) {
    chmod(((stat $LOG_FH)[2] & 07777) | 0100, $LOG_FH);	# Add u+x.
    close $LOG_FH;
};

my $Elapsed = ElapsedTime();
my $Summary = strftime( "Done @ %T on %D.  Elapsed time = $Elapsed.", localtime());
print "\n$Summary\n";
SendMail($Summary) if ($Opt{mail});
PrintStatFile("$Summary<br>$LastStats") if ($Opt{statfile});
exit 0;


#
# Load config file
#
sub LoadConfig {

    foreach my $ConfigFile (@_) {
        if (-e $ConfigFile) {
                open(CONFIG,$ConfigFile) || warn("Unable to open $ConfigFile: $!\n");
                # Build a hash of settings found in the config file.
                while (<CONFIG>) {
                        next if (/^\s*#/);      # Comment.
                        next if (/^\s*$/);      # Blank line.
                        chomp;
                        my ($name,$settings)=split(/:?\s+/,$_,2);
                        $name=uc($name);        # Name is not case sensitive.
                        $settings=~s/\s+$//;    # Trim trailing spaces.
                        $Config{$name}.=$settings . ',' ;
                }
                close CONFIG;
                foreach (keys(%Config)) {
                        $Config{$_} =~ s/,$//;  # Remove trailing comma
                }
        }
        foreach (keys(%Config)) { s/,$//;};     # Trim off trailing commas.
    }
    
    # Process the config file defaults if present.
    unshift @main::ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
            if (defined($Config{'ALLJOBS'}));
}


#
# ProcessOptions
#
sub ProcessOptions (@) {

    foreach my $name (qw(dry-run logfile progress stats eta compare debug)) {
    	$Opt{$name} = 0 unless (exists($Opt{$name}));
    }
    
    # Define our option specifications.  Use subroutines for everything because
    # Getopt::Long doesn't seem to work right if called twice when just 
    # working with variables or a hash directly.  Wc might get called twice if
    # the user uses ^C and sets new options.
    my %OptSpec = (
	'<>'					=>	sub{push @Parms,shift;},
	'cd|C=s'				=>	sub{chdir($_[1]) or die "Unable to cd to $_[1]:$!\n";},
	'compare!'				=>	sub{$Opt{compare}=$_[1];},
	'cpinterval:600'			=>	sub{$Opt{cpinterval}=$_[1];},
	'debug+'				=>	sub{$Opt{debug}++;},
	'dry-run|n'				=>	\&Opt_dry_run,
	'eta!'					=>	sub{$Opt{eta}=$_[1];},
	'help|h'				=>	\&Opt_help,
	'loadmap|loadmaps|load-map|load-maps=s'	=>	\&Opt_loadmap,
	'logfile|l=s'				=>	\&Opt_logfile,
	'mail|m=s@'				=>	sub{push @{$Opt{mail}},$_[1];},
	'maxlinks=i'				=>	sub{$Opt{maxlinks}=$_[1];},
        'optionset|O'				=>	\&Opt_optionset,
	'proginterval:60',			=>	sub{$Opt{proginterval}=$_[1];},
	'progress!'				=>	sub{$Opt{progress}=$_[1];},
	'reverse'				=>	sub{$Opt{reverse}=$_[1];},
	'statfile=s'				=>	sub{$Opt{statfile}=$_[1];},
	'statformat=s'				=>	sub{$Opt{statformat}=$_[1];},
        'statinterval:5000'			=>	sub{$Opt{statinterval}=$_[1];},
        'stats!'				=>	sub{$Opt{stats}=$_[1];}
    );
    return 0 unless (GetOptionsFromArray(\@_,%OptSpec));

    print "debug: options:" . Dumper(%Opt) if ($Opt{debug});


    # Manage the alarm clock.  Do this last so we don't start the timer before long processes.
    $Opt{cpinterval} = 600 unless ($Opt{cpinterval});
    if ($Opt{cpinterval} <= 60) {
        warn "Invalid value for --cpinterval -- set to default.\n";
        $Opt{cpinterval} = 600;
    }
    $Opt{proginterval} = 300 unless ($Opt{proginterval});
    if ($Opt{proginterval} <= 2) {
        warn "Invalid value for --proginterval -- set to default.\n";
        $Opt{proginterval} = 30;
    }
    $Opt{statinterval} = 5000 unless ($Opt{statinterval});
    if ($Opt{progress} or $Opt{statfile}) {
         $AlarmInterval=gcf($Opt{proginterval},$Opt{cpinterval});
    }
    else {
         $AlarmInterval=$Opt{cpinterval};
    }
    $AlarmInterval = 10 if ($AlarmInterval < 10);
    alarm($AlarmInterval - (time() % $AlarmInterval));	# Schedule the first alarm.
    return 1;
}


#
# Opt_dry_run - dry-run flag
#
sub Opt_dry_run {

    my(undef,$arg) = @_;
    $Opt{"dry-run"} = $arg;
    warn "Running dry-run without a logfile -- no record of proposed changes will be kept.\n"
        if ($Opt{"dry-run"} and not $Opt{logfile});
    print "Running in dry-run mode...\n"
        if ( $Opt{'dry-run'} );
}



#
# Opt_help - display the help map
#
sub Opt_help {
	system("pod2text $RealBin/$RealScript");
}
    

#
# Opt_loadmap - load a prior map file.
#
sub Opt_loadmap {

    my(undef,$map) = @_;
    # Load a pre-existing map file
    if ($map) {
        if (open(my $MAPFH,'<',$map)) {
            print "Loading $map\n";
            local %Opt;		# Don't want these updated.
            local @ARGV;	# Don't want these updated.
            my $OldEOL = $/;
            $/ = undef;
            my $PriorMaps = <$MAPFH>;
            $/ = $OldEOL;
            close $MAPFH;
            eval($PriorMaps);
            my $UniqueCnt = Commify(0+keys(%UniqueFiles));
            my $InodesCnt = Commify(0+keys(%Inodes));
            print "Load-maps: $UniqueCnt unique files and $InodesCnt known inodes loaded\n";
        }
        else {
            warn "Unable to open map file: $!";
        }
    }
}


#
# Opt_logfile - dry-run flag
#
sub Opt_logfile {

    $Opt{logfile} = $_[1];
    close $LOG_FH if ($LOG_FH);			# Switching log files?
    if ( $Opt{logfile} ) {
        sysopen( $LOG_FH, $Opt{logfile}, O_CREAT +O_WRONLY +O_TRUNC )
          || die "Unable to open $Opt{logfile}: $!";
        $LOG_FH->autoflush(1);
    }
}


#
# Opt_optionset - load a set of options from the config file.
#
sub Opt_optionset {

    my $optionset = uc($_[1]);

    if (exists($Config{$optionset})) {
	ProcessOptions(shellwords($Config{$optionset}));
    }
    else {
        warn "Option set $optionset not found in config file -- skipped\n";
    }
}


#
# gcf - calculate the greatest common factor of two numbers.
#
sub gcf {
	my ($x, $y) = @_;
	($x,$y) = ($y,$x%$y) while $y;
	return $x;
}



#
# Commify - format numbers with commas.
#
sub Commify ($) {
    local $_ = shift;
    s/(\d)(?=(\d{3})+$)/$1,/g;
    $_;
}

#
# ReplaceWithLink - replace a file with a hard link to another.
#
#     $success = ReplaceWithLink($some_file,$another)
#
#     $some_file is always absolute, $another is always in the current
#     directory
#
#     ReplaceWithLink dies on severe errors, returns 1 on success and 0 if it could
#     not replace the files. It warns on suspect error conditions, but does
#     not warn if they have no severe consequences.
#
sub ReplaceWithLink ($$) {
    my ( $first, $cand ) = @_;
    if ( $Opt{'dry-run'} ) {
        WriteLog($cand,$first) if ($LOG_FH);
        return 1;
    }
    my ( $fh, $tempfile ) = tempfile( "$Prog-1-XXXXXXXX", DIR => dirname($cand) );
    unless ($tempfile) {
        die "Could not create a temporary file: $!";
    }
    unless ( rename $cand, $tempfile ) {
        warn sprintf(
            "Cannot rename %s to %s (%s); Skipping.",
            $DV->stringify($cand),
            $DV->stringify($tempfile), $!,
        );
        unlink $tempfile or warn "Could not unlink '$tempfile': $!";
        return 0;
    }
    unless ( link $first, $cand ) {
        my $link_err = $!;
        my $firstlinks = (stat($first))[3];
        if ($link_err =~ /too many link/i and (!$Opt{maxlinks} or $Opt{maxlinks} > $firstlinks) ) {
            warn "Unable to link $cand to $first: $link_err.  Setting --maxlinks to $firstlinks\n";
            $Opt{maxlinks} = $firstlinks;
        }
        else {
            warn "Unable to link $cand to $first: $link_err.\n";
        }

        if ( rename $tempfile, $cand ) {

            # We could rename back and no harm should be done.
            return 0;
        }
        else {
            die sprintf(
                "Could neither link %s to %s (%s) "
                  . "nor rename %s back to %s (%s).",
                $DV->stringify($first),
                $DV->stringify($cand),
                $link_err,
                $DV->stringify($tempfile),
                $DV->stringify($cand), $!
            );
        }
    }
    close $fh or warn "Could not close the temporary filehandle: $!";
    unless ( unlink $tempfile ) {
        die sprintf(
            "Could not unlink %s (was %s): %s",
            $DV->stringify($tempfile),
            $DV->stringify($cand), $!
        );
    }

    print "debug:   Linked " . join(', ',stat($cand)) . ", $cand\n"
        . "debug:     with " . join(', ',stat($first)) . ", $first\n"
            if ($Opt{debug});
    WriteLog($cand,$first) if ($LOG_FH);
    return 1;
}


#
# WriteLog - write a log entry.
#
sub WriteLog {
    my($cand,$first) = @_;
    if (!printf $LOG_FH "\$1 \$2 %s %s\n", shell_quote($cand), shell_quote($first)) {
        # Log write error.  Give up on logging.
        warn "Unable to write to log file: $!";
        close $LOG_FH;
        $LOG_FH = undef();
    }
}

#
# FileKey - build a hash key for this file
#
sub FileKey {
    my ( $md5, @stat ) = @_;
    # stat 0 - dev #
    # stat 1 - inode #
    # stat 2 - mode
    # stat 3 - number of hard links
    # stat 4 - uid
    # stat 5 - gid
    # stat 6 - device identifier (special files only)
    # stat 7 - size
    # stat 8 - atime
    # stat 9 - mtime
    # stat 10 - ctime
    # stat 11 - preferred block size for file system I/O
    # stat 12 - blocks allocated
    
    return "$md5,$stat[0],$stat[2],$stat[4],$stat[5],$stat[7]";
}

#
# InodeKey - build a key for this inode
#
sub InodeKey {

    # Ideally two pointers to the same inode number on the same device should
    # point to the same file.  Over time, however, an inode could get release
    # and reassigned.  So we compare on the inode number, but also a number of
    # other characteristics that would stay constant, including size and mtime.
    # Not atime though, since we don't care of someone read the file.
    my (@stat) = @_;
    return "$stat[0],$stat[1],$stat[2],$stat[4],$stat[5],$stat[7],$stat[9]";
}



#
# ElapsedTime - produce a formatted elapsed time.
#
sub ElapsedTime () {

    my $Elapsed=time() - $StartTime;
    my $String='s';
    foreach ((60,60,24)) {
	$String = sprintf(":%02d",$Elapsed % $_) . $String;
        $Elapsed = int($Elapsed/$_);
    }
    
    $String = "$Elapsed:" . $String;
    $String =~ s/^[0:]*//;		# Remove high order zeros.
    return $String;
}



#
# PrintStatistics - display conversion statistics
#
sub PrintStatistics () {
    my $uniq_files = keys %UniqueFiles;
    my $ElapsedTime=ElapsedTime();
    my $ElapsedSeconds=time()-$StartTime;
    $ElapsedSeconds = 1 if ($ElapsedSeconds < 1);	# Sometimes get first alarm in second #0.
    my $RootStub=$Root;
    $RootStub =~ s"^.*/([^/])"$1";
    my $TimeStamp = strftime("%D %T",localtime());
    $LastStats = sprintf(
        "elapsed=%s, arg=%s/%s, tlds=%s/%s, %s files, %s unique, %s files/s, speed=%s/s, used=%s, %s saved, current=%s    \r",
        $ElapsedTime,
        map { Commify($_) } (
	    $CurrentArg,$ParmCount,
            $tl_dirs_doing, $tl_dirs_total, $files, $uniq_files,
        int($files/$ElapsedSeconds+0.5),
        ),
        FormatStorage($Usedspc/$ElapsedSeconds),
	FormatStorage($Usedspc),
	FormatStorage($Savedspc),
        $RootStub,
    );
    print "$TimeStamp $LastStats";
    $LastPrint = "stats";
    PrintStatFile("$TimeStamp Processing $Candidate<br>$LastStats") if ($Opt{statfile});
    if ($PrintStats) {

        # This was a manual request.  Don't overwrite it.
        print "\n";
        $PrintStats = 0;    # Turn off manual request flag.
    }
}



#
# PrintStatFile - print an html or text stat file.
#
sub PrintStatFile {

    my $Text = shift;

    my $STATFILE;
    if (open($STATFILE,'>',$Opt{statfile})) {
        if ($Opt{statformat} eq 'html') {
            print $STATFILE qq[
                <!DOCTYPE html>
                <html>
                    <head>
                        <title>$Prog status</title>
			<meta HTTP-EQUIV="refresh" CONTENT="60">
                    </head>
                    <body>
			<font face="COURIER NEW" size=2>
			$Text
			</font>
                    </body>
                </html>
            ];
        }
        else {
            print $STATFILE $Text . "\n";
        }
        close $STATFILE;
    }
    else {
        warn "Unable to open $Opt{statfile}: $!\n";
        $Opt{statfile}='';
    }
}



#
# RegisterFile - Remember this file by MD5 and inode data.
#
{
    # This sub is in a closure so it can maintain a persistent
    # private hash.
    my %CountedInodes;

    sub RegisterFile ($$@) {
        my ( $md5, $cand, @candstat ) = @_;
	$md5 = file_md5_hex($cand) unless $md5;  # We can get here without an MD5 due to maxlinks.
        $UniqueFiles{ FileKey( $md5, @candstat ) } = $cand;
        my $size = $candstat[7];
        warn "size undefined"    unless defined $size;
        warn "usedspc undefined" unless defined $Usedspc;
        if ($Opt{debug}) {
            print "debug:   Registered new file: " . FileKey($md5,@candstat) . " => $cand\n";
        }
        return if $CountedInodes{ $candstat[1] }++;    # don't count twice
        $Usedspc += $size;
    }
}


#
# RegisterInode - Remember this inode by MD5 and inode data.
#

sub RegisterInode ($@) {
    my ( $first, @candstat ) = @_;
    my $key = InodeKey(@candstat);
    if ($candstat[3] > 1 ) {
        # There are other links to this inode.  Remember it.
    	$Inodes{ $key } = $first;
    	if ($Opt{debug}) {
        	print "debug:   Registered new inode: " . InodeKey(@candstat) . " => $first\n";
        }
    }
    elsif (exists($Inodes{ $key })) {
       # There's only one of these now.  No point in keeping it.
       delete $Inodes{ $key };
    }
    else {
       # This is the first and last time we'll see this one.  Ignore it.
    }
}


#
# KnownInodes - if we've already seen this inode, pass back the file it links to
#               or '' if it should stay as-is.  Else return undef.
sub KnownInodes(@) {
    if (exists($Inodes{InodeKey(@_)})) {
        my $first = $Inodes{InodeKey(@_)};
        return '' if ($first eq '');		# Leave as is.
        # So we're going to map this to another file, but make sure that
	# file hasn't disappeared since we last saw it.
        return $first if (-f $first);
    };
    return undef();
}



#
# WriteCheckpoint - write a checkpoint file.
#
sub WriteCheckpoint {

    my $CheckpointFile = "/tmp/$Prog.$$.checkpoint";

    $WriteCheckpoint = 0;	# Mark this as done.
    $LastCheckpoint = time();	# If we fail, warn and retry on next cycle.

    my $CH;
    if (!open($CH,'>',"$CheckpointFile.tmp")) {
        warn "Unable to write checkpoint file: $!";
        return;
    }
    my $Start = time();
    my $Status = print $CH Dumper(@OrigARGV,%Opt,$Root,%Inodes,%UniqueFiles);
    close $CH;
    if (!$Status) {
        warn "Unable to write checkpoint file: $!";
        return;
    }
    if (-e $CheckpointFile) {
            if (!unlink($CheckpointFile)) {
                warn "Unable to delete $CheckpointFile: $!";
                return;
            }
    }
    if (!rename("$CheckpointFile.tmp","$CheckpointFile")) {
        warn "Unable to move $CheckpointFile.tmp: $!";
        return;
    }
    $CheckpointDuration = time() - $Start;
}

       



#
# ProcessItem - process the next file (directory, ...) found.
#
sub ProcessFile {
    # See if the user has cancelled the job.
    if (CheckInterrupt()) {
        # Cancelling.  Prune everything until we get out.
        $File::Find::prune = 1;
        return;
    }

    # Manage the checkpoint file.
    WriteCheckpoint() if ($WriteCheckpoint);

    # Skip this item if it has disappeared since we started.
    $Candidate = $File::Find::name;	# Get the full path name of our candidate.
    my (@candstat) = stat($_);

    # Manage stats and generate progress reports.
    ManageStats($Candidate);

    return if -l;          # Skip relative links.  No pay off.
    return unless -f _;    # Skip non-files.
    return unless -s _;    # Skip empty files.  Risk & no pay off.

    $files++;
    print "debug: Checking $Candidate\n" if ($Opt{debug});

    # If there's a limit on links, see if we've reached it.
    if ( $Opt{maxlinks} ) {
        my (@maxlstat) = stat($Candidate);
        if ( $maxlstat[3] > $Opt{maxlinks} ) {

            # the case that we have to make a new file from a link
            print "debug:   Link limit reached on $Candidate\n" if ($Opt{debug});
            my ( $fh, $tempfile ) =
              tempfile( "$Prog-2-XXXXXXXX", DIR => "." );
            unless ($tempfile) {
                die "Could not create a temporary file: $!";
            }
            unless ( rename $Candidate, $tempfile ) {
                die sprintf( "Could not rename %s to %s: %s",
                    $DV->stringify($Candidate), $DV->stringify($tempfile), $! );
            }
            cp $tempfile, $Candidate
              or die sprintf(
                "Could not cp %s to %s: %s",
                $DV->stringify($tempfile),
                $DV->stringify($Candidate), $!,
              );
            unlink $tempfile;
            $Savedspc -= $maxlstat[7];
        }
    }

    # Now get down to really processing this item.
    my $match;
    my $md5;
    my @firststat;

    # Four choices:
    #   1) We've seen this inode before, and it stayed as-is.  This one can too.
    #   2) We've seen this inode before, and it was replaced.  Replace this one
    #      the same way.
    #   3) It's content matches a prior file.  Link it and remember the inode.
    #   4) It doesn't match anything.  Remember it as a unique file and remember the inode.
    my $first = KnownInodes(@candstat);
    if ($first) {
        @firststat = stat($first);
        $first = '' unless ($firststat[1]);
    }
    if (defined($first) and !$first ) {
        # Case 1: we've seen this before and it stayed as-is.
        print "debug:   $Candidate has same inode as $first -- leave as is\n"
            if ($Opt{debug});
        return;			# Leave it as-is.
    }
    elsif (defined($first) and $first) {
        # Case 2: we've seen this before and it was replaced.
        $match = 1;

        print "debug:   $Candidate has same inode as prior item -- link to $first\n"
            if ($Opt{debug});
    }
    elsif ($first = FindMatch($Candidate,\$md5,@candstat)) {
        # Case 3: We looked for and found a match.
        @firststat = stat($first);
        $match = 1;
        RegisterInode($first,@candstat);	# Remember how we handle this inode.
        print "debug:   $Candidate contents match -- link to $first\n"
            if ($Opt{debug});
    }
    else {
        # Case 4: It didn't match anything.
        $match = 0;
        RegisterFile( $md5, $Candidate, @candstat );	# Remember for future matches.
        RegisterInode('',@candstat);		# Remember this inode.
    }

    if ($match) {
        # Don't replace if we've exceeded our maxlinks.
        if ( $Opt{maxlinks} && $firststat[3] >= $Opt{maxlinks} ) {
            # Exceeded our link limit.  Register this as the new target file.
            RegisterFile( $md5, $Candidate, @candstat );
        }
        elsif ( ReplaceWithLink( $first, $Candidate ) ) {
            if ( $candstat[3] == 1 ) {    # we don't save space otherwise
                $Savedspc += -s $Candidate;
            }
        }
        else {
            # Tried but failed to hardlink.  Make candidate our new target.
            RegisterFile( $md5, $Candidate, @candstat );
            RegisterInode('',@candstat);
        }
    }

    # Skip the stats report unless:
    #    PrintStats = 1 (set by SIGUSR1)
    #    --stats specified and $files % 1000 == 0.
    PrintStatistics()
        if ( $PrintStats or ( $Opt{'stats'} and $files % $Opt{statinterval} == 0 ) );
    return;
}



#
# FindMatch - Try to find a file that matches this one.
#
sub FindMatch ($@) {
    my($cand,$md5ref,@candstat) = @_;

    # Calculate the MD5 sum of the candidate.
    my $fh;
    unless ( open $fh, "<", $cand ) {
        warn sprintf( "Cannot read %s (%s); Skipping.",
            $DV->stringify($File::Find::name), $!, );
        $Usedspc += -s $cand;
        return '';
    }

    $$md5ref = file_md5_hex($cand);	# Get the MD5 signature.

    # See if we recognize this MD5 sum and stat attributes.
    if ( my $first = $UniqueFiles{ FileKey( $$md5ref, @candstat ) } ) {
        # It matches something previous, according to the MD5 and stat data.
	my @firststat;
        @firststat = stat($first);
        if (! $firststat[1]) {
            # This inode disappeared.
            print "debug:   Matching file disappeared: $first\n" if ($Opt{debug});
            delete $UniqueFiles { FileKey( $$md5ref, @candstat )};
            return;		# So then we have no match.
        }
        if ($firststat[0] == $candstat[0] and $firststat[1] == $candstat[1]) {
	    # We found ourselves.  This can happen if we restart/reload prior maps.
            # Treat it as a non-match and just fall through the parent's logic.
            print "debug:   Found self on $cand\n" if ($Opt{debug});
            return;
        }
        print "debug:   MD5 match: " . join(', ',@candstat) . ",$cand\n"
            . "              with: " . join(', ',@firststat) . ",$first\n"
                if ($Opt{debug});
        my $different = ($Opt{compare}?compare $first, $cand:0);
        if ( $different != 0 && $File::Compare::VERSION < 1.1005 ) {

            # workaround bug # 37716 in File::Compare
            $different = compare "$first\0", "$cand\0";
        }
        if ( $different < 0 ) {
            # Compare failed to run.
            warn sprintf(
                "Cannot compare %s and %s (%s); Skipping.",
                $DV->stringify($first),
                $DV->stringify($cand), $!,
            );
	    return;
        }
        elsif ($different == 0) {
            # We have a match!
            print "debug:  $cand matches $first\n" if ($Opt{debug} > 1);
            return $first;
        }
        else {
            # MD5 matched but binary compare differed!!!
            die sprintf(
                "MD5 collision!  %s and %s are not equal with same MD5 ($$md5ref)",
                $DV->stringify($first),
                $DV->stringify($cand)
                );
        }
    }
    else {
        print "debug:  $cand is unique\n" if ($Opt{debug} > 1);
        return;
    }
}



#
# CheckInterrupt
#
sub CheckInterrupt {
    if ( $Cancel and !$CancelConfirmed ) {

        # Don't lose hours (or days) of work due to a ^C in the wrong window.
	print "\nCurrently processing $Root\n";
        print "\nProgress report, statistics, options, cancel job, or resume (p/s/o/c/r)? ";
        my $Response = <STDIN>;
	chomp $Response;
        if ( $Response eq 'c' ) {
            print "Cancel confirmed.  Wrapping up.\n";
            $CancelConfirmed = 1;
        }
        elsif ( $Response eq 'p' ) {
            $PrintProgress = 1;
        }
        elsif ( $Response eq 's' ) {
            PrintStatistics();
            print "\n";
        }
        elsif ( $Response eq 'o' ) {
            my $Line;
            do {
	        print "Current options:\n";
                foreach (sort(keys(%Opt))) {
	            printf "\t%16s: %s\n", "--$_", $Opt{$_};
                }
                print "Enter new options or null to exit: ";
		$Line = <STDIN>;
		last unless ($Line);
                ProcessOptions(shellwords($Line));
            };
        }
        elsif ( $Response eq 'r' ) {
            print "Resuming processing.\n";
        }
        else {
            print "Unrecognized response.  Resuming processing.\n";
        }
        $Cancel = $CancelConfirmed;  # Turn off cancel unless cancel confirmed.
    }
    return ($CancelConfirmed);
}



#
# ManageStats - manage progress reports and statistics.
#
sub ManageStats {

    my $cand = shift;
    # Take care of progress reports.
    if ($PrintProgress) {

        # We've received a request for a progress report.
	print "\n" if ($LastPrint eq 'stats');
        print strftime( "%D %T Now processing $cand\n", localtime( time() ) );
	$LastPrint = "progress";
        $PrintProgress = 0;    # Turn off flag.
	$LastProgress = time();
    }

    # Manage our stats.
    if ( $cand eq $Root ) {
        # We're starting a Parms item, count it's top-level directories.
        my $td = $_;
        opendir my ($dh), $td;
        my (@tl) = grep { !/^\./ && -d "$td/$_" } readdir $dh;
        $tl_dirs_total = @tl;
	$td_slashes = $td =~ tr|/||;
    }
    elsif (-d) {
        # We're continuing an item.  Find out if this is a new TLD.
        my $slashes = $cand =~ tr|/||;
        if ( $slashes == $td_slashes + 1 ) {
            # It's a new TLD.  Update stats and ETA.
            $tl_dirs_doing++;
            if ( $Opt{eta} and $tl_dirs_doing > 1 ) {

                # Calculate our completion time.
                my $TimePerTLD =
                  ( time() - $StartTime ) / ( $tl_dirs_doing - 1 );
                my $ETA =
                  time() +
                  $TimePerTLD * ( $tl_dirs_total - $tl_dirs_doing - 1 );
                print "\n" if ($LastPrint eq 'stats');
                print $Root
                  . strftime( " estimated completion time: %T on %D\n",
                    localtime($ETA) );
		$LastPrint="ETA";
            }
        }
    }
    return;
}


#
# Send mail
#
sub SendMail {
	$Summary = shift;

	my $domain = `domainname`;
	chomp $domain;
	$domain = "localhost" unless ($domain and $domain ne '(none)');
	my $sender = ($ENV{LOGNAME} || $ENV{USER} || getpwuid($<)) . "\@$domain";
	my @MailAddresses = @{$Opt{mail}};
	my %mail = (
		SMTP_Server	=> 'localhost',
		To 		=> join(',',@MailAddresses),
		From		=> $sender,
		Subject		=> "dirvish-dedup done",
		Message		=> 
			"Dedup complete for "
			. join(", ", @Parms_Copy)
			. "\n"
			. "$LastStats\n"
			. "$Summary\n"
	);
	sendmail(%mail)
		or warn "Unable to send e-mail: $!\n";
}

#
# FormatStorage - 
#
sub FormatStorage {

    my $Bytes = shift;
    $Bytes = int($Bytes+0.5);
    if ($Bytes > 10*1024*1024*1024*1024) {
        return Commify(int($Bytes/1024/1024/1024/1024)) . 'T';
    }
    elsif ($Bytes > 10*1024*1024*1024) {
        return Commify(int($Bytes/1024/1024/1024)) . 'G';
    }
    elsif ($Bytes > 10*1024*1024) {
        return Commify(int($Bytes/1024/1024)) . 'M';
    }
    elsif ($Bytes > 10*1024) {
        return Commify(int($Bytes/1024)) . 'K';
    }
    else {
        return $Bytes . 'B';
    }
}

__END__

=head1 NAME

dirvish-dedup - traverse directories, find identical files, replace with hard links

=head1 SYNOPSIS

 dirvish-dedup.pl OPTIONS directory...

 OPTIONS:

  --maxlinks N            limit the amount of links per file
  --cd,-C dir		  cd: Change directories to dir.
  -n,--dry-run		  report changes, but don't really link anything
  --(no)progress	  print progress reports every 60 (default) seconds
  --proginterval=n        Change progress report interval to "n" seconds.
  --(no)stats             print search/link statistics every 5000 files.
  --statinterval=n        Change statistics interval to every "n" files.
  --statfile=file	  Write the statistics to "file"
  --statformat=(html|text)	Write the statfile in HTML or text (default)
			  format.
  -l,--logfile file	  write a link log to "file"
  --(no)compare           physically compare files if the MD5 sum and file
                          attributes match.  Slow.  --nocompare is the default.
  --cpinterval=n          Write a checkpoint files every "n" seconds
                          (default=600).
  --mail=address	  Send a brief e-mail to "address" on completion.
			  May be repeated.
  --reverse		  Process the command-line parameters in reverse order.
			  This is useful when using wild-cards but needing
			  to process the folders in newest-to-oldest order.
  --loadmaps=file	  Load a checkpoint file from a prior run.
  --
                          extra full file read of both files.
                          Default is to trust the MD5 + file size.

=head1 DESCRIPTION

=head1 MATCHING FILES

Files are considered to match if the following characteristics are the same:

=over 4

=item *

MD5 signature

=item *

Owner ID (uid)

=item *

Group ID (gid)

=item *

Permissions

=item *

size

=item *

file content, only if the --compare option is specified.  

=back

This differs from the original trimtrees.pl, which only used the MD5
signature and
always compared the file contents.

The argument for using --compare is that MD5 signature has been found to be
cryptographically insecure.  As applied to this application, that means that
someone
can intentionally create a file B that has the same MD5 signature as some
existing 
file A.
In this application, file B would also need to be the same size.
Assuming that it is possible to intentionally create a file with the same MD5
signature and the same size,  there is some smaller chance that it could
also happen by random chance.
Clearly, then, there is some
risk that two non-matching files could be considered the same based on these
characteristics.  It is not clear what the likelihood is of that happening,
however.

The argument against using --compare is that once two files are found to have
matching MD5 signatures and the selected inode values, --compare requires
that each file be read again to perform a bit-by-bit comparison.  Without
--compare,
file A is read once, and each of it's matches are also read once.  With
--compare,
file A is read once, then reread once for each MD5 match.  The matching files
 is
read twice, once to generate the MD5 signature and once as part of the
comparison.
Mathematically, if we have N matching files, we'll do 1+N full file reads
without
--compare, and 1+3N with --compare.

In short --compare is always safer, but it's not clear what the chances
of an erroneous replacement are without it, and only the user can judge
whether the risk of such a failure outweighs the benefits of faster
run times.

As to the question of why not use one of the SHA algorithms instead, the 
answer is that even the smallest SHA algorithm takes 3 times longer to generate,
and it's not clear that there is much benefit.


=head1 SIGNALS

SIGINT (aka Ctrl-C) is caught, and produces a prompt.  At this point the user may
request current statistics, request a progress report, change options on the fly,
abort the job, or resume processing.

=head2 RISKS

The whole idea of replacing identical files with hard links has
inherent dangers. Once two files have turned into one inode other
processes may accidentally change both although they intend to alter
only one. Please consider if this can happen in your environment.

=head1 ATTRIBUTION

This code is based on the CPAN trimtrees.pl script.  Though my changes are extensive,
they are primarily in the area of new options and performance improvements.  This code
would not have been possible without trimtrees.pl.  Thank you.

=cut

	Local Variables:
	mode: cperl
	cperl-indent-level: 2
	End:
