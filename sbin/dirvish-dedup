#!/usr/bin/perl -w

use strict;
use Cwd;
use Digest::MD5 qw(md5 md5_hex);
use Dumpvalue;
use File::Compare qw(compare);
use File::Copy qw(cp);
use File::Find;
use File::Temp qw(tempfile);
use Getopt::Long;
use POSIX qw(strftime);
use Fcntl;
our %Opt;
my $StartTime=time();
GetOptions(\%Opt,
           "maxlinks=i",
	   "dry-run|n",	
	   "logfile|l=s",
           "progress",
           "stats",
          ) or die;

my @dirs = @ARGV or die "Usage: $0 OPTIONS directories";
our $DEBUG = 0;
our $Signal = 0;
our %MD5;
our $Usedspc = 0;
our $Savedspc = 0;
our $PrintProgress = 0;		# Set to 1 by alarm clock or SIGUSR1.
our $PrintStats = 0;		# Set to 1 by SIGUSR1 for supplemental report.
our $LOG_FH;

print "Running in dry-run mode...\n" if ($Opt{'dry-run'});		# Added, BPM, 3/16/12

$SIG{INT} = sub {
  warn "Caught SIGINT; please stand by, I'm leaving as soon as possible...\n";
  $Signal++;
};

$SIG{USR1} = sub {
  # User requested a status update.
  $PrintProgress = 1;
  $PrintStats = 1;
};

$SIG{HUP} = $SIG{USR1};		# Don't die because the user sent the default kill.


if ($Opt{logfile}) {
  sysopen($LOG_FH,$Opt{logfile},O_CREAT+O_WRONLY+O_TRUNC)
    || die "Unable to open $Opt{logfile}: $!";
  $LOG_FH->autoflush(1);
}


if ($Opt{'progress'}) {
  # Set us up for regular progress reports.
  $SIG{ALRM} = sub {
    $PrintProgress = 1;	# Ask for a status update.
  };
  alarm(30);			# Wake us in 60 seconds.
};

our $DV = Dumpvalue->new(tick => qq{"},
                         quoteHighBit => 1,
                         printUndef => 1,
                        );
our $WD = Cwd::cwd;

sub fmt ($) {
  local $_ = shift;
  s/(\d)(?=(\d{3})+$)/$1,/g;
  $_;
}

# $success = melt($some_file,$another)

# $some_file is always absolute, $another is always in the current
# directory

# melt dies on severe errors, returns 1 on success and 0 if it could
# not melt the files. It warns on suspect error conditions, but does
# not warn if they have no severe consequences.
sub melt ($$) {
  my($first,$basename) = @_;
  if ($Opt{'dry-run'}) {						# Added, BPM, 3/16/12
    printf ("\rdry-run: %s > %s\n",$basename,$first);
    return 1;								# Added, BPM, 3/16/12
  }									# Added, BPM, 3/16/12
  my($fh,$tempfile) = tempfile("dirvish-dedup1-XXXXXXXX", DIR => ".");
  unless ($tempfile) {
    die "Could not create a temporary file: $!";
  }
  unless (rename $basename, $tempfile){
    warn sprintf(
                 "Cannot rename %s to %s (%s); Skipping.",
                 $DV->stringify($basename),
                 $DV->stringify($tempfile),
                 $!,
                );
    unlink $tempfile or die "Could not unlink '$tempfile': $!";
    return 0;
  }
  unless (link $first, $basename){
    my $link_err = $!;
    if (rename $tempfile, $basename){
      # We could rename back and no harm should be done. Don't warn.
      return 0;
    } else {
      die sprintf(
                  "Could neither link %s to %s (%s) ".
                  "nor rename %s back to %s (%s).",
                  $DV->stringify($first),
                  $DV->stringify($basename),
                  $link_err,
                  $DV->stringify($tempfile),
                  $DV->stringify($basename),
                  $!
                 );
    }
  }
  close $fh or warn "Could not close the temporary filehandle: $!";
  unless (unlink $tempfile) {
    die sprintf(
                "Could not unlink %s (was %s): %s",
                $DV->stringify($tempfile),
                $DV->stringify($basename),
                $!
               );
  }
  printf $LOG_FH "%s > %s\n", $basename, $first if ($LOG_FH);
  return 1;
}

{
  my %INODE;
  sub register ($$;$) {
    my($md5,$cand,$candstat) = @_;
    my @stat = $candstat ? @$candstat : stat $cand;
    $MD5{filekey($md5,@stat)} = $cand;
    my $size = $stat[7];
    warn "size undefined" unless defined $size;
    warn "usedspc undefined" unless defined $Usedspc;
    if ($DEBUG) {
      warn(sprintf "\nDEBUG: cand[%s]size[%s]stat[%s]", $cand, $size, join(":",@stat));
    }
    return if $INODE{$stat[1]}++; # don't count twice
    $Usedspc += $size;
  }
}

sub filekey {
    my($md5,@stat) = @_;
    return "$md5,$stat[0],$stat[2],$stat[4],$stat[5],$stat[7]";
}

undef $/;
my %reported;
my $files = 0;
my $dirs = @dirs;
my $tl_dirs_todo = 0;
my $tl_dirs_doing = 0;

sub xreport () {
  my $uniq_files = keys %MD5;
  printf(
         "tlds=%s,cur=%s,unique=%s,files=%s,spcused=%s,spcsaved=%s,\r",
         map {
           fmt($_)
         }
         (
          $tl_dirs_todo,
          $tl_dirs_doing,
          $uniq_files,
          $files,
          $Usedspc,
          $Savedspc
         )
        );
  if ($PrintStats) {
	# This was a manual request.  Don't overwrite it.
	print "\n";
  	$PrintStats = 0;	# Turn off manual request flag.
  }
}

$| = 1;
for my $diri (0..$#dirs) {
  my $root = $dirs[$diri];
  if (!cwd($root)) {
    warn "Unable to cd to $root -- skipped\n";
    next;
  }
  find(
       {
        wanted => sub {
          if ($Signal){
            $File::Find::prune = 1;
            return;
          }
          if ($File::Find::name eq $root) {
            my $td = $_;
            opendir my($dh), $td;
            my(@tl) = grep { !/^\./ && -d "$td/$_" } readdir $dh;
            $tl_dirs_todo = @tl;
          } elsif (-d) {
            my $slashes = $File::Find::name =~ tr|/||;
            if ($slashes == 1) {
              $tl_dirs_doing++;
            }
          }
          return if -l; # relative links would need special treatment that does not pay off
          return unless -f _;
          return unless -s _; # empty files more risk that files with
                              # content and no gain
          $files++;
          my $basename = $_;
          my $fh;
          unless (open $fh, "<", $basename) {
            warn sprintf(
                         "Cannot read %s (%s); Skipping.",
                         $DV->stringify($File::Find::name),
                         $!,
                        );
            $Usedspc += -s $basename;
            return;
          }
          my $data = <$fh>;
          close $fh;
          my $md5 = md5_hex $data;
          my $cand = $File::Find::name;
	  if ($PrintProgress) {
	    # We've received a request for a progress report.
            print strftime("%D %T Now processing $cand\n",localtime(time()));
	    $PrintProgress = 0;		# Turn off flag.
            alarm(30);		# Schedule next alarm.
          }
          if ($Opt{maxlinks}) {
            my(@maxlstat) = stat($cand);
            if ($maxlstat[3] > $Opt{maxlinks}) {
              # the case that we have to make a new file from a link
              my($fh,$tempfile) = tempfile("dirvish-dedup2-XXXXXXXX", DIR => ".");
              unless ($tempfile) {
                die "Could not create a temporary file: $!";
              }
              unless (rename $cand, $tempfile){
                die sprintf(
                            "Could not rename %s to %s: %s",
                            $DV->stringify($cand),
                            $DV->stringify($tempfile),
                            $!
                           );
              }
              cp $tempfile, $cand or die sprintf(
                                                 "Could not cp %s to %s: %s",
                                                 $DV->stringify($tempfile),
                                                 $DV->stringify($cand),
                                                 $!,
                                                );
              unlink $tempfile;
              $Savedspc -= $maxlstat[7];
            }
          }
          my(@candstat) = stat($basename);				# Moved earlier, BPM.
          if (my $first = $MD5{filekey($md5,@candstat)}) {
            unless (File::Spec->file_name_is_absolute($first)) {
              $first = File::Spec->catfile($WD, $first);
            }
            my(@firststat) = stat($first);
            die sprintf(
                        "illegal firststat[%s]first[%s]",
                        join(":",@firststat),
                        $DV->stringify($first),
                       ) unless $firststat[1];
            my $different = compare $first, $basename;
            if ($different != 0 && $File::Compare::VERSION<1.1005) {
              # workaround bug # 37716 in File::Compare
              $different = compare "$first\0", "$basename\0";
            }
            if ($different<0) {
              warn sprintf(
                           "Cannot compare %s and %s (%s); Skipping.",
                           $DV->stringify($first),
                           $DV->stringify($cand),
                           $!,
                          );
              goto XREPORT; # some error occurred
            }
            die sprintf(
                        "Sensation, %s and %s are not equal with same MD5",
                        $DV->stringify($first),
                        $DV->stringify($cand),
                       )
                if $different;
            # replaced by filekey check: goto XREPORT unless $candstat[0] == $firststat[0]; # different file system
            if ($candstat[1] == $firststat[1]) { # already same inode
              if (0 && $Opt{maxlinks} && $firststat[3] > $Opt{maxlinks}) {
                } else {
                  goto XREPORT;
                }
            }
            if ($Opt{maxlinks} && $firststat[3] >= $Opt{maxlinks}){
              register($md5,$cand,\@candstat) if $candstat[3] < $Opt{maxlinks};
            } elsif (melt($first,$basename)) {
              if ($candstat[3]==1) { # we don't save space otherwise
                $Savedspc += $firststat[7];
              }
            } else {
              register($md5,$cand,\@candstat);
            }
          } else {
            register($md5,$cand);
          }
        XREPORT:
          # Skip the stats report unless:
          #    PrintStats = 1 (set by SIGUSR1)
          #    --stats specified and $files % 100 == 0.
          return unless ($PrintStats or ($Opt{'stats'} and $files % 100 == 0));
          xreport;
        },
        no_chdir => 1,
        preprocess => sub { return sort(@_);},
       },
       $root
      );
  last if $Signal;
}
xreport;
close $LOG_FH if ($LOG_FH);

my $StopTime = time();
print strftime("\nDONE @ %T on %D.  ",localtime($StopTime));
my $ElapsedFmt = '';
my $ElapsedTime = $StopTime - $StartTime;
my $Days = int($ElapsedTime/84200);
$ElapsedTime -= $Days*84200;
$ElapsedFmt .= $Days . " days" if ($Days);
my $Hours = int($ElapsedTime/3600);
if ($Hours or $ElapsedFmt) {
	$ElapsedFmt .= ", " if ($ElapsedFmt);
	$ElapsedFmt .= $Hours . " hours";
}
$ElapsedTime -= $Hours*3600;
my $Minutes = int($ElapsedTime/60);
if ($Minutes or $ElapsedFmt) {
	$ElapsedFmt .= ", " if ($ElapsedFmt);
	$ElapsedFmt .= $Minutes . " minutes";
}
$ElapsedTime -= $Minutes*60;
$ElapsedFmt .= ", " if ($ElapsedFmt);
$ElapsedFmt .= $ElapsedTime . " seconds";
print "Elapsed time = $ElapsedFmt\n";

__END__

=head1 NAME

dirvish-dedup - traverse directories, find identical files, replace with hard links

=head1 SYNOPSIS

 dirvish-dedup.pl OPTIONS directory...

 OPTIONS:

  --maxlinks N            limit the amount of links per file
  -n|--dry-run		  report changes, but don't really link anything
  --progress		  print progress reports every 30 seconds
  --stats                 print search/link statistics every 100 files.

=head1 DESCRIPTION

This is a variant of the CPAN trimtrees.pl script.  The changes
consist of the following:

=over 4

=item

Added the --dry-run option

=item

In addition to comparing file contents, only consider files
to match if they have the same uid, gid, and permissions.  
Note that atime, ctime, and mtime values are not compared.

=item

Changed the thousands/millions separator in numbers from _ to ,

=item

Add time stamps and elapsed time to the completion message

=item

Process the directories in alphabetic order.

=back

Traverse all directories named on the command line, compute MD5
checksums and find files with identical MD5. IF they are equal, do a
real comparison if they are really equal, replace the second of two
files with a hard link to the first one.

Special care is taken to cope with C<Too many links> error conditions.
The inode that is overbooked in such a way, is taken out of the pool
and replaced with the another one such that the minimum of files
needed is kept on disk.

The C<--maxlinks> option can be used to reduce the linkcount on all
files within a tree, thus preparing the tree for a subsequent call to
C<cp -al>. This operation can be thought of the reverse of the normal
dirvish-dedup operation (--maxlinks=1 produces a tree without hard links).

=head1 SIGNALS

SIGINT is caught and the script stops as soon as the current file
is finished.

=head2 RISKS

The whole idea of replacing identical files with hard links has
inherent dangers. Once two files have turned into one inode other
processes may accidentally change both although they intend to alter
only one. Please consider if this can happen in your environment.

=cut

	Local Variables:
	mode: cperl
	cperl-indent-level: 2
	End:
