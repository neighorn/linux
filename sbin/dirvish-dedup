#!/usr/bin/perl -w

#
# External packages
#
use strict;
use warnings;
use Cwd;
use Digest::MD5 qw(md5 md5_hex);
use Dumpvalue;
use File::Compare qw(compare);
use File::Copy qw(cp);
use File::Find;
use File::Temp qw(tempfile);
use File::Basename;
use Getopt::Long;
use POSIX qw(strftime);
use Fcntl;
use FindBin qw($Script);
use String::ShellQuote;		# For shell_quote.
use Data::Dumper::Simple;
use Text::ParseWords;

# 
# Prototype declarations.
#
sub PrintStatistics ();
sub RegisterFile ($$@);
sub RegisterInode ($@);
sub FindMatch ($@);
sub ProcessOptions ();
sub ElapsedTime ();

#
# Global variables
#
our $Prog = $Script;       # Get our program name, for messages and work files.
our %Opt;                  # Command line options.
our $Cancel          = 0;  # 1 = cancel requested.
our $CancelConfirmed = 0;  # 1 = cancel confirmed.
our %UniqueFiles;          # Hash of known file signatures (MD5+selected inode data).
our %Inodes;               # Hash of known inodes and what to link them to.
our $Usedspc       = 0;    # Total space examined.
our $Savedspc      = 0;    # Total space recovered.
our $PrintProgress = 0;    # Set to 1 by alarm clock or SIGUSR1.
our $PrintStats    = 0;    # Set to 1 by SIGUSR1 for supplemental report.
our $ETA           = 0;    # Estimated completion.
our $LOG_FH;
our $Root;                 # Current root dir (ARGV item).
our $LastCheckpoint = time();	# Time of last checkpoint.
our $WriteCheckpoint = 0;  # 1 = time to write a checkpoint file.
our @OrigARGV = @ARGV;	   # For checkpoint.
our $AlarmInterval;	   # How long between alarms.
our $ArgCount=0+@ARGV;	   # How many args we have, for stats.
our $CurrentArg = 0;	   # Which arg we're on, for stats.
our @OptSpec;		   # Specs for GetOptions;
our $StartTime = time();   # Start time, for elapsed reports.

#
# Signals.
#
$SIG{INT} = sub {
    warn "Interrupt request accepted.  Please stand-by...\n";
    $Cancel++;
};
$SIG{USR1} = sub {

    # User requested a status update.
    $PrintProgress = 1;
    $PrintStats    = 1;
};
$SIG{HUP} = $SIG{USR1};    # Don't die because the user sent the default kill.


    # Set us up for regular progress reports.
$SIG{ALRM} = sub {
    print "Alarm rang.\n" if ($Opt{debug});
    $PrintProgress = 1 if ( $Opt{'progress'} );	# If they want progress reports, queue it up.
    $WriteCheckpoint = 1 if (time() - $LastCheckpoint >= $Opt{cpinterval}); 
    alarm($AlarmInterval - (time() % $AlarmInterval));	# Schedule the next alarm.
};

#
# Process options.  @OptSpec is global, so we can change options dynamically.
#
ProcessOptions();

our $DV = Dumpvalue->new(
    tick         => qq{"},
    quoteHighBit => 1,
    printUndef   => 1,
);

#
# Do some more initializing.
#

my %reported;
my $files         = 0;
my $tl_dirs_total = 0;
my $tl_dirs_doing = 0;

select(STDERR);
$| = 1;
select(STDOUT);
$| = 1;

#
# Begin processing arguments.
#
die "No directories specified.  Enter $Prog -h for usage.\n" unless (@ARGV);
my @ARGV_Copy = @ARGV;		# In case ProcessInterrupt has to reuse @ARGV.
foreach $Root ( @ARGV_Copy ) {
    $CurrentArg++;		# Increment count for stats.
    if ( !cwd($Root) ) {
        warn "Unable to cd to $Root -- skipped: $!\n";
        next;
    }
    print strftime("%D %T Starting $Root" . ' 'x30 . "\n",localtime())
        if (@ARGV > 1);
    find(
        {
            wanted     => \&ProcessFile,
            no_chdir   => 1,
            preprocess => sub { return sort(@_); },
        },
        $Root
    );
    PrintStatistics();		# Final stats for this argv item.
    print "\n";
    WriteCheckpoint();
    last if $Cancel and $CancelConfirmed;
}

#
# Done.  Wrap up the log file and write the elapsed time.
#
if ($LOG_FH) {
    chmod(((stat $LOG_FH)[2] & 07777) | 0100, $LOG_FH);	# Add u+x.
    close $LOG_FH;
};

my $Elapsed = ElapsedTime();
print strftime( "\nDONE @ %T on %D.  Elapsed time = $Elapsed.\n", localtime());


#
# ProcessOptions
#
sub ProcessOptions () {

    @OptSpec = ("maxlinks=i", "dry-run|n", "logfile|l=s", "progress!",
        "stats!", "eta!", "strict!", "debug+", "cpinterval:600", "proginterval:30",
        "statinterval:5000", "load-maps=s")
      or die;
    GetOptions(\%Opt, @OptSpec) or die;
    foreach my $name (qw(dry-run logfile progress stats eta strict debug)) {
    	$Opt{$name} = 0 unless (exists($Opt{$name}));
    }

    # Manage the dry-run flag.
    warn "Running dry-run without a logfile -- no record of proposed changes will be kept.\n"
        if ($Opt{"dry-run"} and not $Opt{logfile});
    print "Running in dry-run mode...\n"
      if ( $Opt{'dry-run'} );
    
    # Set up the log file.
    if ( $Opt{logfile} ) {
        close $LOG_FH if ($LOG_FH);		# In case we're changing options via ^C.
        sysopen( $LOG_FH, $Opt{logfile}, O_CREAT +O_WRONLY +O_TRUNC )
          || die "Unable to open $Opt{logfile}: $!";
        $LOG_FH->autoflush(1);
    }

    # Load a pre-existing map file
    if ($Opt{'load-maps'}) {
        if (open(my $MAPFH,'<',$Opt{'load-maps'})) {
            print "Loading $Opt{'load-maps'}\n";
            local %Opt;		# Don't want these updated.
            local @ARGV;	# Don't want these updated.
            my $OldEOL = $/;
            $/ = undef;
            my $PriorMaps = <$MAPFH>;
            $/ = $OldEOL;
            close $MAPFH;
            eval($PriorMaps);
            my $UniqueCnt = Commify(0+keys(%UniqueFiles));
            my $InodesCnt = Commify(0+keys(%Inodes));
            print "Load-maps: $UniqueCnt unique files and $InodesCnt known inodes loaded\n";
        }
        else {
            warn "Unable to open map file: $!";
        }
    }
        
    # Manage the alarm clock.  Do this last so we don't start the timer before long processes.
    $Opt{cpinterval} = 600 unless ($Opt{cpinterval});
    if ($Opt{cpinterval} <= 60) {
        warn "Invalid value for --cpinterval -- set to default.\n";
        $Opt{cpinterval} = 600;
    }
    $Opt{proginterval} = 30 unless ($Opt{proginterval});
    if ($Opt{proginterval} <= 2) {
        warn "Invalid value for --proginterval -- set to default.\n";
        $Opt{proginterval} = 30;
    }
    $Opt{statinterval} = 5000 unless ($Opt{statinterval});
    if ($Opt{progress}) {
         $AlarmInterval=($Opt{proginterval} < $Opt {cpinterval}?$Opt{proginterval}:$Opt{cpinterval});
    }
    else {
         $AlarmInterval=$Opt{cpinterval};
    }
    alarm($AlarmInterval - (time() % $AlarmInterval));	# Schedule the first alarm.
    
}



#
# Commify - format numbers with commas.
#
sub Commify ($) {
    local $_ = shift;
    s/(\d)(?=(\d{3})+$)/$1,/g;
    $_;
}

#
# ReplaceWithLink - replace a file with a hard link to another.
#
#     $success = ReplaceWithLink($some_file,$another)
#
#     $some_file is always absolute, $another is always in the current
#     directory
#
#     ReplaceWithLink dies on severe errors, returns 1 on success and 0 if it could
#     not replace the files. It warns on suspect error conditions, but does
#     not warn if they have no severe consequences.
#
sub ReplaceWithLink ($$) {
    my ( $first, $cand ) = @_;
    if ( $Opt{'dry-run'} ) {
        WriteLog($cand,$first) if ($LOG_FH);
        return 1;
    }
    my ( $fh, $tempfile ) = tempfile( "$Prog-1-XXXXXXXX", DIR => dirname($cand) );
    unless ($tempfile) {
        die "Could not create a temporary file: $!";
    }
    unless ( rename $cand, $tempfile ) {
        warn sprintf(
            "Cannot rename %s to %s (%s); Skipping.",
            $DV->stringify($cand),
            $DV->stringify($tempfile), $!,
        );
        unlink $tempfile or warn "Could not unlink '$tempfile': $!";
        return 0;
    }
    unless ( link $first, $cand ) {
        my $link_err = $!;
        if ( rename $tempfile, $cand ) {

            # We could rename back and no harm should be done.
            warn "Unable to link $cand to $first: $link_err\n";
            return 0;
        }
        else {
            die sprintf(
                "Could neither link %s to %s (%s) "
                  . "nor rename %s back to %s (%s).",
                $DV->stringify($first),
                $DV->stringify($cand),
                $link_err,
                $DV->stringify($tempfile),
                $DV->stringify($cand), $!
            );
        }
    }
    close $fh or warn "Could not close the temporary filehandle: $!";
    unless ( unlink $tempfile ) {
        die sprintf(
            "Could not unlink %s (was %s): %s",
            $DV->stringify($tempfile),
            $DV->stringify($cand), $!
        );
    }

    print "debug:   Linked " . join(', ',stat($cand)) . ", $cand\n"
        . "debug:     with " . join(', ',stat($first)) . ", $first\n"
            if ($Opt{debug});
    WriteLog($cand,$first) if ($LOG_FH);
    return 1;
}


#
# WriteLog - write a log entry.
#
sub WriteLog {
    my($cand,$first) = @_;
    if (!printf $LOG_FH "\$1 \$2 %s %s\n", shell_quote($cand), shell_quote($first)) {
        # Log write error.  Give up on logging.
        warn "Unable to write to log file: $!";
        close $LOG_FH;
        $LOG_FH = undef();
    }
}

#
# FileKey - build a hash key for this file
#
sub FileKey {
    my ( $md5, @stat ) = @_;
    return "$md5,$stat[0],$stat[2],$stat[4],$stat[5],$stat[7]";
}

#
# InodeKey - build a key for this inode
#
sub InodeKey {

    # Ideally two pointers to the same inode number on the same device should
    # point to the same file.  Over time, however, an inode could get release
    # and reassigned.  So we compare on the inode number, but also a number of
    # other characteristics that would stay constant, including size and mtime.
    # Not atime though, since we don't care of someone read the file.
    my (@stat) = @_;
    return "$stat[0],$stat[1],$stat[2],$stat[4],$stat[5],$stat[7],$stat[9]";
}



#
# ElapsedTime - produce a formatted elapsed time.
#
sub ElapsedTime () {

    my $Elapsed=time() - $StartTime;
    my $String='s';
    foreach ((60,60,24)) {
	$String = sprintf(":%02d",$Elapsed % $_) . $String;
        $Elapsed = int($Elapsed/$_);
    }
    $String = "$Elapsed" . $String;
    $String =~ s/^[0:]*//;		# Remove high order zeros.
    return $String;
}



#
# PrintStatistics - display conversion statistics
#
sub PrintStatistics () {
    my $uniq_files = keys %UniqueFiles;
    my $ElapsedTime=ElapsedTime();
    my $ElapsedSeconds=time()-$StartTime;
    $ElapsedSeconds = 1 if ($ElapsedSeconds < 1);	# Sometimes get first alarm in second #0.
    my $RootStub=$Root;
    $RootStub =~ s"^.*/([^/])"$1";
    printf(
        "%s elapsed=%s, arg %s/%s, tlds=%s/%s, %s files, %s unique, %s files/s, %s/s, %s used, %s saved, %s    \r",
        strftime("%D %T",localtime()), 
        $ElapsedTime,
        map { Commify($_) } (
	    $CurrentArg,$ArgCount,
            $tl_dirs_doing, $tl_dirs_total, $files, $uniq_files,
        int($files/$ElapsedSeconds+0.5),
        ),
        FormatStorage($Usedspc/$ElapsedSeconds),
	FormatStorage($Usedspc),
	FormatStorage($Savedspc),
        $RootStub,
    );
    if ($PrintStats) {

        # This was a manual request.  Don't overwrite it.
        print "\n";
        $PrintStats = 0;    # Turn off manual request flag.
    }
}


#
# RegisterFile - Remember this file by MD5 and inode data.
#
{
    # This sub is in a closure so it can maintain a persistent
    # private hash.
    my %CountedInodes;

    sub RegisterFile ($$@) {
        my ( $md5, $cand, @candstat ) = @_;
        $UniqueFiles{ FileKey( $md5, @candstat ) } = $cand;
        my $size = $candstat[7];
        warn "size undefined"    unless defined $size;
        warn "usedspc undefined" unless defined $Usedspc;
        if ($Opt{debug}) {
            print "debug:   Registered new file: " . FileKey($md5,@candstat) . " => $cand\n";
        }
        return if $CountedInodes{ $candstat[1] }++;    # don't count twice
        $Usedspc += $size;
    }
}


#
# RegisterInode - Remember this inode by MD5 and inode data.
#

sub RegisterInode ($@) {
    my ( $first, @candstat ) = @_;
    my $key = InodeKey(@candstat);
    if ($candstat[3] > 1 ) {
        # There are other links to this inode.  Remember it.
    	$Inodes{ $key } = $first;
    	if ($Opt{debug}) {
        	print "debug:   Registered new inode: " . InodeKey(@candstat) . " => $first\n";
        }
    }
    elsif (exists($Inodes{ $key })) {
       # There's only one of these now.  No point in keeping it.
       delete $Inodes{ $key };
    }
    else {
       # This is the first and last time we'll see this one.  Ignore it.
    }
}


#
# KnownInodes - if we've already seen this inode, pass back the file it links to
#               or '' if it should stay as-is.  Else return undef.
sub KnownInodes(@) {
    if (exists($Inodes{InodeKey(@_)})) {
        my $first = $Inodes{InodeKey(@_)};
        return '' if ($first eq '');		# Leave as is.
        # So we're going to map this to another file, but make sure that
	# file hasn't disappeared since we last saw it.
        return $first if (-f $first);
    };
    return undef();
}



#
# WriteCheckpoint - write a checkpoint file.
#
sub WriteCheckpoint {

    my $CheckpointFile = "/tmp/$Prog.$$.checkpoint";

    $WriteCheckpoint = 0;	# Mark this as done.
    $LastCheckpoint = time();	# If we fail, warn and retry on next cycle.

    my $CH;
    if (!open($CH,'>',"$CheckpointFile.tmp")) {
        warn "Unable to write checkpoint file: $!";
        return;
    }
    my $Status = print $CH Dumper(@OrigARGV,%Opt,$Root,%Inodes,%UniqueFiles);
    close $CH;
    if (!$Status) {
        warn "Unable to write checkpoint file: $!";
        return;
    }
    if (-e $CheckpointFile) {
            if (!unlink($CheckpointFile)) {
                warn "Unable to delete $CheckpointFile: $!";
                return;
            }
    }
    if (!rename("$CheckpointFile.tmp","$CheckpointFile")) {
        warn "Unable to move $CheckpointFile.tmp: $!";
        return;
    }
}

       



#
# ProcessItem - process the next file (directory, ...) found.
#
sub ProcessFile {
    # See if the user has cancelled the job.
    if (CheckInterrupt()) {
        # Cancelling.  Prune everything until we get out.
        $File::Find::prune = 1;
        return;
    }

    my $cand = $File::Find::name;	# Get the full path name of our candidate.


    # Manage the checkpoint file.
    WriteCheckpoint() if ($WriteCheckpoint);

    # Manage stats and generate progress reports.
    ManageStats($cand);

    return if -l;          # Skip relative links.  No pay off.
    return unless -f _;    # Skip non-files.
    return unless -s _;    # Skip empty files.  Risk & no pay off.

    $files++;
    my $basename = $_;
    print "debug: Checking $cand\n" if ($Opt{debug});

    # If there's a limit on links, see if we've reached it.
    if ( $Opt{maxlinks} ) {
        my (@maxlstat) = stat($cand);
        if ( $maxlstat[3] > $Opt{maxlinks} ) {

            # the case that we have to make a new file from a link
            print "debug:   Link limit reached on $cand\n" if ($Opt{debug});
            my ( $fh, $tempfile ) =
              tempfile( "$Prog-2-XXXXXXXX", DIR => "." );
            unless ($tempfile) {
                die "Could not create a temporary file: $!";
            }
            unless ( rename $cand, $tempfile ) {
                die sprintf( "Could not rename %s to %s: %s",
                    $DV->stringify($cand), $DV->stringify($tempfile), $! );
            }
            cp $tempfile, $cand
              or die sprintf(
                "Could not cp %s to %s: %s",
                $DV->stringify($tempfile),
                $DV->stringify($cand), $!,
              );
            unlink $tempfile;
            $Savedspc -= $maxlstat[7];
        }
    }

    # Now get down to really processing this item.
    my (@candstat) = stat($basename);
    my $match;
    my $first = KnownInodes(@candstat);
    my @firststat;
    my $md5;

    # Four choices:
    #   1) We've seen this inode before, and it stayed as-is.  This one can too.
    #   2) We've seen this inode before, and it was replaced.  Replace this one
    #      the same way.
    #   3) It's content matches a prior file.  Link it and remember the inode.
    #   4) It doesn't match anything.  Remember it as a unique file and remember the inode.
    if (defined($first) and !$first ) {
        # Case 1: we've seen this before and it stayed as-is.
        print "debug:   $cand has same inode as $first -- leave as is\n"
            if ($Opt{debug});
        return;			# Leave it as-is.
    }
    elsif (defined($first) and $first) {
        # Case 2: we've seen this before and it was replaced.
        $match = 1;

        eval('@firststat = stat($first);');
        print "debug:   $cand has same inode as prior item -- link to $first\n"
            if ($Opt{debug});
    }
    elsif ($first = FindMatch($cand,\$md5,@candstat)) {
        # Case 3: We looked for and found a match.
        $match = 1;
        RegisterInode($first,@candstat);	# Remember how we handle this inode.
        print "debug:   $cand contents match -- link to $first\n"
            if ($Opt{debug});
    }
    else {
        # Case 4: It didn't match anything.
        $match = 0;
        RegisterFile( $md5, $cand, @candstat );	# Remember for future matches.
        RegisterInode('',@candstat);		# Remember this inode.
    }

    if ($match) {
        # Don't replace if we've exceeded our maxlinks.
        if ( $Opt{maxlinks} && $firststat[3] >= $Opt{maxlinks} ) {
            # Exceeded our link limit.  Register this as the new target file.
            RegisterFile( $md5, $cand, @candstat );
        }
        elsif ( ReplaceWithLink( $first, $cand ) ) {
            if ( $candstat[3] == 1 ) {    # we don't save space otherwise
                $Savedspc += -s $cand;
            }
        }
        else {
            # Tried but failed to hardlink.  Make candidate our new target.
            RegisterFile( $md5, $cand, @candstat );
            RegisterInode('',@candstat);
        }
    }

    # Skip the stats report unless:
    #    PrintStats = 1 (set by SIGUSR1)
    #    --stats specified and $files % 1000 == 0.
    PrintStatistics()
        if ( $PrintStats or ( $Opt{'stats'} and $files % $Opt{statinterval} == 0 ) );
    return;
}



#
# FindMatch - Try to find a file that matches this one.
#
sub FindMatch ($@) {
    my($cand,$md5ref,@candstat) = @_;

    # Calculate the MD5 sum of the candidate.
    my $fh;
    unless ( open $fh, "<", $cand ) {
        warn sprintf( "Cannot read %s (%s); Skipping.",
            $DV->stringify($File::Find::name), $!, );
        $Usedspc += -s $cand;
        return '';
    }


    my $LineEnd=$/;	# Save the line-end character.
    local $/;		# Don't impact other things.
    undef $/;		# Read the whole file.
    my $data = <$fh>;
    close $fh;
    $/ = $LineEnd;	# Put the line-end character back.
    $$md5ref = md5_hex $data;
    $data = '';	# Don't need to keep this in memory now.  Could be big.

    # See if we recognize this MD5 sum and stat attributes.
    if ( my $first = $UniqueFiles{ FileKey( $$md5ref, @candstat ) } ) {
        # It matches something previous, according to the MD5 and stat data.
	my @firststat;
        @firststat = stat($first);
        if (! $firststat[1]) {
            # This inode disappeared.
            print "debug:   Matching file disappeared: $first\n" if ($Opt{debug});
            delete $UniqueFiles { FileKey( $$md5ref, @candstat )};
            return;		# So then we have no match.
        }
        if ($firststat[0] == $candstat[0] and $firststat[1] == $candstat[1]) {
	    # We found ourselves.  This can happen if we restart/reload prior maps.
            # Treat it as a non-match and just fall through the parent's logic.
            print "debug:   Found self on $cand\n" if ($Opt{debug});
            return;
        }
        print "debug:   MD5 match: " . join(', ',@candstat) . ",$cand\n"
            . "              with: " . join(', ',@firststat) . ",$first\n"
                if ($Opt{debug});
        my $different = ($Opt{strict}?compare $first, $cand:0);
        if ( $different != 0 && $File::Compare::VERSION < 1.1005 ) {

            # workaround bug # 37716 in File::Compare
            $different = compare "$first\0", "$cand\0";
        }
        if ( $different < 0 ) {
            # Compare failed to run.
            warn sprintf(
                "Cannot compare %s and %s (%s); Skipping.",
                $DV->stringify($first),
                $DV->stringify($cand), $!,
            );
	    return;
        }
        elsif ($different == 0) {
            # We have a match!
            print "debug:  $cand matches $first\n" if ($Opt{debug} > 1);
            return $first;
        }
        else {
            # MD5 matched but binary compare differed!!!
            die sprintf(
                "MD5 collision!  %s and %s are not equal with same MD5 ($$md5ref)",
                $DV->stringify($first),
                $DV->stringify($cand)
                );
        }
    }
    else {
        print "debug:  $cand is unique\n" if ($Opt{debug} > 1);
        return;
    }
}



#
# CheckInterrupt
#
sub CheckInterrupt {
    if ( $Cancel and !$CancelConfirmed ) {

        # Don't lose hours (or days) of work due to a ^C in the wrong window.
        print "\nProgress report, statistics, options, cancel job, or none (p/s/o/c/n)? ";
        my $Response = <STDIN>;
	chomp $Response;
        if ( $Response eq 'c' ) {
            print "Cancel confirmed.  Wrapping up.\n";
            $CancelConfirmed = 1;
        }
        elsif ( $Response eq 'p' ) {
            $PrintProgress = 1;
	    $Cancel = 0;
        }
        elsif ( $Response eq 's' ) {
            PrintStatistics();
	    $Cancel = 0;
        }
        elsif ( $Response eq 'o' ) {
            my $Line;
            do {
	        print "Current options:\n";
                foreach (sort(keys(%Opt))) {
	            printf "\t%16s: %s\n", "--$_", $Opt{$_};
                }
                print "Enter new options or null to exit: ";
		$Line = <STDIN>;
                @ARGV = shellwords($Line);
                $Opt{'load-maps'}='';	# Don't reload the maps each time.
                ProcessOptions();
            } until ($Line =~ /^\s*$/);
        }
        elsif ( $Response eq 'n' ) {
            print "Resuming processing.\n";
            $Cancel = 0;
        }
        else {
            print "Unrecognized response.  Resuming processing.\n";
            $Cancel = 0;
        }
    }
    return ($Cancel and $CancelConfirmed);
}



#
# ManageStats - manage progress reports and statistics.
#
sub ManageStats {

    my $cand = shift;
    # Take care of progress reports.
    if ($PrintProgress) {

        # We've received a request for a progress report.
        print strftime( "%D %T Now processing $cand\n", localtime( time() ) );
        $PrintProgress = 0;    # Turn off flag.
    }

    # Manage our stats.
    if ( $cand eq $Root ) {
        # We're starting a ARGV item, count it's top-level directories.
        my $td = $_;
        opendir my ($dh), $td;
        my (@tl) = grep { !/^\./ && -d "$td/$_" } readdir $dh;
        $tl_dirs_total = @tl;
    }
    elsif (-d) {
        # We're continuing an item.  Find out if this is a new TLD.
        my $slashes = $cand =~ tr|/||;
        if ( $slashes == 1 ) {
            # It's a new TLD.  Update stats and ETA.
            $tl_dirs_doing++;
            if ( $Opt{eta} and $tl_dirs_doing > 1 ) {

                # Calculate our completion time.
                my $TimePerTLD =
                  ( time() - $StartTime ) / ( $tl_dirs_doing - 1 );
                my $ETA =
                  time() +
                  $TimePerTLD * ( $tl_dirs_total - $tl_dirs_doing - 1 );
                print $Root
                  . strftime( " estimated completion time: %T on %D\n",
                    localtime($ETA) );
            }
        }
    }
    return;
}



#
# FormatStorage - 
#
sub FormatStorage {

    my $Bytes = shift;
    if ($Bytes > 10*1024*1024*1024*1024) {
        return Commify(int($Bytes/1024/1024/1024/1024)) . 'T';
    }
    elsif ($Bytes > 10*1024*1024*1024) {
        return Commify(int($Bytes/1024/1024/1024)) . 'G';
    }
    elsif ($Bytes > 10*1024*1024) {
        return Commify(int($Bytes/1024/1024)) . 'M';
    }
    elsif ($Bytes > 10*1024) {
        return Commify(int($Bytes/1024)) . 'K';
    }
    else {
        return $Bytes . 'B';
    }
}

__END__

=head1 NAME

dirvish-dedup - traverse directories, find identical files, replace with hard links

=head1 SYNOPSIS

 dirvish-dedup.pl OPTIONS directory...

 OPTIONS:

  --maxlinks N            limit the amount of links per file
  -n|--dry-run		  report changes, but don't really link anything
  --progress		  print progress reports every 30 seconds
  --stats                 print search/link statistics every 100 files.
  -l|--logfile file	  write a link log to "file"
  --strict                physically compare files if the MD5 sum
                          and file size match.  This causes an
                          extra full file read of both files.
                          Default is to trust the MD5 + file size.

=head1 DESCRIPTION

This is a variant of the CPAN trimtrees.pl script.  The changes
consist of the following:

=over 4

=item

Added the --dry-run option

=item

In addition to comparing file contents, only consider files
to match if they have the same uid, gid, and permissions.  
Note that atime, ctime, and mtime values are not compared.

=item

Changed the thousands/millions separator in numbers from _ to ,

=item

Add time stamps and elapsed time to the completion message

=item

Process the directories in alphabetic order.

=back

Traverse all directories named on the command line, compute MD5
checksums and find files with identical MD5. IF they are equal, do a
real comparison if they are really equal, replace the second of two
files with a hard link to the first one.

Special care is taken to cope with C<Too many links> error conditions.
The inode that is overbooked in such a way, is taken out of the pool
and replaced with the another one such that the minimum of files
needed is kept on disk.

The C<--maxlinks> option can be used to reduce the linkcount on all
files within a tree, thus preparing the tree for a subsequent call to
C<cp -al>. This operation can be thought of the reverse of the normal
dirvish-dedup operation (--maxlinks=1 produces a tree without hard links).

=head1 SIGNALS

SIGINT is caught and the script stops as soon as the current file
is finished.

=head2 RISKS

The whole idea of replacing identical files with hard links has
inherent dangers. Once two files have turned into one inode other
processes may accidentally change both although they intend to alter
only one. Please consider if this can happen in your environment.

=cut

	Local Variables:
	mode: cperl
	cperl-indent-level: 2
	End:
