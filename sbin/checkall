#! /usr/bin/perl

use strict;
no strict 'refs';
use warnings;
use Getopt::Long qw(:config bundling no_auto_abbrev gnu_compat no_ignore_case);
use Sys::Syslog;
use Getopt::Std;
use IO::Socket;
use File::Temp qw(tempfile);
use POSIX qw(strftime);
use Fcntl;
use FindBin qw($RealBin $RealScript);
require CheckAll::CheckItem;

my $HIGHLIGHT = "\e[33;40;1m";	# Yellow FG, Black BG, Bright.
my $RESET = "\e[0m";

# Set a path, particularly for OnOK/OnFail actions.
$ENV{PATH}="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$ENV{PATH}";

our $opt_c='';			# Configuration file (service list).
our $opt_h=0;			# Help
our $opt_v=0;			# Verbose option.
our $opt_t=0;			# Test option.
our $opt_q=0;			# Quiet option.
our @opt_P;			# Who to page on errors.
our $opt_R=120;			# Set number of minutes to re-report fail items.
our $opt_s='';			# Alert subject
our $Prog = $RealScript;	# Get our program name.
$Prog=~s/\.pl$|\.bat$//;       	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";		# Trim off path, if present.
my @ItemList;			# List of item objects to check.
my @NowFail;			# Newly failing items.
my @NowOK;			# Newly OK items.
my @StillFail;			# On-going fail items.
my %FailItems;			# List of items previously failing.
my @OtherItems;			# Stuff in the status file from other check lists.
$| = 1;				# Unbuffer output.
my $StartTime = time();

my $StatusFile="$ENV{HOME}/.$Prog.dat";
my $ServiceList="/usr/local/etc/$Prog.list";

my $HostName = `hostname`;
chomp $HostName;

GetOptions (
	'v|verbose+'	=> \$opt_v,
	'c|config=s'	=> \$opt_v,
	'h|help'	=> \$opt_h,
	't|test'	=> \$opt_t,
	'q|quiet'	=> \$opt_q,
	'P|page=s'	=> \@opt_P,
	'R|renotify=i'	=> \$opt_R,
	's|subject=s'	=> \$opt_s,
);

# Check options.
if ($opt_h) {
	system("pod2text $RealBin/$RealScript");
	exit 1;
}

openlog("$Prog");


my $FailMessages;
if ($opt_q) {
	# Prepare the Fail-Message header text.
	my($Minutes,$Hours)=(localtime())[1,2];
	$Minutes="0$Minutes" if ($Minutes <= 9);
	$FailMessages="The following services have failed at 
$Hours:$Minutes...";
}

my $errors=0;
my %PIDs;		# Map PID to @ItemList.
my %NameMap;		# Maps status names to @ItemList.

# Prepare the list of files to process.
foreach (@ARGV) {
	# Add a path and file name prefix to parameters (not -c).
	s"^"/usr/local/etc/$Prog.";
}
push @ARGV,$opt_c if ($opt_c);	# Use opt_c for files in other locations.
push @ARGV,$ServiceList unless (@ARGV+0 > 0);	# Use default if nothing else.
foreach (@ARGV) {
	LoadServiceList($_,\@ItemList,\%NameMap);	# Load this file.
}

if (@ItemList+0 == 0) {
	# Nothing to monitor.
	warn "No services found in $ServiceList to monitor.";
	push @NowFail,"No services found to monitor";
}

# Load any prior statuses.
LoadPriorStatuses($StatusFile, \%NameMap, \@OtherItems);

# Go check all these services.
my $Services = @ItemList + 0;
my $DescLen = 0;		# Will keep length of longest desc here.
foreach my $Item (@ItemList) {
	my $CheckResult = Check $Item;
	my($Type,$Value) = ($CheckResult =~ m/^(\S+)=(\d+)$/);
	
	if ($Type eq 'Status') {		# 5.8 doesn't have switch.
		# This one returned a status immediately.
		$Item->Status($Value);
		$Services--;			# Not waiting on this one.
	}
	elsif ($Type eq 'PIDList') {
		# This one is running in the background.  Map the PID to the item.
		$PIDs{$Value} = $Item;
	}
	else	{
		# Somebody sent back a response we don't understand.
		die qq[Unexpected response "$CheckResult" from $Item->{'Desc'}];
	}

	# Track the length of our longest description for formatting purposes, but ignore headings.
	if (ref $Item ne 'heading') {
		my $Len = length($Item->{Desc});
		$DescLen = $Len if ($DescLen < $Len);
	}
}

# All background processes submitted.  Wait for the results to come in.
my $pid;
`tty -s`;	# Find out if we have a tty.
my $no_tty = $?;
if ($Services) {
	do {
		print "Waiting for results on $Services service" . ($Services==1?'':'s') . "   \r"
			unless ($no_tty or  $opt_q);
		$pid = waitpid(-1,0);
		$PIDs{$pid}->Status($?>>8) if ($pid > 0);
		$Services--;
	} while $pid > 0;
	# Wipe out waiting message.
	print ' 'x40 . "\r" unless ($no_tty or  $opt_q);
}

# All results are in.  Run back through our report and list the results.
my $Errors = 0;
my $Renotify = 0;		# Set to 1 if no changes but someone due for renotification.
$DescLen += 2;				# Add two blanks for padding.
foreach my $Item (@ItemList) {
	# Call report to issue visible status, and count failures.
	my $Desc = $Item->Desc;
	my $Status = $Item->Report($DescLen);
	if ($Status == 0) {
		#CHECK_STILL_OK -- can't get constants to export.
		# syslog('INFO','%s is still OK',$Desc)  - don't fill log with "still OK".
	 	#	if (ref $Item ne 'heading' and $^O !~ /MSWin/);
	}	
	elsif ($Status == 1) {
		syslog('WARNING','%s',"$Desc is still failing")
			if ($^O !~ /MSWin/);
		push @StillFail, $Desc;
		$Renotify++
			 if ((time() - $Item->PriorNotification) >
				60 * $Item->Renotifyinterval);
		$Errors++;
	}
	elsif ($Status == 2) {
		syslog('INFO','%s', "$Desc is NOW OK")
			if ($^O !~ /MSWin/);
		push @NowOK, $Desc;
		if (my $Action = $Item->Onok) {
			if ($opt_t) {
				print "\t\tTesting: OnOK for $Desc suppressed.\n";
			}
			else {
				print "Triggering OnOK for $Desc\n" if ($opt_v);
				$Action =~ s/%D/$Desc/g;
				system("($Action)&");
				my $Status = $?;
				syslog(($Status?'WARNING':'INFO'),'%s',"Executed OnOK actions for $Desc.  Status $Status.")
					if ($^O !~ /MSWin/);
			}
		}
	}
	elsif ($Status == 3) {
		syslog('WARNING','%s', "$Desc is NOW FAILING")
			if ($^O !~ /MSWin/);
		push @NowFail, $Desc;
		if (my $Action = $Item->Onfail) {
			if ($opt_t) {
				print "\t\tTesting: OnFail action for $Desc suppressed.\n";
			}
			else {
				print "Triggering OnFail for $Desc\n" if ($opt_v);
				$Action =~ s/%D/$Desc/g;
				system("($Action)&");
				my $Status = $?;
				syslog(($Status?'WARNING':'INFO'),'%s',"Executed OnFail actions for $Desc.  Status $Status.")
					if ($^O !~ /MSWin/);
			}
		}
		$Item->FirstFail($StartTime);	# Remember when it failed.
		$Errors++;
	}
	else {
		die "$Item->{FILE}:$Item->{LINE} Unexpected status $Status returned.";
	}
}

if (@NowFail+@NowOK+$Renotify > 0 and @opt_P > 0 and ! $opt_t) {
	# Set up the e-mail subject.
	my $TotalDown = @NowFail + @StillFail;
	my $Status;
	if ($TotalDown) {
		$Status = "$TotalDown service" . ($TotalDown > 1?'s':'') . " down";	# Something is down.
	}
	elsif (@NowOK) {
		$Status = 'All services restored';	# Was down, but all up now.
	}
	else {
		$Status = 'All services up';		# Never was done (shouldn't happen).
	}
	$opt_s = '%C alert: %S' unless ($opt_s);
	$opt_s =~ s/%C/$HostName/g;
	$opt_s =~ s/%N/$TotalDown/g;
	$opt_s =~ s/%S/$Status/g;

	# Build the e-mail text.	
	my($MAIL,$MailFile) = tempfile();
	
	if (@NowFail) {
		print $MAIL "Now fail: " . join(', ',@NowFail) . "\n";
	}
	if (@StillFail) {
		print $MAIL "Still failing: " . join(', ',@StillFail) . "\n";
	}
	if (@NowOK) {
		print $MAIL "Now OK: " . join(', ',@NowOK) . "\n";
	}

	# Send the e-mail.
	printf $MAIL strftime("\nFrom $HostName at %T on %D\n",localtime());
	close $MAIL;
	system("sed 's/  */ /g' $MailFile | mail -s \"$opt_s\" " . join(' ',@opt_P)) && warn "Unable to send mail: $!\n";
	unlink $MailFile;
	
	# Update all the notification times.
	foreach my $Item (@ItemList) {
		$Item->PriorNotification($StartTime);
	}
}

# Write the status file, so we know "still failing" from "now failing".
WriteStatusFile($StartTime,$StatusFile,\@ItemList,\@OtherItems) unless ($opt_t);

if (@NowFail+@StillFail > 0) {
	printf "%s==> %d " . ($Errors == 1?'service is':'services are') . " failing.%s\n",
		$HIGHLIGHT, $Errors, $RESET
		unless ($opt_q);
	exit 8;
}
else {
	print "All services are OK.\n" unless ($opt_q);
	syslog('INFO','All services are OK.')
		if ($^O !~ /MSWin/);
	exit 0;
}




#
# LoadServiceList - load a list of services.
#
sub LoadServiceList {
	my($ServiceList,$ArrayRef,$MapRef) = @_;
	return unless (-f $ServiceList);
	my $FH;
	if (sysopen($FH,$ServiceList,O_RDONLY)) {
		# Load the service file.
		my $LineInProgress = '';
		my $CompleteLine = '';
		my $StartLine;
		my $LineNum = 0;
		while (<$FH>) {
			$LineNum++;
			next if (/^\s*#/);			# Skip comments.
			next if (/^\s*$/);			# Skip blank lines.
			chomp;
			s/\s+$//;				# Strip trailing blanks.

			# Is this a continuation line (starts with white space)?
			if (/^\s+/) {
				# Yes.  Append it to any prior data.
				s/^\s+//;
				$LineInProgress .= " $_";	# Append to prior data.
			}
			else {
				# This is (the beginning of?) a new line.  Process the old line if we have one.
				ProcessServiceLine($ServiceList, $StartLine, $ArrayRef, $MapRef, $LineInProgress);
				$LineInProgress = $_;
				$StartLine = $LineNum;
			}
		}
		# Process the last line if we have one.
		ProcessServiceLine($ServiceList, $StartLine, $ArrayRef, $MapRef, $LineInProgress);	
		close $FH;
	}
}



#
# ProcessServiceLine : process one logical line from a service file.
#
sub ProcessServiceLine {
	my($FileName, $StartLine, $ArrayRef, $MapRef, $Line) = @_;
	return if ($Line =~ /^\s*$/);		# Skip empty lines.

	my($Keyword,$Rest) = split('\s+',$Line,2);
	$Keyword = lc($Keyword);				# Ignore case.
	if ($Keyword eq 'include') {
		# Include file.
		$Rest =~ s/^(["'])(.*)\1$/$2/;	# Strip quotes.
		LoadServiceList($Rest,$ArrayRef,$MapRef);
		return 0;
	}

	# Must be a check type.  Load it if it isn't already loaded.
	if (!exists($INC{"CheckAll/$Keyword.pm"})) {
	#		eval("use CheckAll::$Keyword;");
		eval qq[require "CheckAll/$Keyword.pm"];
		if ($@) {
			warn qq[$FileName:$StartLine: Unable to include a "$Keyword" module: $@\n];
			return 1;
		}
	}

	# Create this object and put it in @ItemList.
	my $Item;
	eval {
		$Item = $Keyword->new (
			"$FileName",	# For object error msgs.
			"$StartLine",	# For object error msgs.
			$Rest);		# Other parameters.
	};
	if ($@) {
		warn qq[$FileName:$StartLine: Unable to create a "$Keyword" item: $@\n];
		return 2;	
	}
	else {
		# Set the unique name if it isn't already set.
		$Item->Name(ref($Item) . "=" . $Item->Target) unless ($Item->Name);

		# Map the name to this item.
		$MapRef->{$Item->Name} = $Item;
		push @$ArrayRef,$Item;
		return 0;
	}
}



sub LoadPriorStatuses {

	my($StatusFile,$MapRef,$OtherRef) = @_;

	# Load table of items that have already been reported failing.
	my $STATUS;
	if (-f $StatusFile) {
		if (sysopen($STATUS,$StatusFile,O_RDONLY)) {
			# Load up any items that were previously failing.
			while (<$STATUS>) {
				next unless
					(/^Name=(.*), FailAt=(\d+)=\S+ \S+, LastNotify=(\d+)=\S+ \S+, LastCheck=(\d+)=\S+ \S+,?/);
				my($Name,$FirstFail,$LastNotify,$LastCheck)=($1,$2,$3,$4);
				if(exists($MapRef->{$Name})) {
					$MapRef->{$Name}->{PriorStatus} = 8;
					$MapRef->{$Name}->{FirstFail} = $FirstFail;
					$MapRef->{$Name}->{PriorNotification} = $LastNotify;
				}
				elsif ((time()-$LastCheck)/86400 <= 60) {
					# Not one of ours.  Must come from another config file.  Just 
					# store it to write back later.
					push @$OtherRef,$_;
				}
				else {
					# Nobody has checked this one for 60 days.  Forget it.
				}
			}
			close $STATUS;
		}
		else {
			warn "Unable to open $StatusFile: $!\n";
		}
	}
}




sub WriteStatusFile {

	my($StartTime,$StatusFile,$ArrayRef,$OtherRef) = @_;
	my $STATUS;
	if (open ($STATUS,"> $StatusFile")) {
		foreach my $Item (@$ArrayRef) {
			next if ($Item->Status eq 0);		# Skip OK services.
			next if (ref $Item eq 'history');	# We don't track history lines.
			printf $STATUS "Name=%s, FailAt=%d=%s, LastNotify=%d=%s, LastCheck=%d=%s, File=%s:%d\n",
				$Item->Name,
				$Item->FirstFail,
				strftime("%D %T",localtime($Item->FirstFail)),
				$Item->PriorNotification,
				strftime("%D %T",localtime($Item->PriorNotification)),
				$StartTime,
				strftime("%D %T",localtime($StartTime)),
				$Item->{FILE},
				$Item->{LINE}
			;
		}
		# Write out stuff we found in the status file that weren't ours.
		foreach (@$OtherRef) {
			print $STATUS $_;
		}
		close $STATUS;
	}
	else {
		warn("Unable to update $StatusFile: $!\n");
	}
}
=pod

=head1 checkall -- check on services

=head2 Overview

checkall checks critical services to make sure they're running.  It can optionally 
take action when a service fails or recovers, and/or send out notifications.

=head2 Command format:

   checkall [options] [listname ...]

=head2 Command options:

=over 3

=item -c file

Service file -- normally the service to monitor are determined by reading files
from /usr/local/etc/checkall.list (default) or /usr/local/etc/checkall.I<listname>
if one or more list names are provided on the command line.  The -c option provides an
alternate way of identifying a service file, when the desired file isn't named according
to the "listname" standard (i.e. isn't located in /usr/local/etc).

=item -h, --help

Help -- print this documentation

=item -P address, --page=address

Page -- send a message to this e-mail address whenever services transition from OK
to failing or vice versa, or if enough time has elapsed to warrant renotification.
This option may be repeated to send e-mails to multiple addresses.

=item -q, --quiet

Quiet - suppress status messages.

=item -R minutes, --renotify=minutes

Renotify -- send out another page if a service has been failing for this many minutes
since the last page.  Default is 120 (2 hours).

=item -s subject, --subject=subject

Subject -- use this subject line when sending out pages.  The following substitutions 
are made:
	"%C" is replaced with the host Computer name.
	"%N" is replaced with the Number of services down.
	"%S" is replaced with an English status phrase (e.g. "All services restored").

=item -v, --verbose

Verbose -- turn on diagnostics.

=back

=head2 Service List Files

checkall determines what services to monitor by using service list files.  The default
service list is "/usr/local/etc/checkall.list".  Alternate or additional lists can be
saved as "/usr/local/etc/checkall.I<name>", where "name" matches the name specified on the
command line (e.g. /usr/local/etc/checkall.urgent would be referenced by "checkall urgent").
Service lists that don't follow this naming convention can be specified using the -c option.

Service list files are formatted according to the following rules:

=over 3

=item *

Blank lines and lines starting with # are ignored

=item *

Lines beginning with white space are treated as continuation lines.

=item *

A service list file may include another service list file using the "include" directive as follows:

   include path-to-file

=item *

All other lines designate services to check.  The general format of a service line is:

   checktype parameters

"checktype" refers to a Perl check module called "CheckAll::I<checktype>".  This module will be 
loaded if necessary, and passed the parameters provided.  Most modules require at least a
Target= parameter and a Desc= parameter.  See the documentation in CheckAll::CheckItem for common
parameters, and other modules in the CheckAll:: tree for kinds of checks and specific parameters.

The most common checks are "tcpport", which checks for connectivity to a TCP socket, and "process", which
checks the process table for a running process.  "heading" is also used to insert headings.
=back

=cut

