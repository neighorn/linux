#! /usr/bin/perl

use strict;
no strict 'refs';
use warnings;
use Sys::Syslog;
use Getopt::Std;
use IO::Socket;
use File::Temp qw(tempfile);
use POSIX qw(strftime);
use Fcntl;
use FindBin qw($RealBin $RealScript);
require CheckAll::CheckItem;

my $HIGHLIGHT = "\e[33;40m";
my $RESET = "\e[0m";

our $opt_c='';			# Configuration file (service list).
our $opt_v=0;			# Verbose option.
our $opt_t=0;			# Test option.
our $opt_q=0;			# Quiet option.
our $opt_P='';			# Who to page on errors.
our $opt_R=120;			# Set number of minutes to re-report down items.
our $opt_s='';			# Alert subject
our $Prog = $RealScript;	# Get our program name.
$Prog=~s/\.pl$|\.bat$//;       	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";		# Trim off path, if present.
my @ItemList;			# List of item objects to check.
my @NowDown;			# Newly down items.
my @NowUp;			# Newly up items.
my @StillDown;			# On-going down items.
my %DownItems;			# List of items previously down.
$| = 1;				# Unbuffer output.
my $StartTime = time();

my $StatusFile="$ENV{HOME}/.$Prog.dat";
my $ServiceList="/usr/local/etc/$Prog.list";

my $HostName = `hostname`;
chomp $HostName;

getopts('c:P:qR:s:v');

# Check options.
if ($opt_s) {
	$opt_s =~ s/%C/$HostName/g;
}
else {
	$opt_s = "$HostName alert";
}

openlog("$Prog");


my $DownMessages;
if ($opt_q) {
	# Prepare the Down-Message header text.
	my($Minutes,$Hours)=(localtime())[1,2];
	$Minutes="0$Minutes" if ($Minutes <= 9);
	$DownMessages="The following services were detected down at 
$Hours:$Minutes...";
}

my $errors=0;
my %PIDs;		# Map PID to @ItemList.
my %NameMap;		# Maps status names to @ItemList.

# Prepare the list of files to process.
foreach (@ARGV) {
	# Add a path and file name prefix to parameters (not -c).
	s"^"/usr/local/etc/$Prog.";
}
push @ARGV,$opt_c if ($opt_c);	# Use opt_c for files in other locations.
push @ARGV,$ServiceList unless (@ARGV+0 > 0);	# Use default if nothing else.
foreach (@ARGV) {
	LoadServiceList($_,\@ItemList,\%NameMap);	# Load this file.
}

if (@ItemList+0 == 0) {
	# Nothing to monitor.
	warn "No services found in $ServiceList to monitor.";
	push @NowDown,"No services found to monitor";
}

# Load any prior statuses.
LoadPriorStatuses($StatusFile, \%NameMap);

# Go check all these services.
my $Services = @ItemList + 0;
my $DescLen = 0;		# Will keep length of longest desc here.
foreach my $Item (@ItemList) {
	my $CheckResult = Check $Item;
	my($Type,$Value) = ($CheckResult =~ m/^(\S+)=(\d+)$/);
	
	if ($Type eq 'Status') {		# 5.8 doesn't have switch.
		# This one returned a status immediately.
		$Item->Status($Value);
		$Services--;			# Not waiting on this one.
	}
	elsif ($Type eq 'PIDList') {
		# This one is running in the background.  Map the PID to the item.
		$PIDs{$Value} = $Item;
	}
	else	{
		# Somebody sent back a response we don't understand.
		die qq[Unexpected response "$CheckResult" from $Item->{'Desc'}];
	}

	if (ref $Item ne 'heading') {
		my $Len = length($Item->{Desc});
		$DescLen = $Len if ($DescLen < $Len);
	}
}

# All background processes submitted.  Wait for the results to come in.
my $pid;
if ($Services) {
	do {
		print "Waiting for results on $Services service" . ($Services==1?'':'s') . "   \r";
		$pid = waitpid(-1,0);
		$PIDs{$pid}->Status($?) if ($pid > 0);
		$Services--;
	} while $pid > 0;
	print ' 'x40 . "\r";		# Wipe out waiting message.
}

# All results are in.  Run back through our report and list the results.
my $Errors = 0;
my $Renotify = 0;		# Set to 1 if no changes but someone due for renotification.
$DescLen += 2;				# Add two blanks for padding.
foreach my $Item (@ItemList) {
	# Call report to issue visible status, and count failures.
	my $Desc = $Item->Desc;
	my $Status = $Item->Report($DescLen);
	if ($Status == 0) {
		#CHECK_STILL_UP -- can't get constants to export.
		syslog('INFO','%s is still up',$Desc)
			if ($^O !~ /MSWin/);
	}	
	elsif ($Status == 1) {
		#CHECK_STILL_DOWN {
		syslog('INFO','%s is still down',$Desc)
			if ($^O !~ /MSWin/);
		push @StillDown, $Desc;
		$Renotify++
			 if ((time() - $Item->PriorNotification) >
				60 * $Item->Renotifyinterval);
		$Errors++;
	}
	elsif ($Status == 2) {
		#CHECK_NOW_UP {
		syslog('INFO','%s is NOW up',$Desc)
			if ($^O !~ /MSWin/);
		push @NowUp, $Desc;
		if (my $Action = $Item->Onup) {
			print "Triggering OnUp for $Desc\n" if ($opt_v);
			$Action =~ s/%D/$Desc/g;
			system("($Action)&");
			syslog('INFO',"Executed OnUp actions for $Desc.  Status $?")
				if ($^O !~ /MSWin/);
		}
	}
	elsif ($Status == 3) {
		#CHECK_NOW_DOWN {
		syslog('INFO','%s is NOW down',$Desc)
			if ($^O !~ /MSWin/);
		push @NowDown, $Desc;
		if (my $Action = $Item->Ondown) {
			print "Triggering OnDown for $Desc\n" if ($opt_v);
			$Action =~ s/%D/$Desc/g;
			system("($Action)&");
			syslog('INFO',"Executed OnDown actions for $Desc.  Status $?")
				if ($^O !~ /MSWin/);
		}
		$Item->FirstDown($StartTime);	# Remember when it went down.
		$Errors++;
	}
	else {
		die "$Item->{FILE}:$Item->{LINE} Unexpected status $Status returned.";
	}
}

if (@NowDown+@NowUp+$Renotify > 0 and $opt_P) {
	my($MAIL,$MailFile) = tempfile();
	
	if (@NowDown) {
		print $MAIL "Now down: " . join(', ',@NowDown) . "\n";
	}
	if (@StillDown) {
		print $MAIL "Still down: " . join(', ',@StillDown) . "\n";
	}
	if (@NowUp) {
		print $MAIL "Now up: " . join(', ',@NowUp) . "\n";
	}
	printf $MAIL strftime("\nFrom $HostName at %T on %D\n",localtime());
	close $MAIL;
	system("sed 's/  */ /g' $MailFile | mail -s \"$opt_s\" $opt_P") && warn "Unable to send mail: $!\n";
	unlink $MailFile;
	
	# Update all the notification times.
	foreach my $Item (@ItemList) {
		$Item->PriorNotification($StartTime);
	}
}

# Write the status file, so we know "still down" from "now down".
WriteStatusFile($StartTime,$StatusFile,\@ItemList);

if (@NowDown+@StillDown > 0) {
	exit 8;
}
else {
	exit 0;
}




#
# LoadServiceList - load a list of services.
#
sub LoadServiceList {
	my($ServiceList,$ArrayRef,$MapRef) = @_;
	return unless (-f $ServiceList);
	my $FH;
	if (sysopen($FH,$ServiceList,O_RDONLY)) {
		# Load the service file.
		my $LineInProgress = '';
		my $CompleteLine = '';
		my $StartLine;
		my $LineNum = 0;
		while (<$FH>) {
			$LineNum++;
			next if (/^\s*#/);			# Skip comments.
			next if (/^\s*$/);			# Skip blank lines.
			chomp;
			s/\s+$//;				# Strip trailing blanks.

			# Is this a continuation line (starts with white space)?
			if (/^\s+/) {
				# Yes.  Append it to any prior data.
				s/^\s+//;
				$LineInProgress .= " $_";	# Append to prior data.
			}
			else {
				# This is (the beginning of?) a new line.  Process the old line if we have one.
				ProcessServiceLine($ServiceList, $StartLine, $ArrayRef, $MapRef, $LineInProgress);
				$LineInProgress = $_;
				$StartLine = $LineNum;
			}
		}
		# Process the last line if we have one.
		ProcessServiceLine($ServiceList, $StartLine, $ArrayRef, $MapRef, $LineInProgress);	
		close $FH;
	}
}



#
# ProcessServiceLine : process one logical line from a service file.
#
sub ProcessServiceLine {
	my($FileName, $StartLine, $ArrayRef, $MapRef, $Line) = @_;
	return if ($Line =~ /^\s*$/);		# Skip empty lines.

	my($Keyword,$Rest) = split('\s+',$Line,2);
	$Keyword = lc($Keyword);				# Ignore case.
	if ($Keyword eq 'include') {
		# Include file.
		$Rest =~ s/^(["'])(.*)\1$/$2/;	# Strip quotes.
		LoadServiceList($Rest,$ArrayRef,$MapRef);
		return 0;
	}

	# Must be a check type.  Load it if it isn't already loaded.
	if (!exists($INC{"CheckAll/$Keyword.pm"})) {
	#		eval("use CheckAll::$Keyword;");
		eval qq[require "CheckAll/$Keyword.pm"];
		if ($@) {
			warn qq[$ServiceList:$StartLine: Unable to include a "$Keyword" module -- skipped\n];
			return 1;
		}
	}

	# Create this object and put it in @ItemList.
	my $Item;
	eval {
		$Item = $Keyword->new (
			"$ServiceList",	# For object error msgs.
			"$StartLine",	# For object error msgs.
			$Rest);		# Other parameters.
	};
	if ($@) {
		warn qq[$ServiceList:$StartLine: Unable to create a "$Keyword" item: $@\n];
		return 2;	
	}
	else {
		# Set the unique name if it isn't already set.
		$Item->Name($Item->Desc) unless ($Item->Name);
		# Map the name to this item.
		if (exists($MapRef->{$Item->Name}) and $Keyword ne 'heading') {
			warn qq[$Item->{FILE}:$Item->{LINE}: Item has non-unique name "$Item->{Name}" -- skipped.  Set a unique Desc or use Name=\n];
			return 3;
		}
		else {
			$MapRef->{$Item->Name} = $Item;
			push @$ArrayRef,$Item;
			return 0;
		}
	}
}





sub LoadPriorStatuses {

	my($StatusFile,$MapRef) = @_;

	# Load table of items that have already been reported down.
	my $STATUS;
	if (-f $StatusFile) {
		if (sysopen($STATUS,$StatusFile,O_RDONLY)) {
			# Load up any items that were previously down.
			while (<$STATUS>) {
				next unless (/^Name=(.*), DownAt=(\d+)=\S+ \S+, LastNotify=(\d+)=/);
				my($Name,$FirstDown,$LastNotify)=($1,$2,$3);
				if(exists($MapRef->{$Name})) {
					$MapRef->{$Name}->{PriorStatus} = 8;
					$MapRef->{$Name}->{FirstDown} = $FirstDown;
					$MapRef->{$Name}->{PriorNotification} = $LastNotify;
				}
				else {
					# Obsolete service (removed from service list).
				}
			}
			close $STATUS;
		}
		else {
			warn "Unable to open $StatusFile: $!\n";
		}
	}
}




sub WriteStatusFile {

	my($StartTime,$StatusFile,$ArrayRef) = @_;
	my $STATUS;
	if (open ($STATUS,"> $StatusFile")) {
		foreach my $Item (@$ArrayRef) {
			next unless ($Item->Status eq 8);	# Skip up services.
			next if (ref $Item eq 'history');	# We don't track history lines.
			printf $STATUS "Name=%s, DownAt=%d=%s, LastNotify=%d=%s\n",
				$Item->Name,
				$Item->FirstDown,
				strftime("%D %T",localtime($Item->FirstDown)),
				$Item->PriorNotification,
				strftime("%D %T",localtime($Item->PriorNotification));
		}
		close $STATUS;
	}
	else {
		warn("Unable to update $StatusFile: $!\n");
	}
}
