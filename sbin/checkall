#! /usr/bin/perl

use strict;
no strict 'refs';
use warnings;
use Getopt::Long qw(:config bundling no_auto_abbrev gnu_compat no_ignore_case);
use Sys::Syslog;
use Getopt::Std;
use IO::Socket;
use File::Temp qw(tempfile);
use POSIX qw(strftime);
use Fcntl;
use FindBin qw($Bin $Script);
require CheckAll::CheckItem;

my $HIGHLIGHT = "\e[33;40;1m";	# Yellow FG, Black BG, Bright.
my $RESET = "\e[0m";

# Set a path, particularly for OnOK/OnFail actions.
$ENV{PATH}="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$ENV{PATH}";

our $opt_c='';			# Configuration file (service list).
our $opt_f='';			# Configuration file (service list).
our $opt_h=0;			# Help
our $opt_v=0;			# Verbose option.
our $opt_t=0;			# Test option.
our $opt_q=0;			# Quiet option.
our @opt_P;			# Who to page on errors.
our $opt_R=120;			# Set number of minutes to re-report fail items.
our $opt_s='';			# Alert subject
our $opt_S=0;			# Single - only run one process at a time (for debugging).
our $opt_w=20;			# Wait time in seconds (for checks that timeout)
our $Prog = $Script;	# Get our program name.
$Prog=~s/\.pl$|\.bat$//;       	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";		# Trim off path, if present.
my @ItemList;			# List of item objects to check.
my @NowFail;			# Newly failing items.
my @NowOK;			# Newly OK items.
my @StillFail;			# On-going fail items.
my %FailItems;			# List of items previously failing.
my @OtherItems;			# Stuff in the status file from other check lists.
$| = 1;				# Unbuffer output.
my $StartTime = time();

my $StatusFile="$ENV{HOME}/.$Prog.dat";
my $ServiceList="/usr/local/etc/$Prog.list";

our $HostName = `hostname`;
chomp $HostName;

GetOptions (
	'v|verbose+'	=> \$opt_v,
	'c|config=s'	=> \$opt_c,
	'fail|failed'	=> \$opt_f,
	'h|help'	=> \$opt_h,
	't|test'	=> \$opt_t,
	'q|quiet'	=> \$opt_q,
	'P|page=s'	=> \@opt_P,
	'R|renotify=i'	=> \$opt_R,
	's|subject=s'	=> \$opt_s,
	'S|single!'		=> \$opt_S,
	'w|waittime=i'	=> \$opt_w,
);

# Check options.
if ($opt_h) {
	system("pod2text $Bin/$Script");
	exit 1;
}

openlog("$Prog");


my $FailMessages;
if ($opt_q) {
	# Prepare the Fail-Message header text.
	my($Minutes,$Hours)=(localtime())[1,2];
	$Minutes="0$Minutes" if ($Minutes <= 9);
	$FailMessages="The following services have failed at 
$Hours:$Minutes...";
}

my $errors=0;
my %PIDs;		# Map PID to @ItemList.
my %NameMap;		# Maps status names to @ItemList.

# Prepare the list of files to process.
foreach (@ARGV) {
	# Add a path and file name prefix to unqualified names.
	s"^"/usr/local/etc/$Prog." unless (m"/");
}
push @ARGV,$opt_c if ($opt_c);	# Use opt_c for files in other locations.
push @ARGV,$ServiceList unless (@ARGV+0 > 0);	# Use default if nothing else.
foreach (@ARGV) {
	LoadServiceList($_,\@ItemList,\%NameMap);	# Load this file.
}

if (@ItemList+0 == 0) {
	# Nothing to monitor.
	warn "No services found in $ServiceList to monitor.";
	push @NowFail,"No services found to monitor";
}

# Load any prior statuses.
LoadPriorStatuses($StatusFile, \%NameMap, \@OtherItems);

# Go check all these services.
my $Services = @ItemList + 0;
my $DescLen = 0;		# Will keep length of longest desc here.
foreach my $Item (@ItemList) {
	my $CheckResult = Check $Item;
	my($Type,$Value) = ($CheckResult =~ m/^(\S+)=(\d+)$/);
	
	if ($Type eq 'Status') {		# 5.8 doesn't have switch.
		# This one returned a status immediately.
		$Item->Status($Value);
		$Services--;			# Not waiting on this one.
	}
	elsif ($Type eq 'PIDList') {
		# This one is running in the background.  Map the PID to the item.
		$PIDs{$Value} = $Item;
		if ($opt_S) {
			# Single-service submission - primarily to make debugging easier.
			my $pid = waitpid($Value,0);
			$PIDs{$pid}->Status($?>>8) if ($pid > 0);
			$Services--;
		}
	}
	else	{
		# Somebody sent back a response we don't understand.
		die qq[Unexpected response "$CheckResult" from $Item->{'Desc'}];
	}

	# Track the length of our longest description for formatting purposes, but ignore headings.
	if (ref $Item ne 'heading') {
		my $Len = length($Item->{Desc});
		$DescLen = $Len if ($DescLen < $Len);
	}
	
}

# All background processes submitted.  Wait for the results to come in.
my $pid;
`tty -s`;	# Find out if we have a tty.
my $no_tty = $?;
if ($Services) {
	do {
		print "Waiting for results on $Services service" . ($Services==1?'':'s') . "   \r"
			unless ($no_tty or  $opt_q);
		$pid = waitpid(-1,0);
		$PIDs{$pid}->Status($?>>8) if ($pid > 0);
		$Services--;
	} while $pid > 0;
	# Wipe out waiting message.
	print ' 'x40 . "\r" unless ($no_tty or  $opt_q);
}

# All results are in.  Run back through our report and list the results.
my $Errors = 0;
my $WorstError = 0;		# Set to 4 for delayed notification, 8 for full failure.
my $Renotify = 0;		# Set to 1 if no changes but some service is due for renotification.
$DescLen += 2;			# Add two blanks for padding.
my $Now = time();		# Avoid repeated calls.
foreach my $Item (@ItemList) {
	# Call report to issue visible status, and count failures.
	my $Desc = $Item->Desc;
	my $Status = $Item->Report($DescLen,$opt_f);
	my $DoDownActions = 0;
	if ($Status == 0) {
		#
		# CHECK_STILL_OK -- Item is still up.
		#
		# syslog('INFO','%s is still OK',$Desc)  - don't fill log with "still OK".
	 	#	if (ref $Item ne 'heading' and $^O !~ /MSWin/);
	}	
	elsif ($Status == 1) {
		#
		# CHECK_STILL_DOWN -- Item is still down.
		#
		$Errors++;
		#syslog('WARNING','%s',"$Desc is still failing")
		#	if ($^O !~ /MSWin/);
		if ($Now >= $Item->NextNotification) {
			$Renotify++;
			$WorstError = 8;
			$Item->NextNotification(
				$Now +
				60*(defined($Item->Renotifyinterval)?$Item->Renotifyinterval:$opt_R)
			);
			if ($Item->FirstNotification == 0) {
				# This was a DelayFirstNotification target, that has remained down through the delay period.
				# Essentially, it's a firstfail as far as notifications are concerned.
				$DoDownActions = 1;
				$Item->FirstNotification($Now);
			}
			else {
				# We sent out notifications before, but it's time for another one.
				push @StillFail, $Desc;
			}
		}
		if ($Item->FirstNotification == 0) {
			# We have a service down with a delay notification that hasn't notified yet.
			$WorstError = 4 if ($WorstError < 4);
			print "debug: " . $Item->FirstNotification . ", $Now < " . $Item->NextNotification . "\n";
		}
		else {
			# A service is down.
			$WorstError = 8;
		}
	}
	elsif ($Status == 2) {
		#
		# CHECK_NOW_OK -- Item is back up.
		#
		#syslog('INFO','%s', "$Desc is NOW OK")
		#	if ($^O !~ /MSWin/);
		next if ($Item->FirstNotification == 0);	# Recovered within DelayFirstNotification period.
		push @NowOK, $Desc;
		if (my $Action = $Item->Onok) {
			if ($opt_t) {
				print "\t\tTesting: OnOK for $Desc suppressed.\n";
			}
			else {
				print "Triggering OnOK for $Desc\n" if ($opt_v);
				$Action =~ s/%D/$Desc/g;
				system("($Action)&");
				my $Status = $?;
				syslog(($Status?'WARNING':'INFO'),'%s',"Executed OnOK actions for $Desc.  Status $Status.")
					if ($^O !~ /MSWin/);
			}
		}
	}
	elsif ($Status == 3) {
		#
		# CHECK_NOW_DOWN -- Item has gone down.
		#
		$Item->FirstFail($StartTime);	# Remember when it failed.
		$Errors++;
		
		# Delay errors on first notification if DelayFirstNotification time specified.
		if ($Item->Delayfirstnotification) {
			#
			# Delaying notifications.
			syslog('INFO','%s', "$Desc notification delayed per config")
				if ($^O !~ /MSWin/);
			$Item->FirstNotification(0);
			$Item->NextNotification($Now + 60*$Item->Delayfirstnotification);
			$WorstError = 4 if ($WorstError == 0);
			next;
		}
		else {
			#
			# Not delaying notifications.
			#syslog('WARNING','%s', "$Desc is NOW FAILING")
			#	if ($^O !~ /MSWin/);
			$DoDownActions = 1;
			$Item->FirstNotification($Now);
			$WorstError = 8;
		}
	}
	else {
		die "$Item->{FILE}:$Item->{LINE} Unexpected status $Status returned.";
	}

	# Common code for "Now Down and no delay notification" or "Still down and delay time expired"
	if ($DoDownActions) {
		push @NowFail, $Desc;
		if (my $Action = $Item->Onfail) {
			if ($opt_t) {
				print "\t\tTesting: OnFail action for $Desc suppressed.\n";
			}
			else {
				print "Triggering OnFail for $Desc\n" if ($opt_v);
				$Action =~ s/%D/$Desc/g;
				system("($Action)&");
				my $Status = $?;
				syslog(($Status?'WARNING':'INFO'),'%s',"Executed OnFail actions for $Desc.  Status $Status.")
					if ($^O !~ /MSWin/);
			}
		}
		$Item->NextNotification(
			$Now +
				60*(defined($Item->Renotifyinterval)?$Item->Renotifyinterval:$opt_R)
		);
	}
}

if (@NowFail+@NowOK+$Renotify > 0 and @opt_P > 0 and ! $opt_t) {
	# Set up the e-mail subject.
	my $TotalDown = @NowFail + @StillFail;
	my $Status;
	if ($TotalDown) {
		$Status = "$TotalDown service" . ($TotalDown > 1?'s':'') . " down";	# Something is down.
	}
	elsif (@NowOK) {
		$Status = 'All services restored';	# Was down, but all up now.
	}
	else {
		$Status = 'All services up';		# Never was down (shouldn't happen).
	}
	$opt_s = '%C alert: %S' unless ($opt_s);
	$opt_s =~ s/%C/$HostName/g;
	$opt_s =~ s/%N/$TotalDown/g;
	$opt_s =~ s/%S/$Status/g;

	# Build the e-mail text.	
	my($MAIL,$MailFile) = tempfile();
	my $ToList=join(', ',@opt_P);
	print $MAIL <<ENDHeaders;
X-Jobsummary: Name=checkall Status=8 RunTime=0:0:0:20
To: $ToList
Subject: $opt_s

ENDHeaders
	
	if (@NowFail) {
		print $MAIL "Now failing: " . join(', ',@NowFail) . "\n";
	}
	if (@StillFail) {
		print $MAIL "Still failing: " . join(', ',@StillFail) . "\n";
	}
	if (@NowOK) {
		print $MAIL "Now OK: " . join(', ',@NowOK) . "\n";
	}

	# Send the e-mail.
	printf $MAIL strftime("\nFrom $HostName at %T on %D\n",localtime());
	close $MAIL;
	if (my $Status = system("sed 's/  */ /g' $MailFile | sendmail " . join(' ',@opt_P))) {
		syslog('ERROR','%s','Unable to send notifications. RC=$Status, Error=$!')
			if ($^O !~ /MSWin/);
	}
	else {
		syslog('INFO','%s','Notifications sent.') if ($^O !~ /MSWin/);
	}
	unlink $MailFile;
}

# Write the status file, so we know "still failing" from "now failing".
WriteStatusFile($StartTime,$StatusFile,\@ItemList,\@OtherItems) unless ($opt_t);

if ($Errors > 0) {
	printf "%s==> %d " . ($Errors == 1?'service is':'services are') . " failing.%s\n",
		$HIGHLIGHT, $Errors, $RESET
		unless ($opt_q);
	exit $WorstError;
}
else {
	print "All services are OK.\n" unless ($opt_q);
	syslog('INFO','All services are OK.')
		if ($^O !~ /MSWin/);
	exit 0;
}




#
# LoadServiceList - load a list of services.
#
sub LoadServiceList {
	my($ServiceList,$ArrayRef,$MapRef) = @_;
	return unless (-f $ServiceList);
	my $FH;
	if (sysopen($FH,$ServiceList,O_RDONLY)) {
		# Load the service file.
		my $LineInProgress = '';
		my $CompleteLine = '';
		my $StartLine;
		my $LineNum = 0;
		while (<$FH>) {
			$LineNum++;
			next if (/^\s*#/);			# Skip comments.
			next if (/^\s*$/);			# Skip blank lines.
			chomp;
			s/\s+$//;				# Strip trailing blanks.

			# Is this a continuation line (starts with white space)?
			if (/^\s+/) {
				# Yes.  Append it to any prior data.
				s/^\s+//;
				$LineInProgress .= " $_";	# Append to prior data.
			}
			else {
				# This is (the beginning of?) a new line.  Process the old line if we have one.
				ProcessServiceLine($ServiceList, $StartLine, $ArrayRef, $MapRef, $LineInProgress);
				$LineInProgress = $_;
				$StartLine = $LineNum;
			}
		}
		# Process the last line if we have one.
		ProcessServiceLine($ServiceList, $StartLine, $ArrayRef, $MapRef, $LineInProgress);	
		close $FH;
	}
}



#
# ProcessServiceLine : process one logical line from a service file.
#
sub ProcessServiceLine {
	my($FileName, $StartLine, $ArrayRef, $MapRef, $Line) = @_;
	return if (!defined($Line) or $Line =~ /^\s*$/);		# Skip empty lines.
	print "Verbose: Processing line $StartLine: $Line\n" if ($opt_v >= 3);

	my($Keyword,$Rest) = split('\s+',$Line,2);
	$Keyword = lc($Keyword);				# Ignore case.

	# Is there an "ifhost" prefix to this test?
##### ifhost and ifcmd need quote processing on the second argument only.
	if ($Keyword eq 'ifhost') {
		# Ifhost /pattern/ selection statement.
		my $HostPattern;
		# Split the pattern off of the rest of the line.
		($HostPattern,$Rest) = split('\s+',$Rest,2);
		# Return nothing if we don't match.
		eval "('$HostName' =~ $HostPattern);";
		my $Match = $?;
		# Report any pattern errors.
		if ($@) {
			warn qq"$FileName:$StartLine: Unable to evaluate $HostPattern: $@\n";
			return 0;
		}
		if ($Match) {
			# Now process the rest of the line normally.
			return ProcessServiceLine($FileName, $StartLine, $ArrayRef, $MapRef, $Rest);
		}
		else {
			return 0;  # Not for this host.
		}
	}

	# Is there an "ifcmd" prefix to this test.
	if ($Keyword eq 'ifcmd') {
		# Ifcmd "cmd" selection statement.
		my($Command, $Negate);
		# Split the pattern off of the rest of the line.
		($Command,$Rest) = split(/\s+/,$Rest,2);
		$Command =~ s/^(["'])(.*)\1$/$2/;	# Strip quotes.
		if ($Command =~ /^!(.*)$/) {
			$Negate = 1;
			$Command =~ $1;
		}
		else {
			$Negate = 0;
		}
		# Run command.
		my $Status = (system($Command) ne 0);
		if ($Status eq $Negate) {
			return ProcessServiceLine($FileName, $StartLine, $ArrayRef, $MapRef, $Rest);
		}
		else {
			return 0;  # Not for this host.
		}
	}
		
	if ($Keyword eq 'include') {
		# Include file.
		$Rest =~ s/^(["'])(.*)\1$/$2/;	# Strip quotes.
		LoadServiceList($Rest,$ArrayRef,$MapRef);
		return 0;
	}

	# Must be a check type.  Load it if it isn't already loaded.
	if (!exists($INC{"CheckAll/$Keyword.pm"})) {
	#		eval("use CheckAll::$Keyword;");
		eval qq[require "CheckAll/$Keyword.pm"];
		if ($@) {
			warn qq[$FileName:$StartLine: Unable to include a "$Keyword" module: $@\n];
			return 1;
		}
	}

	# Create this object and put it in @ItemList.
	my $Item;
	eval {
		$Item = $Keyword->new (
			"$FileName",	# For object error msgs.
			"$StartLine",	# For object error msgs.
			$Rest);		# Other parameters.
	};
	if ($@) {
		warn qq[$FileName:$StartLine: Unable to create a "$Keyword" item: $@\n];
		return 2;	
	}
	else {
		# Set the unique name if it isn't already set.
		$Item->Name(ref($Item) . "=" . $Item->Host . "=" . $Item->Target) unless ($Item->Name);

		# Map the name to this item.
		$MapRef->{$Item->Name} = $Item;
		push @$ArrayRef,$Item;
		return 0;
	}
}



sub LoadPriorStatuses {

	my($StatusFile,$MapRef,$OtherRef) = @_;

	# Load table of items that have already been reported failing.
	my $STATUS;
	if (-f $StatusFile) {
		if (sysopen($STATUS,$StatusFile,O_RDONLY)) {
			# Load up any items that were previously failing.
			while (<$STATUS>) {
				next unless
					(/^Name=(.*), FailAt=(\d+)=\S+ \S+, FirstNotify=(\d+)=\S+ \S+, NextNotify=(\d+)=\S+ \S+, LastCheck=(\d+)=\S+ \S+,?/);
				my($Name,$FirstFail,$FirstNotify,$NextNotify,$LastCheck)=($1,$2,$3,$4,$5);
				if(exists($MapRef->{$Name})) {
					$MapRef->{$Name}->{FirstFail} = $FirstFail;
					$MapRef->{$Name}->{FirstNotification} = $FirstNotify;
					$MapRef->{$Name}->{NextNotification} = $NextNotify;
					$MapRef->{$Name}->{PriorStatus} = 8;	# Must be down or it wouldn't be listed here.
				}
				elsif ((time()-$LastCheck)/86400 <= 60) {
					# Not one of ours.  Must come from another config file.  Just 
					# store it to write back later.
					push @$OtherRef,$_;
				}
				else {
					# Nobody has checked this one for 60 days.  Forget it.
				}
			}
			close $STATUS;
		}
		else {
			warn "Unable to open $StatusFile: $!\n";
		}
	}
}




sub WriteStatusFile {

	my($StartTime,$StatusFile,$ArrayRef,$OtherRef) = @_;
	my $STATUS;
	if (open ($STATUS,"> $StatusFile")) {
		foreach my $Item (@$ArrayRef) {
			next if ($Item->Status eq 0);		# Skip OK services.
			next if (ref $Item eq 'history');	# We don't track history lines.
			printf $STATUS "Name=%s, FailAt=%d=%s, FirstNotify=%d=%s, NextNotify=%d=%s, LastCheck=%d=%s, File=%s:%d\n",
				$Item->Name,
				$Item->FirstFail,
				strftime("%D %T",localtime($Item->FirstFail)),
				$Item->FirstNotification,
				strftime("%D %T",localtime($Item->FirstNotification)),
				$Item->NextNotification,
				strftime("%D %T",localtime($Item->NextNotification)),
				$StartTime,
				strftime("%D %T",localtime($StartTime)),
				$Item->{FILE},
				$Item->{LINE}
			;
		}
		# Write out stuff we found in the status file that weren't ours.
		foreach (@$OtherRef) {
			print $STATUS $_;
		}
		close $STATUS;
	}
	else {
		warn("Unable to update $StatusFile: $!\n");
	}
}
=pod

=head1 checkall -- check on services

=head2 Overview

checkall checks critical services to make sure they're running.  It can optionally 
take action when a service fails or recovers, and/or send out notifications.

=head2 Command format:

   checkall [options] [listname ...]
   
=head2 Return codes:

=over 3

=item 0

All services are up.

=item 4

Some services are down, but none have reached their "DelayNotification" delay yet,
so no alerts have gone out.

=item 8

One or more services are down.  Alerts have gone out if requested.

=back

=head2 Command options:

=over 3

=item -c file

Service file -- normally the service to monitor are determined by reading files
from /usr/local/etc/checkall.list (default) or /usr/local/etc/checkall.I<listname>
if one or more list names are provided on the command line.  The -c option provides an
alternate way of identifying a service file, when the desired file isn't named according
to the "listname" standard (i.e. isn't located in /usr/local/etc).

=item --fail, --failed

Fail -- only list failing items.

=item -h, --help

Help -- print this documentation

=item -P address, --page=address

Page -- send a message to this e-mail address whenever services transition from OK
to failing or vice versa, or if enough time has elapsed to warrant renotification.
This option may be repeated to send e-mails to multiple addresses.

=item -q, --quiet

Quiet -- suppress status messages.

=item -R minutes, --renotify=minutes

Renotify -- send out another page if a service has been failing for this many minutes
since the last page.  Default is 120 (2 hours).

=item -s subject, --subject=subject

Subject -- use this subject line when sending out pages.  The following substitutions 
are made:
	"%C" is replaced with the host Computer name.
	"%N" is replaced with the Number of services down.
	"%S" is replaced with an English status phrase (e.g. "All services restored").

=item -S, --single

Single -- run tests one at a time rather than in parallel.  This is primarily
used as a debugging aid.

=item -v, --verbose

Verbose -- turn on diagnostics.

=item -w seconds, --waittime=seconds

Wait Time -- Wait up to "seconds" seconds for individual checks to complete.  Some checks
(primarily network checks) support time-out values.  Other checks ignore this value.

The effective value for any given check is the larger of this value or a waittime value specified in the check definition.  The default value is 20 seconds.

=back

=head2 Service List Files

checkall determines what services to monitor by using service list files.  The default
service list is "/usr/local/etc/checkall.list".  Alternate or additional lists can be
saved as "/usr/local/etc/checkall.I<name>", where "name" matches the name specified on the
command line (e.g. /usr/local/etc/checkall.urgent would be referenced by "checkall urgent").
Service lists that don't follow this naming convention can be specified using the -c option.

Service list files are formatted according to the following rules:

=over 3

=item *

Blank lines and lines starting with # are ignored

=item *

Lines beginning with white space are treated as continuation lines.

=item *

A service list file may include another service list file using the "include" directive as follows:

   include path-to-file

=item *

All other lines designate services to check.  The general format of a service line is:

   checktype parameters

"checktype" refers to a Perl check module called "CheckAll::I<checktype>".  This module will be 
loaded if necessary, and passed the parameters provided.  Most modules require at least a
Target= parameter and a Desc= parameter.  See the documentation in CheckAll::CheckItem for common
parameters, and other modules in the CheckAll:: tree for kinds of checks and specific parameters.

The most common checks are "tcpport", which checks for connectivity to a TCP socket, and "process", which
checks the process table for a running process.  "heading" is also used to insert headings.
=back

=cut

