#! /usr/bin/perl

use strict;
no strict 'refs';
use warnings;
use Getopt::Long qw(:config bundling no_auto_abbrev gnu_compat no_ignore_case);
use Sys::Syslog;
use IO::Select;
use IO::Socket;
use File::Temp qw(tempfile);
use POSIX qw(strftime :sys_wait_h);
use Fcntl;
use FindBin qw($Bin $Script);
use Text::ParseWords;

my $HIGHLIGHT = "\e[33;40;1m";	# Yellow FG, Black BG, Bright.
my $RESET = "\e[0m";

# Set a path, particularly for OnOK/OnFail actions.
$ENV{PATH}="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$ENV{PATH}";

our $opt_c='';			# Service file (service list).
our $opt_f='';			# Service file (service list).
our $opt_h=0;			# Help
our $opt_v=0;			# Verbose option.
our $opt_t=0;			# Test option.
our $opt_q=0;			# Quiet option.
our @opt_P;			# Who to page on errors.
our $opt_R=120;			# Set number of minutes to re-report fail items.
our $opt_s='';			# Alert subject
our $opt_S=0;			# Single - only run one process at a time (for diagnostics).
our $opt_w=20;			# Wait time in seconds (for checks that timeout)
our $Prog = $Script;		# Get our program name.
$Prog=~s/\.pl$|\.bat$//;       	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";		# Trim off path, if present.
my @ItemList;			# List of item objects to check.
my @NowFail;			# Newly failing items.
my @NowOK;			# Newly OK items.
my @StillFail;			# On-going fail items.
my %FailItems;			# List of items previously failing.
my @OtherItems;			# Stuff in the status file from other check lists.
my @ConfigFiles = (		# List of configuration files.
	'/usr/local/etc/checkall.cfg',
	"$ENV{HOME}/.checkallrc",
);

$| = 1;				# Unbuffer output.
our $StartTime = time();

my $StatusFile="$ENV{HOME}/.$Prog.dat";
my $ServiceList="/usr/local/etc/$Prog.list";

our $HostName = `hostname`;
chomp $HostName;

# Load the config file.
my %Config;
foreach my $FileName (@ConfigFiles) {
#	my @Data = ReadFile($FileName);
	foreach (ReadFile($FileName)) {
		next unless ($_);	# Sparse array has blank entries.
                my ($name,$settings)=/^\s*(\S+):\s*(.+)/;
		$settings = '' unless ($settings);	# Suppress undef errors.
                $name=~tr/[a-z]/[A-Z]/;
                if ($Config{$name}) {
			$Config{$name}=$Config{$name} . ' ' . $settings;
		}
		else {
			$Config{$name}=$settings;
		}
        }
}

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
        if (defined($Config{'ALLJOBS'}));

GetOptions (
	'v|verbose+'	=> \$opt_v,
	'c|config=s'	=> \$opt_c,
	'a|all'		=> sub {$opt_f = 0;},	# Synonym for --nofail
	'fail|failed!'	=> \$opt_f,
	'h|help'	=> \$opt_h,
	'L|libdir=s'	=> sub{ unshift @INC, glob($_[1]); },
	't|test'	=> \$opt_t,
	'q|quiet'	=> \$opt_q,
	'P|page=s'	=> \@opt_P,
	'R|renotify=i'	=> \$opt_R,
	's|subject=s'	=> \$opt_s,
	'S|single!'	=> \$opt_S,
	'w|waittime=i'	=> \$opt_w,
);

eval "use CheckAll::CheckItem;"; # Do this late, to benefit from -L.

# Check options.
if ($opt_h) {
	system("pod2text $Bin/$Script");
	exit 1;
}

openlog("$Prog");


my $FailMessages;
if ($opt_q) {
	# Prepare the Fail-Message header text.
	my($Minutes,$Hours)=(localtime())[1,2];
	$Minutes="0$Minutes" if ($Minutes <= 9);
	$FailMessages="The following services have failed at 
$Hours:$Minutes...";
}

my $errors=0;
my %PIDs;		# Map PID to @ItemList.
my %NameMap;		# Maps status names to @ItemList.
my $IOList;		# IO::Select item, to be used if needed.

# Prepare the list of files to process.
foreach (@ARGV) {
	# Add a path and file name prefix to unqualified names.
	s"^"/usr/local/etc/$Prog." unless (m"/");
}
push @ARGV,$opt_c if ($opt_c);	# Use opt_c for files in other locations.
push @ARGV,$ServiceList unless (@ARGV+0 > 0);	# Use default if nothing else.
foreach (@ARGV) {
	LoadServiceList($_,\@ItemList,\%NameMap);	# Load this file.
}

if (@ItemList+0 == 0) {
	# Nothing to monitor.
	warn 'No services found in ' . join(', ',@ARGV) . ' to monitor.';
	push @NowFail,"No services found to monitor";
}

# Load any prior statuses.
LoadPriorStatuses($StatusFile, \%NameMap, \@OtherItems);

# Go check all these services.
my $Services = @ItemList + 0;
my $DescLen = 0;		# Will keep length of longest desc here.
foreach my $Item (@ItemList) {
	print "Checking $Item->{FILE}:$Item->{LINE}: $Item->{Desc}\n"
		if ($opt_v);
	my $CheckResult = Check $Item;
	my ($Type,$Value);
	if (ref($CheckResult) eq 'ARRAY') {
		$Type=$CheckResult->[0];
	}
	else {
		($Type,$Value) = ($CheckResult =~ m/^(\S+)=(\S+)$/);
	}
	
	if ($Type eq 'Status') {		# 5.8 doesn't have switch.
		# This one returned a status immediately.
		$Item->Status($Value);
		$Services--;			# Not waiting on this one.
	}
	elsif ($Type eq 'FHList') {
		# This one is running in the background, and the answer will come via pipe.
		my($pid,$FH) = @{$CheckResult}[1..2];
		if (!$IOList) {
			# First one.  Create the IO::Select item.
			$IOList = IO::Select->new() || die "Unable to create IO::Select item";
		}
		$PIDs{$pid} = $Item;
		$IOList->add($FH) || warn "Handle add failed: $!";
	}
	else	{
		# Somebody sent back a response we don't understand.
		die qq[Unexpected response "$CheckResult" from $Item->{'Desc'}];
	}

	# Track the length of our longest description for formatting purposes, but ignore headings.
	if (ref $Item ne 'heading') {
		my $Len = length($Item->{Desc});
		$DescLen = $Len if ($DescLen < $Len);
	}
	
}

# All background processes submitted.  Wait for the results to come in.
my($pid,$status,$detail);
`tty -s`;	# Find out if we have a tty.
my $no_tty = $?;
if ($Services) {
	# Wait for any PIDs that return status detail via pipes.
	my @Ready;
	while ($IOList and @Ready = $IOList->can_read($opt_w)) {
		foreach my $FH (@Ready) {
			($pid,$status,$detail) = split('/',<$FH>,3);
			$IOList->remove($FH);
			close $FH;
			$PIDs{$pid}->Status($status);
			$PIDs{$pid}->StatusDetail($detail);
		}
	}
	# Wipe out waiting message.
	print ' 'x40 . "\r" unless ($no_tty or  $opt_q);
}

# All results are in.  Run back through our report and list the results.
my $Errors = 0;
my $WorstError = 0;		# Set to 4 for delayed notification, 8 for full failure.
my $Renotify = 0;		# Set to 1 if no changes but some service is due for renotification.
$DescLen += 2;			# Add two blanks for padding.
my $Now = time();		# Avoid repeated calls.
foreach my $Item (@ItemList) {
	# Call report to issue visible status, and count failures.
	my $Desc = $Item->Desc;
	my $LongDesc;
	if ($Item->{StatusDetail}) {
		$LongDesc = "$Desc (" . $Item->{StatusDetail} . ")";
	}
	else {
		$LongDesc = $Desc;
	}
	my $Status = $Item->Report($DescLen,$opt_f);
	my $DoDownActions = 0;
	if ($Status == 0 or $Status == 4) {
		#
		# CHECK_STILL_OK -- Item is still up.
		# CHECK_NOT_TESTED -- Not tested due to time restrictions.
		#
		# syslog('INFO','%s is still OK',$Desc)  - don't fill log with "still OK".
	 	#	if (ref $Item ne 'heading' and $^O !~ /MSWin/);
	}	
	elsif ($Status == 1) {
		#
		# CHECK_STILL_DOWN -- Item is still down.
		#
		$Errors++;
		#syslog('WARNING','%s',"$Desc is still failing")
		#	if ($^O !~ /MSWin/);
		if ($Now >= $Item->NextNotification) {
			$Renotify++;
			$WorstError = 8;
			$Item->NextNotification(
				$Now +
				60*(defined($Item->Renotifyinterval)?$Item->Renotifyinterval:$opt_R)
			);
			if ($Item->FirstNotification == 0) {
				# This was a DelayFirstNotification target, that has remained down through the delay period.
				# Essentially, it's a firstfail as far as notifications are concerned.
				$DoDownActions = 1;
				$Item->FirstNotification($Now);
			}
			elsif ($opt_R) {
				# We sent out notifications before, but it's time for another one.
				push @StillFail, $LongDesc;
			}
		}
		if ($Item->FirstNotification == 0) {
			# We have a service down with a delay notification that hasn't notified yet.
			$WorstError = 4 if ($WorstError < 4);
		}
		else {
			# A service is down.
			$WorstError = 8;
		}
	}
	elsif ($Status == 2) {
		#
		# CHECK_NOW_OK -- Item is back up.
		#
		#syslog('INFO','%s', "$Desc is NOW OK")
		#	if ($^O !~ /MSWin/);
		next if ($Item->FirstNotification == 0);	# Recovered within DelayFirstNotification period.
		push @NowOK, $Desc;
		if (my $Action = $Item->Onok) {
			if ($opt_t) {
				print "\t\tTesting: OnOK for $Desc suppressed.\n";
			}
			else {
				print "Triggering OnOK for $Desc\n" if ($opt_v);
				$Action =~ s/%D/$Desc/g;
				system("($Action)&");
				my $Status = $?;
				syslog(($Status?'WARNING':'INFO'),'%s',"Executed OnOK actions for $Desc.  Status $Status.")
					if ($^O !~ /MSWin/);
			}
		}
	}
	elsif ($Status == 3) {
		#
		# CHECK_NOW_DOWN -- Item has gone down.
		#
		$Item->FirstFail($StartTime);	# Remember when it failed.
		$Errors++;
		
		# Delay errors on first notification if DelayFirstNotification time specified.
		if ($Item->Delayfirstnotification) {
			#
			# Delaying notifications.
			syslog('INFO','%s', "$Desc notification delayed per config")
				if ($^O !~ /MSWin/);
			$Item->FirstNotification(0);
			$Item->NextNotification($Now + 60*$Item->Delayfirstnotification);
			$WorstError = 4 if ($WorstError == 0);
			next;
		}
		else {
			#
			# Not delaying notifications.
			#syslog('WARNING','%s', "$Desc is NOW FAILING")
			#	if ($^O !~ /MSWin/);
			$DoDownActions = 1;
			$Item->FirstNotification($Now);
			$WorstError = 8;
		}
	}
	else {
		die "$Item->{FILE}:$Item->{LINE} Unexpected status $Status returned.";
	}

	# Common code for "Now Down and no delay notification" or "Still down and delay time expired"
	if ($DoDownActions) {
		push @NowFail, $LongDesc;
		if (my $Action = $Item->Onfail) {
			if ($opt_t) {
				print "\t\tTesting: OnFail action for $Desc suppressed.\n";
			}
			else {
				print "Triggering OnFail for $Desc\n" if ($opt_v);
				$Action =~ s/%D/$Desc/g;
				system("($Action)&");
				my $Status = $?;
				syslog(($Status?'WARNING':'INFO'),'%s',"Executed OnFail actions for $Desc.  Status $Status.")
					if ($^O !~ /MSWin/);
			}
		}
		$Item->NextNotification(
			$Now +
				60*(defined($Item->Renotifyinterval)?$Item->Renotifyinterval:$opt_R)
		);
	}
}

if (@NowFail+@NowOK+$Renotify > 0 and @opt_P > 0 and ! $opt_t) {
	# Set up the e-mail subject.
	my $TotalDown = @NowFail + @StillFail;
	my $Status;
	if ($TotalDown) {
		$Status = "$TotalDown service" . ($TotalDown > 1?'s':'') . " down";	# Something is down.
	}
	elsif (@NowOK) {
		$Status = 'All services restored';	# Was down, but all up now.
	}
	else {
		$Status = 'All services up';		# Never was down (shouldn't happen).
	}
	$opt_s = '%C alert: %S' unless ($opt_s);
	$opt_s =~ s/%C/$HostName/g;
	$opt_s =~ s/%N/$TotalDown/g;
	$opt_s =~ s/%S/$Status/g;

	# Build the e-mail text.	
	my($MAIL,$MailFile) = tempfile();
	my $ToList=join(', ',@opt_P);
	print $MAIL <<ENDHeaders;
X-Jobsummary: Name=checkall Status=8 RunTime=0:0:0:20
To: $ToList
Subject: $opt_s

ENDHeaders
	
	if (@NowFail) {
		print $MAIL "Now failing: " . join(', ',@NowFail) . "\n";
	}
	if (@StillFail) {
		print $MAIL "Still failing: " . join(', ',@StillFail) . "\n";
	}
	if (@NowOK) {
		print $MAIL "Now OK: " . join(', ',@NowOK) . "\n";
	}

	# Send the e-mail.
	printf $MAIL strftime("\nFrom $HostName at %T on %D\n",localtime());
	close $MAIL;
	if (my $Status = system("sed 's/  */ /g' $MailFile | sendmail " . join(' ',@opt_P))) {
		syslog('ERROR','%s','Unable to send notifications. RC=$Status, Error=$!')
			if ($^O !~ /MSWin/);
	}
	else {
		syslog('INFO','%s','Notifications sent.') if ($^O !~ /MSWin/);
	}
	unlink $MailFile;
}

# Write the status file, so we know "still failing" from "now failing".
WriteStatusFile($StartTime,$StatusFile,\@ItemList,\@OtherItems) unless ($opt_t);

if ($Errors > 0) {
	printf "%s==> %d " . ($Errors == 1?'service is':'services are') . " failing.%s\n",
		$HIGHLIGHT, $Errors, $RESET
		unless ($opt_q);
	exit $WorstError;
}
else {
	print "All services are OK.\n" unless ($opt_q);
	syslog('INFO','All services are OK.')
		if ($^O !~ /MSWin/);
	exit 0;
}




#
# LoadServiceList - load a list of services.
#
sub LoadServiceList {
	my($FileName,$ArrayRef,$MapRef,@Vars) = @_;
	# Prepare @Vars.
	my %Vars;
	foreach (@Vars) {
		my($Var,$Value) = split('=',$_,2);
		$Value =~ s/^(['"])(.*)\1$/$2/; # Strip quotes.
		$Vars{$Var}=$Value;
	}
	my @Data = ReadFile($FileName);
	print "Processing $FileName ($#Data items found)...\n"
		if ($opt_v);
	foreach my $Index (0..$#Data) {
		ProcessServiceLine($FileName, $Index, $ArrayRef, $MapRef, $Data[$Index], %Vars);	
	}
}



#
# ProcessServiceLine : process one logical line from a service file.
#
sub ProcessServiceLine {
	my($FileName, $StartLine, $ArrayRef, $MapRef, $Line, %Vars) = @_;
	return if (!defined($Line) or $Line =~ /^\s*$/);		# Skip empty lines.
	print "	Processing line $StartLine: $Line\n" if ($opt_v >= 3);

	my($Keyword,$Rest) = split('\s+',$Line,2);
	$Keyword = lc($Keyword);				# Ignore case.
	
	# Substitute variables
	foreach my $Name (keys(%Vars)) {
		$Rest=~s/$Name/$Vars{$Name}/g;
	}

	# Is there an "ifhost" prefix to this test?
##### ifhost and ifcmd need quote processing on the second argument only.
	if ($Keyword eq 'ifhost') {
		# Ifhost /pattern/ selection statement.
		my $HostPattern;
		# Split the pattern off of the rest of the line.
		($HostPattern,$Rest) = split('\s+',$Rest,2);
		# Return nothing if we don't match.
		eval "('$HostName' =~ $HostPattern);";
		my $Match = $?;
		# Report any pattern errors.
		if ($@) {
			warn qq"$FileName:$StartLine: Unable to evaluate $HostPattern: $@\n";
			return 0;
		}
		if ($Match) {
			# Now process the rest of the line normally.
			return ProcessServiceLine($FileName, $StartLine, $ArrayRef, $MapRef, $Rest);
		}
		else {
			return 0;  # Not for this host.
		}
	}

	# Is there an "ifcmd" prefix to this test.
	if ($Keyword eq 'ifcmd') {
		# Ifcmd "cmd" selection statement.
		my($Command, $Negate);
		# Split the pattern off of the rest of the line.
		($Command,$Rest) = split(/\s+/,$Rest,2);
		$Command =~ s/^(["'])(.*)\1$/$2/;	# Strip quotes.
		if ($Command =~ /^!(.*)$/) {
			$Negate = 1;
			$Command =~ $1;
		}
		else {
			$Negate = 0;
		}
		# Run command.
		my $Status = (system($Command) ne 0);
		if ($Status eq $Negate) {
			return ProcessServiceLine($FileName, $StartLine, $ArrayRef, $MapRef, $Rest);
		}
		else {
			return 0;  # Not for this host.
		}
	}
		
	if ($Keyword eq 'include') {
		# Include file.
		my @Vars = parse_line('\s+',0,$Rest);
		my $FileName = shift(@Vars);
		$FileName =~ s/^(["'])(.*)\1$/$2/;	# Strip quotes.
		LoadServiceList($FileName,$ArrayRef,$MapRef,@Vars);
		return 0;
	}

	# Must be a check type.  Load it if it isn't already loaded.
	if (!exists($INC{"CheckAll/$Keyword.pm"})) {
		eval qq[require "CheckAll/$Keyword.pm"];
		if ($@) {
			warn qq[$FileName:$StartLine: Unable to include a "$Keyword" module: $@\n\@INC = ] 
				. join("\n\t",@INC) . "\n";
			return 1;
		}
	}

	# Create this object and put it in @ItemList.
	my $Item;
	eval {
		$Item = $Keyword->new (
			"$FileName",	# For object error msgs.
			"$StartLine",	# For object error msgs.
			$Rest);		# Other parameters.
	};
	if ($@) {
		warn qq[$FileName:$StartLine: Unable to create a "$Keyword" item: $@\n];
		return 2;	
	}
	else {
		# Interpret variables in Desc.
		if ($Item->{Desc} =~ /%C/) {
			if ($Item->{Host} and $Item->{Host} ne 'localhost') {
				$Item->{Desc} =~ s/%C/$Item->{Host}/g;
			}
			else {
				$Item->{Desc} =~ s/%C/$HostName/g;
			}
		}
		# Set the unique name if it isn't already set.
		$Item->Name(ref($Item) . "=" . ($Item->Host?$Item->Host:'localhost') . "=" . ($Item->Target?$Item->Target:'no-target')) unless (defined($Item->Name) and $Item->Name);

		# Map the name to this item.
		$MapRef->{$Item->Name} = $Item;
		push @$ArrayRef,$Item;
		return 0;
	}
}



sub LoadPriorStatuses {

	my($StatusFile,$MapRef,$OtherRef) = @_;

	# Load table of items that have already been reported failing.
	my $STATUS;
	if (-f $StatusFile) {
		if (sysopen($STATUS,$StatusFile,O_RDONLY)) {
			# Load up any items that were previously failing.
			while (<$STATUS>) {
				next unless
					(/^Name=(.*), FailAt=(\d+)=\S+ \S+, FirstNotify=(\d+)=\S+ \S+, NextNotify=(\d+)=\S+ \S+, LastCheck=(\d+)=\S+ \S+,?/);
				my($Name,$FirstFail,$FirstNotify,$NextNotify,$LastCheck)=($1,$2,$3,$4,$5);
				if(exists($MapRef->{$Name})) {
					$MapRef->{$Name}->{FirstFail} = $FirstFail;
					$MapRef->{$Name}->{FirstNotification} = $FirstNotify;
					$MapRef->{$Name}->{NextNotification} = $NextNotify;
					$MapRef->{$Name}->{PriorStatus} = 8;	# Must be down or it wouldn't be listed here.
				}
				elsif ((time()-$LastCheck)/86400 <= 60) {
					# Not one of ours.  Must come from another config file.  Just 
					# store it to write back later.
					push @$OtherRef,$_;
				}
				else {
					# Nobody has checked this one for 60 days.  Forget it.
				}
			}
			close $STATUS;
		}
		else {
			warn "Unable to open $StatusFile: $!\n";
		}
	}
}




sub WriteStatusFile {

	my($StartTime,$StatusFile,$ArrayRef,$OtherRef) = @_;
	my $STATUS;
	if (open ($STATUS,"> $StatusFile")) {
		foreach my $Item (@$ArrayRef) {
			next if ($Item->Status == 0 or $Item->Status == 4);	# Skip OK services.
			next if (ref $Item eq 'history');	# We don't track history lines.
			printf $STATUS "Name=%s, FailAt=%d=%s, FirstNotify=%d=%s, NextNotify=%d=%s, LastCheck=%d=%s, File=%s:%d\n",
				$Item->Name,
				$Item->FirstFail,
				strftime("%D %T",localtime($Item->FirstFail)),
				$Item->FirstNotification,
				strftime("%D %T",localtime($Item->FirstNotification)),
				$Item->NextNotification,
				strftime("%D %T",localtime($Item->NextNotification)),
				$StartTime,
				strftime("%D %T",localtime($StartTime)),
				$Item->{FILE},
				$Item->{LINE}
			;
		}
		# Write out stuff we found in the status file that weren't ours.
		foreach (@$OtherRef) {
			print $STATUS $_;
		}
		close $STATUS;
	}
	else {
		warn("Unable to update $StatusFile: $!\n");
	}
}


sub ReadFile {

	my $FileName = shift;
	my @Data;
	my $FH;
	
	return @Data unless (-f $FileName);	# File doesn't exist.  Return empty array.

	# Go process the file.
	if (sysopen($FH,$FileName,O_RDONLY)) {
		# Read the file, joining multi-line entries into one.
		my $LineInProgress = '';
		my $CompleteLine = '';
		my $StartLine;
		my $LineNum = 0;
		while (<$FH>) {
			$LineNum++;
			next if (/^\s*#/);			# Skip comments.
			next if (/^\s*$/);			# Skip blank lines.
			chomp;
			s/\s+$//;				# Strip trailing blanks.

			# Is this a continuation line (starts with white space)?
			if (/^\s+/) {
				# Yes.  Append it to any prior data.
				s/^\s+//;
				$LineInProgress .= " $_";	# Append to prior data.
			}
			else {
				# This is the beginning of a new line.  Store the old line if we have one.
				$Data[$StartLine] = $LineInProgress if ($LineInProgress);
				$LineInProgress = $_;
				$StartLine = $LineNum;
			}
		}
		# Process the last line if we have one.
		$Data[$StartLine] = $LineInProgress if ($LineInProgress);
		close $FH;
	}
	else {
		warn "Unable to open $FileName: $!";
	}
	
	return @Data;
}
=pod

=head1 checkall -- check on services

=head2 Overview

checkall checks critical services to make sure they're running.  It can optionally 
take action when a service fails or recovers, and/or send out notifications.

=head2 Command format:

   checkall [options] [listname ...]
   
=head2 Return codes:

=over 3

=item 0

All services are up.

=item 4

Some services are down, but none have reached their "DelayNotification" delay yet,
so no alerts have gone out.

=item 8

One or more services are down.  Alerts have gone out if requested.

=back

=head2 Command options:

=over 3

=item -c file

Service file -- normally the service to monitor are determined by reading files
from /usr/local/etc/checkall.list (default) or /usr/local/etc/checkall.I<listname>
if one or more list names are provided on the command line.  The -c option provides an
alternate way of identifying a service file, when the desired file isn't named according
to the "listname" standard (i.e. isn't located in /usr/local/etc).

=item --fail, --failed

Fail -- only list failing items.

=item --all, --nofail, --nofailed

All -- override prior --fail/--failed.  This is used primarily on the command
line to override a --fail or --failed in the .cfg file.

=item -h, --help

Help -- print this documentation

=item -L path, --libdir=path

Lib -- add this path when looking for Perl modules to include.

=item -P address, --page=address

Page -- send a message to this e-mail address whenever services transition from OK
to failing or vice versa, or if enough time has elapsed to warrant renotification.
This option may be repeated to send e-mails to multiple addresses.

=item -q, --quiet

Quiet -- suppress status messages.

=item -R minutes, --renotify=minutes

Renotify -- send out another page if a service has been failing for this many minutes
since the last page.  Default is 120 (2 hours).

=item -s subject, --subject=subject

Subject -- use this subject line when sending out pages.  The following substitutions 
are made:
	"%C" is replaced with the host Computer name.
	"%N" is replaced with the Number of services down.
	"%S" is replaced with an English status phrase (e.g. "All services restored").

=item -S, --single

Single -- run tests one at a time rather than in parallel.  This is primarily
used as a diagnostic aid.

=item -t, --test

Test -- run normal checks, but suppress any OnOK or OnFail actions, and don't
send out any e-mail alerts.

=item -v, --verbose

Verbose -- turn on diagnostics.

=item -w seconds, --waittime=seconds

Wait Time -- Wait up to "seconds" seconds for individual checks to complete.  Some checks
(primarily network checks) support time-out values.  Other checks ignore this value.

The effective value for any given check is the larger of this value or a waittime value specified in the check definition.  The default value is 20 seconds.

=back

=head2 Configuration File

Options may also be specified in an optional configuration file named /usr/local/etc/checkall.cfg.
The file format is "Alljobs:" starting in column 1, followed optionally by white space,
followed by a list of command line options.  For example:

  Alljobs: -L /usr/mcsi-linux/lib/perl5/site-perl --waittime=30 --failed

Lines beginning with white space are continuation lines.  For example:

  Alljobs: -L /usr/mcsi-linux/lib/perl5/site-perl
           --waittime=30
           --failed

Blank lines and lines beginning with # are ignored.

=head2 Service List Files

checkall determines what services to monitor by using service list files.  The default
service list is "/usr/local/etc/checkall.list".  Alternate or additional lists can be
saved as "/usr/local/etc/checkall.I<name>", where "name" matches the name specified on the
command line (e.g. /usr/local/etc/checkall.urgent would be referenced by "checkall urgent").
Service lists that don't follow this naming convention can be specified using the -c option.

Service list files are formatted according to the following rules:

=over 3

=item *

Blank lines and lines starting with # are ignored

=item *

Lines beginning with white space are treated as continuation lines.

=item *

A service list file may include another service list file using the "include" directive as follows:

   include path-to-file [var=value ...]

if var=value pairs are specified, the included file will have all occurrances of "var" replaced
with "value", allowing a single file to be included multiple times with different values.  For
example:

  checkall.list contains:
	include /usr/local/etc/checkall.checkserver %HOST=ben %FUNCTION="web server"
	include /usr/local/etc/checkall.checkserver %HOST=sandy %FUNCTION="mail server"

  checkall.checkserver contains:
        heading %HOST: %FUNCTION
	tcpport  Target=%HOST:22 Desc="%HOST %FUNCTION ssh port"

=item *

All other lines designate services to check.  The general format of a service line is:

   checktype parameters

"checktype" refers to a Perl check module called "CheckAll::I<checktype>".  This module will be 
loaded if necessary, and passed the parameters provided.  Most modules require at least a
Target= parameter and a Desc= parameter.  See the documentation in CheckAll::CheckItem for common
parameters, and other modules in the CheckAll:: tree for kinds of checks and specific parameters.

The most common checks are "tcpport", which checks for connectivity to a TCP socket, and "process", which
checks the process table for a running process.  "heading" is also used to insert headings.
=back

=cut

