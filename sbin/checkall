#! /usr/bin/perl

use strict;
use warnings;
use Sys::Syslog;
use Getopt::Std;
use IO::Socket;
use File::Temp qw(tempfile);
use POSIX qw(strftime);
use Fcntl;

my $HIGHLIGHT = "\e[33;40m";
my $RESET = "\e[0m";

our $opt_v=0;		# Verbose option.
our $opt_t=0;		# Test option.
our $opt_q=0;		# Quiet option.
our $opt_P='';		# Who to page on errors.
our $opt_s='';		# Alert subject

my @NowDown;		# Newly down items.
my @NowUp;		# Newly up items.
my @StillDown;		# On-going down items.
my %DownItems;		# List of items previously down.

my $StatusFile="$ENV{HOME}/.checkall.dat";
my $ServiceList="/usr/local/etc/checkall.list";
my $RepeatThreshold=2;		# Set number of hours to re-report down items.

my $HostName = `hostname`;
chomp $HostName;

getopts('qv:P:s:');

if (!$opt_s) {
	$opt_s = "$HostName alert";
}

openlog("checkall");

# Load table of items that have already been reported down.
if (-f $StatusFile) {
	if (sysopen(STATUS,$StatusFile,O_RDONLY)) {
		# Load up any items that were previously down.
		while (<STATUS>) {
			my($Time,undef,$Desc)=split(/\s+/,$_,3);
	    		$Desc=~s/^\s*(.*)\s*$/$1/;
			if ($Time + $RepeatThreshold*60*60 > time()) {
				$DownItems{$Desc}=$Time;
			}
		}
		close STATUS;
	}
	else {
		warn "Unable to open $StatusFile: $!\n";
	}
}

my $DownMessages;
if ($opt_q) {
	# Prepare the Down-Message header text.
	my($Minutes,$Hours)=(localtime())[1,2];
	$Minutes="0$Minutes" if ($Minutes <= 9);
	$DownMessages="The following services were detected down at 
$Hours:$Minutes...";
}

my $errors=0;
my $FH;
my @Lines;		# Input file line (minus comments).
my @Statuses;		# Parallel array for @Lines. 1 = up, 0 = down.
my %PIDs;		# Map PID to @Lines/@Statuses index.
my $Services=0;		# Number of services we're checking.

# If they didn't provide a list file, use the default.
push @ARGV,$ServiceList unless (@ARGV+0 > 0);

foreach (@ARGV) {
	# Add a path and file name prefix if they didn't provide a name.
	s"^"/usr/local/etc/checkall." unless (m"/");
	LoadList($_,\@Lines);
}

if (@Lines+0 == 0) {
	# Nothing to monitor.
	warn "No services found in $ServiceList to monitor.";
	push @NowDown,"No services found to monitor";
}

# Create child processes to check each service, so they run in parallel.
for my $index (0..$#Lines) {
	next if ($Lines[$index] =~ /^\s*head(ing|er)[:\s]\s*(.*)\s*$/);	# Ignore headings until we have statuses (stati?).
	$Services++;

	# Spin off a child process to check the status of this item.
	my $pid = fork();
	if ($pid) {
		# We're the parent.  Remember the pid that goes with this line.
		$PIDs{$pid} = $index;
		next;
	}
	else {
		# We're the child.  Go test this service.
		my ($TargetList,$Desc,$DownAction,$UpAction,undef)=split(/#/,$Lines[$index]);	# break out data elements.
		$Desc=~s/^\s*(.*)\s*$/$1/;
		$TargetList=~s/\s//g;
		print "\n$$ Checking $Desc\n" if ($opt_v);
		my $GroupOK=0;
		my $socket;
		foreach (split(/,/,$TargetList)) {
			my($host,$port)=split(/:/);
			# try to connect.
			if ($socket=IO::Socket::INET->new(PeerAddr=>"$host:$port",Timeout=>20)) {
				# Connected OK.
				printf "\t%s:%d OK - %s\n", $host, $port, $Desc if ($opt_v);
				close($socket);
				$GroupOK=1;		# One of this target group worked.
				last;			# Don't need to do any further checking.
			}
			else {
				# Connection is down.
				printf "\t\t%s DOWN: $!\n", $Desc if ($opt_v);
				close($socket) if ($socket);
			}
		}
		exit($GroupOK);		# Tell the parent whether it was up or down.
	}
}

# Parent: all background processes submitted.  Wait for the results to come in.
my $pid;
$| = 1;
do {
	print "Waiting for results on $Services service" . ($Services==1?'':'s') . "   \r";
	$pid = waitpid(-1,0);
	$Statuses[$PIDs{$pid}] = $? if ($pid > 0);
	$Services--;
} while $pid > 0;
print ' 'x30 . "\r";		# Wipe out waiting message.

# All results are in.  Run back through our report and list the results.
for my $index (0..$#Lines) {
	if ($Lines[$index] =~ /^\s*head(ing|er)[:\s]\s*(.*)\s*$/) {
		# Print a heading line.
		printf "%-48.48s --\n",$2;
		next;
	}
	my ($TargetList,$Desc,$DownAction,$UpAction,undef)=split(/#/,$Lines[$index]);	# break out data elements.
	$Desc=~s/^\s*(.*)\s*$/$1/;

	if ($Statuses[$index]) {
		printf "\t%-40.40s OK\n", $Desc if (!$opt_q);
		# Trigger up action if it was down before.
		if ($DownItems{$Desc}) {
			syslog('INFO','%s is now up',$Desc)
				if ($^O !~ /MSWin/);
			if ($UpAction) {
				print "Triggering Up-action for $Desc\n" if ($opt_v);
				$UpAction =~ s/%D/$Desc/g;
				system($UpAction);
			}
			push @NowUp, $Desc;
		}
		else {
			syslog('INFO','%s is still up',$Desc)
				if ($^O !~ /MSWin/);
		}
		delete $DownItems{$Desc};	# No longer down, if it was before.
	}
	elsif ($DownItems{$Desc}) {
		# Connection failed, but we have already reported it.
		syslog('INFO','%s is still down',$Desc);
		printf "\t\t$HIGHLIGHT%s still DOWN$RESET\n", $Desc if (!$opt_q);
		push @StillDown, $Desc;
	}
	else {
		# Connection is newly down.
		syslog('INFO','%s is now down',$Desc);
		if ($opt_q) {
			$DownMessages.="\r\n\t$Desc";
		}
		else {
			printf "\t\t$HIGHLIGHT%-40.40s\tDOWN$RESET\n", $Desc;
		}
		if ($DownAction) {
			print "Triggering down-action for $Desc\n" if ($opt_v);
			$DownAction =~ s/%D/$Desc/g;
			system($DownAction);		# Trigger action.
		}
		$DownItems{$Desc}=time();
		push @NowDown,$Desc;
		$errors=1;
	}
}

if (@NowDown+@NowUp > 0 and $opt_P) {
	my($MAIL,$MailFile) = tempfile();
	
	if (@NowDown) {
		print $MAIL "Now down: " . join(', ',@NowDown) . "\n";
	}
	if (@StillDown) {
		print $MAIL "Still down: " . join(', ',@StillDown) . "\n";
	}
	if (@NowUp) {
		print $MAIL "Now up: " . join(', ',@NowUp) . "\n";
	}
	printf $MAIL strftime("From $HostName at %T on %D\n",localtime());
	close $MAIL;
	system("sed 's/  */ /g' $MailFile | mail -s \"$opt_s\" $opt_P") && warn "Unable to send mail: $!\n";
	unlink $MailFile;
}

# Update list of down items.
if (open (STATUS,"> $StatusFile")) {
	foreach (keys(%DownItems)) {
		my ($sec,$min,$hour)=(localtime($DownItems{$_}))[0..2];
		printf STATUS "%lu %02d:%02d:%02d %s\n",
			$DownItems{$_},$hour,$sec,$min,$_;
	}
	close STATUS;
} else {
	warn("Unable to update $StatusFile: $!\n");
	$errors=1;
}

if (@NowDown+@StillDown > 0) {
	printf "\n$HIGHLIGHT%d services down.$RESET\n",(@NowDown+@StillDown);
	exit 8;
}
else {
	exit 0;
}


#
# LoadList - load a list of services.
#
sub LoadList {
	my($ServiceList,$ArrayRef) = @_;
	return unless (-f $ServiceList);
	if (sysopen($FH,$ServiceList,O_RDONLY)) {
		# Load the service file.
		while (<$FH>) {
			next if (/^\s*#/);			# Skip comments.
			next if (/^\s*$/);			# Skip blank lines.
			chomp;
			if (/^\s*include[:\s]\s*(.*)$/) {
				# Include file.
				LoadList($1,$ArrayRef);
			}
			else {
				# Just an ordinary line.
				push @$ArrayRef,$_;				# Save this.
			}
		}
	}
}
