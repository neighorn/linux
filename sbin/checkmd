#!/usr/bin/perl

use strict;
use warnings;
use LogOutput;
use ProcessOptions;
use Text::ParseWords;
use Time::Local;

# Set up the environment.
$ENV{'PATH'}='/usr/local/sbin:/usr/local/bin:/sbin:/usr/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;			# Get our name, for messages.
$Prog=~s/^.*\///;		# Trim off the path, if present.
our @Parms;
our $opt_C;
our $opt_d;
our $opt_f;
our $opt_h;
our $opt_m;
our $opt_e;
our $opt_p;
our $opt_P;
our $opt_O;
our $opt_v;
our $opt_w = 0;
our %devices;
my @Args=@ARGV;			# Preserve orig command for ref.
my $ErrorFlag=0;			# No errors so far.
my $Syslog='user';			# Name of Syslog facility.  '' for no logging.
my $LogFile='';			# Log file name, or null for none.
my $BaseDir='/usr/local/etc';	# Set our base directory.
my $ConfigFile="$BaseDir/${Prog}.cfg";	# Name of config file.
my %Config;

# Set our base directory.
chdir($BaseDir) || die "Unable to cd to $BaseDir: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#	1) We define a new type l (lowercase L), which is a list (i.e. if
#	   specified multiple times, values are concatenated & blank separated.o
#	   Normal =s and =i would replace values instead of concatenate.
#	2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
my $OptSpec='C d f h m=l e=l p=l P=l O=s v w';

# Load the config file.
if (-e $ConfigFile) {
        open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
        # Build a hash of settings found in the config file.
        while (<CONFIG>) {
                next if (/^\s*#/);      # Comment.
                next if (/^\s*$/);      # Blank line.
                my ($name,$settings)=/^\s*(\S+)\s*:\s*(.+)/;
                $name=~tr/[a-z]/[A-Z]/;
                $Config{$name}=$settings;
        }
}

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}

if ($ErrorFlag) {exit $ErrorFlag;}	# Exit if errors were detected.
	
# Set up our logging and output filtering.
LogOutput('',$Syslog,$LogFile,$opt_m,$opt_e,$opt_p,$opt_P);

if ($Config{DISABLEUNTIL} and not $opt_f and not $opt_w) {
	if ($Config{DISABLEUNTIL} =~ m"^(\d\d\d\d)[/-](\d\d?)[/-](\d\d?)(?:\s+(\d\d?):(\d\d?)(?::(\d\d+))?)?") {
		my($AYear,$AMonth,$ADay,$AHour,$AMinute,$ASecond) = ($1,$2,$3,$4,$5,$6);
		$AHour = 8 unless (defined($AHour));
		$AMinute = 0 unless (defined($AMinute));
		$ASecond = 0 unless (defined($ASecond));
		my $ADate = timelocal($ASecond,$AMinute,$AHour,$ADay,$AMonth-1,$AYear);
		if (time() < $ADate) {
			printf "Checks disabled until %d/%.2d/%.2d %d:%.2d:%.2d per config file. Use -f to force execution.\n",
				$AYear,$AMonth,$ADay,$AHour,$AMinute,$ASecond;
			exit 0;
		}
	}
	else {
              print "Invalid DisableUntil date specified in config file: $Config{DISABLEUNTIL} -- ignored.\n";
	}
}

if (! $opt_m and ! $opt_e ) {
	# No mail addresses.  That's an error unless we have a tty.
	`tty -s` && warn "No e-mail addresses supplied.  $Prog has no way to notify of raid failures.\n";
}

do {
	$ErrorFlag = CheckMDDevices();
	sleep(60) if ($ErrorFlag and $opt_w);
} until (($ErrorFlag == 0) or ($opt_w == 0));


# Document the devices if we had errors.
if ($ErrorFlag) {
	foreach (sort(keys(%devices))) {
		my $serial = `smartctl -i /dev/$_ | grep 'Serial Number'`;
		chomp $serial;
		$serial =~ s/^.*:\s+//;
		print "Device /dev/$_: S#$serial\n" if ($serial);
	}
}

exit(0);


#
# CheckMDDevices - check the status of MD devices.
#
sub CheckMDDevices {


	# Typical /proc/mdstat records...
	# md1 : active raid1 sda1[0] sdb1[1] sdc[2](S)
	#      261952 blocks [2/2] [UU]
	#      996018 blocks super 1.2 [2/1] [U_]
	# Recovery line...
	#[========>............]  recovery = 41.3% (45933184/111201856) finish=1051.6min speed=1032K/sec
	my ($mdname, $status, $type);
	my $ReturnStatus = 0;
	open (MDSTAT, '/proc/mdstat') || die("Unable to open /proc/mdstat: $!\n");
	while (<MDSTAT>) {
		chomp;
		next if (/^\s*$/);
		#        md1          :   active     raid1        s  da 1 [ 0 ]  (S )
		print "Verbose: $_\n" if ($opt_v);
		if (/^\s*(md\d+)\s*:\s*(\S+)\s+.*(raid\S+)(\s+[sh]d.+\d*\[\d+\](\([SF]\))?)+$/) {
			# This is a "mdx : active raid1" line.
			($mdname, $status, $type) = ($1,$2,$3);
			my $rest;
			($rest = $_) =~ s/^.*?://;
			if ($status =~ /^active/ && $type =~ /raid[156]/ && $_ !~ /\(F\)/) {
				# Everything is normal.
				print "Verbose:	- normal\n" if ($opt_v);
			} else {
				warn "Unexpected response from $mdname: $rest\n";
				$ReturnStatus=1;
			}
			# Maintain a list of devices.
			$rest =~ s/^raid\S+\s*//;
			foreach (split(/\s+/,$rest)) {
				if (/(...)\d+\[\d+\]/) {
					$devices{$1}=1;
				}
			}
		}
		if (/\s*\d+\s+blocks\s.*\[\d+\/\d+\]\s+(\S+)\s*$/) {
			# This is a "xxxxxx blocks [2/2] [UU]" line.
			if ($1 !~ /^\[UU+\]/) {
				warn "$mdname is degraded ($1)\n" unless ($opt_w);
				$ReturnStatus=1;
			}
		}
		if (/\s*[\[\]=>.]+\s*(recovery|resync|check)/) {
			my $operation=$1;
			# This is a recovery line.  It's an error, unless we're
			# checking the RAID.  Find out.
			if ($operation ne 'check') {
				# Older versions didn't flag check in /proc/mdstat.
				my $FH;
				if (open($FH,'<',"/sys/block/$mdname/md/sync_action")) {
					my $sync_action=<$FH>;
					close $FH;
					$operation = 'check' if ($sync_action =~ /^check/);	# We're verifying.
				}	
			}
			# If we're checking, and haven't been told to treat that as an error, we're OK.
			next if ($operation eq 'check' and !$opt_C);

			# We're recovering (or checking and told to treat that as an error).  Report.
			chomp;
			warn "$mdname: $_\n" unless ($opt_w);
			$ReturnStatus=1;
		}
		if (/^\s*resync=/) {
			# This device needs resync, but is delayed.  So it is still broken.
			chomp;
			warn "$mdname: $_\n" unless ($opt_w);
			$ReturnStatus=1;
		}
	}
	return $ReturnStatus;
}


#
# Untaint  -- use very carefully!
#

sub untaint {
        my(@parms) = @_;
        foreach (@parms) {
                s/^(.*)$/$1/;
                $_=$1;
        }
        if (@parms == 1) {
                # Return scalar
                return $parms[$[];
        } else {
                # Return list
                return (@parms);
        }
}



#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,$ENV{'PAGER'}?"| $ENV{'PAGER'}":"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - check for incomplete RAID meta-devices.

Usage:	$Prog [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config]
	$Prog [-h]

Flags:
	-C:		Check: consider check (verify) status as an error.
			By default RAIDs that are verifying are considered healthy.
	-e mailid:	Error: Send an execution report to this e-mail address
			if errors are detected.
	-f:		Force: Ignore "DisableUntil" parameter from the config file.
	-m mailid:	Mailid: Send an execution report to this e-mail address.
	-p mailid:	Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:	Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-O config:	Insert the "config" configuration options from
			$ConfigFile into
			the command line at this point.
	-h	:	Help: display this panel
	-v	:	Verbose
	-w	:	Wait: loop, waiting until all devices are normal before exiting.

Examples:
	checkmd

Notes:
	The config file may contain "DISABLEUNTIL: yyyy/mm/dd" or
	"DISABLEUNTIL: yyyy/mm/dd hh:mm:ss" to disable alerts until the
	specified date (and time).  This can be used to suppress alerts for known
	issues until the specified date.  This date can be ignored with -f.

Return codes:
	0	:	Normal termination
	1	:	Help panel displayed.
	2	:	Invalid or unrecognized command line options.
	3	:	Invalid or unrecognized command line option value.
	4	:	Incorrect command line parameters.
	5	:	Unexpected message found in output.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:	Ignore - Don't display this message, it's not interesting.
#		LogOnly - Write this message to the syslog and log file, but
#			don't display it on STDOUT.
#		Show - Display this message, but it's not an error condition.
#		# - This is a comment, ignore it.
#
#  Pattern:	an ordinary perl pattern.  All patterns for a given score
#		are joined by logical OR conditions.
#
#  Notes:
#	1) The "Type" parameter may be specified in upper, lower, or mixed case.
#	2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
IGNORE	/^\s*$/
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY	/^Command: /
#
# These are normal messages that we want to see.
#
SHOW	/^\s*debug:/
SHOW	/^\s*Checks disabled until/
IGNORE	/^Job ended normally with status 0 and signal 0$/
SHOW	"^Device /dev/\S+:\s+S#"
SHOW	"^\s*Verbose:"
#
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
