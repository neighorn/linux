#!/usr/bin/perl
#
# scan-log - scan syslog log.
#
use lib '/usr/local/lib/perl5/site_perl';
use LogOutput;
use ProcessOptions;
use Text::ParseWords;

use FindBin;


# Initialize variables.
our $Prog=$FindBin::RealScript;         # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            # Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    # Trim off the path, if present.
my $ErrorFlag=0;                       # No errors so far.
my $Syslog='';                     # No logging - we just create more traffic we flag.
our $BaseDir=$FindBin::Bin;		# Set our base directory.
my $LogFile='';			# Name of the log file.
my $ConfigFile="$BaseDir/../etc/$Prog/${Prog}.cfg";     # Name of config file.
my $FilterDir="$BaseDir/../etc/${Prog}";     # Name of filter directory.
my $Hostname = `hostname`;
chomp $Hostname;
$Hostname =~ s/(.*?)(\..*$)$/$1/;

#

# Note: general purpose script - don't change current directory.
#chdir $BaseDir || die "Unable to change directories to $BaseDir: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#       1) We define a new type l (lowercase L), which is a list (i.e. if
#          specified multiple times, values are concatenated & blank separated.o
#          Normal =s and =i would replace values instead of concatenate.
#       2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
$OptSpec='h t m=l e=l O=s p=l P=l s r t v f=s';

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		($name,$settings)=split(/:?\s+/,$_,2);
		$name=~tr/[a-z]/[A-Z]/;
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}
if ($ErrorFlag) {exit $ErrorFlag;}      # Exit if errors were detected.
	
# Verify the command line.
die(qq<Incorrect number of parameters.  See "$Prog -h" for usage.\n">)
	unless (@Parms >= 1);

# Set up our logging and output filtering.
($BaseFileName=$Parms[0]) =~ s"^(.*/)?([^-]+)(-.+)?$"$2";
$opt_f="$FilterDir/$BaseFileName.filter" unless ($opt_f);
my $RunDate = `date +%m/%d`;
chomp $RunDate;
$LogOutput::Subject="$Prog $Hostname $RunDate $BaseFileName";
LogOutput("$opt_f",$Syslog,$LogFile,$opt_m,$opt_e,$opt_p,$opt_P);

# Verify the command line.
die "No files specified to scan.\n" unless (@Parms > 0);


# Expand file list, in case there are wild cards.
@Files=();
foreach (@Parms) {
	push @Files, glob $_;
}

foreach (@Files) {
	if (! -e $_) {
		warn "$_ does not exist -- skipped\n";
	}
	elsif (! -r $_) {
		warn "$_ is not readable -- skipped\n";
	}
	elsif (! -f $_) {
		warn "$_ is not a regular file -- skipped\n";
	}
	else {
		RunDangerousCmd("cat $_ | grep -v '^... .. ..:..:.. .* scanlog: ' | sed 's/ *\$//'"); 
	}
}

if ($ExitCode) {
	warn "$Prog failed.\n";
} else {
	#print "$Prog ended normally.\n";
}

$ExitCode=$Errors?10:0;
exit($ExitCode);

#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($opt_t) {
		print "Test: $Cmd\n";
	} else {
		print "Executing: $Cmd\n" if ($opt_v);
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Zip selected shared folders onto the snap server.

Usage:  $Prog [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config] [-t|-v] files
	$Prog -h

Flags:
	-e mailid:      Error: Send an execution report to this e-mail address
			if errors are detected.
	-f filter:	Filter: name of filter file.  Defaults to $Prog.filter.
	-m mailid:      Mailid: Send an execution report to this e-mail address.
	-p mailid:      Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:      Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-O config:      Insert the "config" configuration options from
			$ConfigFile.
			the command line at this point.
	-t	:	Test: echo commands instead of running them.
	-v	:	Verbose: echo commands before running them.
	-h      :       Help: display this panel

Parameters:
	files	:	one or more files to zip.

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
ENDUSAGE
close PAGENATER;
exit 1;
}
