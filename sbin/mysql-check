#!/usr/bin/perl
#
# Run local or remote MySQL integrity checks.
#
use strict;
use warnings;
use LogOutput;
use Getopt::Long qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
use POSIX qw(strftime);
use Fcntl qw(:flock :mode :DEFAULT);
use File::Basename;

# Initialize variables.
my $Prog=$0;			# Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";		# Trim off the path, if present.
$ENV{PATH} = '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin';
my @Args=@ARGV;			# Preserve orig command for ref.
my $ErrorFlag=0;		# No errors so far.
my @ConfigFiles=("/usr/local/etc/${Prog}.cfg");     # Name of config files.
my $JobLockFile;		# Name of our lock file.
my $JOBLOCKFH;			# Lock file handle.
our $Errors=0;
our %Config;
our @Parms;
our %Options;			# Options settings.

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
our %OptionSpecifications=(
		'<>'			=>	sub {my $Arg = shift; push @Parms,$Arg if (length($Arg));},
		'always-mail|m=s'	=>	\&opt_Array,
		'always-page|p=s'	=>	\&opt_Array,
		'cancel'		=>	\&opt_Value,
		'debug|d'		=>	sub {$DB::AutoTrace=1;},
		'error-mail|M=s'	=>	\&opt_Array,
		'error-page|P=s'	=>	\&opt_Array,
		'filter-file|F=s'	=>	\&opt_Array,
		'help|h|?!'		=>	\&opt_h,
                'host=s'                =>      \&opt_Value,
		'remote-host|R=s'	=>	sub { opt_Array(@_,'allow-delete'=>1,'expand-config'=>1);},
		'subject=s'		=>	\&opt_Value,
		'test|t'		=>	\&opt_Value,
		'verbose|v'		=>	sub {$Options{verbose} = (exists($Options{verbose})?$Options{verbose}+1:1)},
);
#
our $ExitCode;

my $HostName = `hostname`;
chomp $HostName;
$HostName =~ s/\..*$//;		# Strip domain.
our $BaseDir="/usr/local/backup/$Prog";	# Set our base directory.
# ---------------------------------------------------------
#
# Load the config file.
#
foreach (@ConfigFiles) {
        LoadConfigFile($_);
}
foreach (keys(%Config)) { s/,$//;};     # Trim off trailing commas.

# ---------------------------------------------------------
#
# Process the config file defaults if present.
#
# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
        if (join(' ',@ARGV) =~ /^\s*(\b-[tv]+)*\s*$/ && defined($Config{DEFAULTJOB}));

# Process the config file host defaults and general defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
        if (defined($Config{'ALLJOBS'}));

# ---------------------------------------------------------
#
# Process the command line options.
#
my @ARGVSave = @ARGV;           # In case we need to reprocess the command line later.
%Options=(verbose => 0);        # Initialize Options.
die "Invalid options specified\n" unless (GetOptions(%OptionSpecifications));
@ARGV = @ARGVSave;              # Restore @ARGV for LogOutput and second GetOptions.

$Options{subject}='%* %m/%d %C %N %E %*%*%*' unless (exists($Options{subject}) and $Options{subject});

# ---------------------------------------------------------
#
# Set up our logging and output filtering.
#
LogOutput({
	ALWAYS_MAIL_LIST => $Options{'always-mail'},
	ERROR_MAIL_LIST => $Options{'error-mail'},
	ALWAYS_PAGE_LIST => $Options{'always-page'},
	ERROR_PAGE_LIST => $Options{'error-page'},
	SYSLOG_FACILITY => 'user',
	VERBOSE => ($Options{verbose} >= 5? $Options{verbose}-4:0),
	FILTER_FILE => $Options{'filter-file'},
	MAIL_SUBJECT => $Options{subject},
});

# Verify the command line.
if (exists($Options{week})) {
	die "Invalid value for -n ($Options{week}): must be 1-5\n" unless ($Options{week} =~ /^[1-5]$/);
}

if (exists($Options{'remote-host'}) and @{$Options{'remote-host'}} > 0) {
	$Errors = RunRemote(@ARGV);
}
else {
	$Errors = RunLocally(@Parms);
}

# ---------------------------------------------------------
#
# Release the job lock.
#
if ($JOBLOCKFH) {
        close $JOBLOCKFH;
        unlink $JobLockFile;
}


if ($ExitCode) {
	warn "$Prog failed.\n";
} else {
	#print "$Prog ended normally.\n";
}

$ExitCode=$Errors?10:0;
exit($ExitCode);


# ---------------------------------------------------------
#
# LoadConfigFile - load a configuration file
#
sub LoadConfigFile {
	my $ConfigFile = shift;
	if (-e $ConfigFile) {
		my $CONFIGFH;
                open($CONFIGFH,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
                # Build a hash of settings found in the config file.
                my @Lines;

                # Read config file and assemble continuation lines into single items.
                while (<$CONFIGFH>) {
                        chomp;
                        next if (/^\s*#/);                      # Comment.
                        next if (/^\s*$/);                      # Blank line.
                        if (/^\s+(\S.*)$/ and @Lines > 0) {
                                # Continuation line.  Append to prior line.
                                $Lines[$#Lines] .= " $1";
                        }
                        else {
                                push @Lines, $_;
                        }
                }
                close $CONFIGFH;

                # Process assembled lines.
                foreach (@Lines) {
                        my ($name,$settings)=split(/:?\s+/,$_,2);
                        $name=uc($name);                        # Name is not case sensitive.
                        $settings='' unless ($settings);        # Avoid undef warnings.
                        $settings=~s/\s+$//;                    # Trim trailing spaces.
			if ($name eq 'INCLUDE') {
				LoadConfigFile($settings);
			}
			else {
				$settings=~s/\s+$//;	# Trim trailing spaces.
				$Config{$name}.=$settings . ',' ;
			}
                }
		foreach (keys(%Config)) {
			$Config{$_} =~ s/,$//;  # Remove trailing comma
		}
        }
}



# ---------------------------------------------------------
#
# RunRemote - Run this elsewhere and track the results.
#
sub RunRemote {

	my @ARGV=@_;
	my $Errors = 0;

	# Analyze the remote-host list, ignoring duplicates and handling !-deletions.
	my @HostList = @{$Options{'remote-host'}};
	die "No remote hosts specified on the command line or in the configuration file.\n" unless (@HostList);

	my $MaxLength = 0;
	foreach (@HostList) { $MaxLength=($MaxLength < length($_)?length($_):$MaxLength); }
	$MaxLength++;		# Allow for trailing colon.
	my $DeleteNext=0;
	foreach (@ARGV) {
		if ($DeleteNext) {
			$_ = '';
			$DeleteNext=0;
		}
		elsif (/^--remote-host=/) {
			$_ = '';		# Delete this for remote systems.
		}
		elsif (/^-R/) {
			$_ = '';
			$DeleteNext=1;
		}
	}
	@ARGV = grep { $_ ne '' } @ARGV;
	@ARGV = map {qq<"$_">} @ARGV;

	foreach my $Host (@HostList) {
		my $Cmd =   "ssh $Host $Prog "
			  . join(' ', @ARGV) . ' '
			  . '-F SHOWALL '
			  . '--always-mail= '
			  . '2\>\&1 '
			  ;
		my $FH;

		# Don't even go to remote hosts if test level 2 (-tt).
		if($Options{test} and $Options{test} >= 2) {
			print "Test: $Cmd\n";
			next;
		}

		print "Verbose: Running $Cmd\n" if ($Options{verbose} or $Options{test});
		if (open($FH, "$Cmd |")) {
			while (<$FH>) {
				printf "%-*s %s", $MaxLength, "$Host:", $_;
			}
			close $FH;
			my ($ExitCode, $Signal) = ($? >> 8, $? & 127);
			printf "%-*s  Remote job exited with return code %d and signal %d\n", $MaxLength, "$Host:", $ExitCode, $Signal;
			$Errors++ if ($ExitCode);
		}
		else {
			warn "Unable to open ssh session to $Host: $!\n";
			$Errors++;
		}
	}

	return $Errors;
}


# ---------------------------------------------------------
#
# RunLocally - run a sysbackup on this machine.
#
sub RunLocally {

	my @Parms = @_;
	# ---------------------------------------------------------
	#
	# Load any host-specific options
	#
	my $HostOptions = $Config{uc("host=$HostName")};
	if ($HostOptions) {
		die "Invalid options specified\n" unless (GetOptionsFromString($HostOptions,%OptionSpecifications));
	}

	my $ExitCode = RunDangerousCmd(
		  '/usr/bin/mysqlcheck '
		. '--all-databases '
		. ($Options{host}?"--host $Options{host} ":'')
	);

}


# ---------------------------------------------------------
#
# GetStatus - retrieve the status of a device
#
sub GetStatus {
	my $SyncFile = shift;
	my $FH;
	if (open($FH,'<',$SyncFile)) {
		my $Status = <$FH>;
		chomp $Status;
		close $FH;
		return $Status;
	} 
	else {
		warn "Unable to open $SyncFile: $!\n";
		return "unknown";
	}
}



# ---------------------------------------------------------
#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($Options{test}) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($Options{'verbose'});
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


# ---------------------------------------------------------
#
# opt_Value - generic single-value option processing
#
sub opt_Value {
	my($Name,$Value) = @_;
	$Options{$Name} = $Value;
}


# ---------------------------------------------------------
#
# opt_Array - generic multi-value option  processing
#
sub opt_Array {

	my($Name,$Value,%ArrayOpt) = @_;

	# Possible array processing options:
	#	preserve-lists:	0 (default), split on embedded spaces or commas
	#			1, don't split on embedded spaces or commas
	#	allow-delete:	0 (default), leading ! on value has no meaning
	#			1, leading ! on value means delete value from
	#				current list.
	#	force-delete:	0 (default), assume add unless ! and allow-delete=1
	#			1, delete this item regardless of leading !


	# Set a recursion limit if we don't already have one.  This helps
	# us detect list loops (listA points to listA, or A->B->A, etc.).
	$ArrayOpt{'recursion-limit'} = 64 unless ($ArrayOpt{'recursion-limit'});

	# Is the value empty, meaning to wipe any entries to this point.
	if (!$Value) {
		# Received "--opt=".  Empty this array.
		@{$Options{$Name}}=();
		return;
	}

	# Split out lists by default, unless embedded-lists are preserved.
	my @ValueList;
	if ($ArrayOpt{'preserve-lists'}) {
		# Preserve commas and embedded spaces.  Just leave value as is.
		@ValueList = ($Value);
	}
	else {
		$Value =~ s/[\s,]+$//;	# Trailing separators make no sense.
		$Value =~ s/^\s+//;	# Ignore leading whitespace.
		@ValueList = split(/[,\s]+/,$Value);
	}

	# Now process each list item individually.
	while ($Value = shift(@ValueList)) {
		
		# Are we adding or deleting this item.
		my $AddItem = 1;	# Assume we're adding.
		my $Prefix;
		if ($ArrayOpt{'force-delete'}) {
			# We've been told, flat-out, to delete this item.
			$AddItem = 0;
			$Value =~ s/^!+// if ($ArrayOpt{'allow-delete'});
		}
		elsif ($ArrayOpt{'allow-delete'} and $Value =~ /^!+(.*)$/) {
			# Delete is allowed, and ! is present.
			$AddItem = 0;
			$Value = $1;
		}
		
		# If config lists are permitted, see if this is a config list.
		if ($ArrayOpt{'expand-config'} and exists($Config{uc($Value)})) {
			# This is a reference to a config file list. Recurse
			# through this, in case the list contains more lists.
			die "List loop detected in --$Name=$Value"
				if ($ArrayOpt{'recursion-limit'} <= 0);
			opt_Array(
				$Name,
				$Config{uc($Value)},
				%ArrayOpt,'recursion-limit'=>($ArrayOpt{'recursion-limit'}-1),
				'force-delete'=> (1-$AddItem),
			);
			next;
		}

		# If we got here, we have a value to either add or delete.
		if ($AddItem) {
			push @{$Options{$Name}},$Value
				unless grep { $_ eq $Value } @{$Options{$Name}};
		}
		else {
			# Remove this item from the list if present.
			@{$Options{$Name}} = grep { $_ ne $Value } @{$Options{$Name}};
		}
	}
}



# ---------------------------------------------------------
#
# opt_h: Usage
#
sub opt_h {

	use FindBin qw($RealScript);

	system(qq<pod2text $RealScript | more>);
exit 1;
}

=pod

=head1 mysql-check: check MySQL table integrity on local or remote machines

=head3 Usage:  
	mysql-check [options] 

	mysql-check -h

=head3 Flags:
        --error-mail|-e mailid: Error: Send an execution report to this
                                e-mail address if errors are detected.
        --filter|-F filter:     Filter: Use alternate error detection
                                filter file "filter".  The default is
                                to use the built-in error filter.
        --always-mail|-m addr:  Mailid: Send an execution report to
                                this e-mail address.
        --always-page|-p addr:  Page: Send a very brief message
                                (suitable for a pager) to this e-mail
                                address when this job completes.
        --error-page|-P addr:   Page error: Send a very brief message to
                                this e-mail address if errors are
                                detected in this job.
        --option-set|-O config: Insert the "config" configuration options
                                from /usr/local/etc/%Prog.cfg
                                into the command line at this point.
        --host host:		Host:  Run mysqlcheck on the local machine
				with the --host parameter to connect to 
                                a MySQL server elsewhere on the network.
				This option requires that MySQL be installed
                                on the local machine to provide the mysqlcheck
                                binary.  See also --remote-host, which supports
                                checking multiple hosts, and does not require
                                a local MySQL installation as it uses the 
                                remote systems' software to initiate the
                                check.
        --remote-host|-R host:  Remote: Run this on one or more remote
                                hosts.  "host" may be a host name, an
                                IP address, a configuration file entry
                                name, or a comma or space separated list of
                                any mix of these.  This option may also be
                                repeated to append to the list.  This option
				causes the script to ssh to the specified
				host and run the check locally from that
                                machine.  See also --host.
        --filter|-F filter:	Filter: use the specified filter file.  The
				default is to use __DATA__, the internal
				filter file.
        --test|-t:              Test: echo commands instead of running them.
        --verbose|-v:           Verbose: echo commands before running them.
                                May be used multiple times to increase verbosity.
        --help|-h:              Help: display this panel
	--subject text:s	Subject: set the subject e-mail to 'text'.  Percent
				variables are processed per LogOutput.pm.

=head3 Parameters:              (none)

=head3 Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.

=cut
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.

IGNORE  /^\s*\s*(\S+:\s*)?$/ 
IGNORE  "^\s*(\S+:\s+)?.*\s+OK$" 

# These are normal messages that we want to see in the e-mail log only. 
# 
LOGONLY "^\S+ started on \S+ on \S+, \d+-\d+-\d+" 
LOGONLY /^Command: / 
IGNORE "^\s*(\S+:\s+)?\S+ started on \S+ on \S+, \d+-\d+-\d+" 
IGNORE /^\s*(\S+:\s+)?Command: / 
# 
# These are normal messages that we want to see. 
# 
SHOW    "^\s*(\S+:\s+)?\S+ ended normally with status 0 and signal 0$" 
IGNORE	"^\s*\S+:\s+\S+ ended on \S+, \d+-\d+-\d+ at \d\d:\d\d:\d\d - run time:"
SHOW    "^\s*(\S+:\s+)?Test:" 
SHOW    "^\s*(\S+:\s+)?Executing:" 
SHOW    "^\s*(\S+:\s+)?Verbose" 
SHOW    "^\s*(\S+:\s+)?debug:" 
# The log files always throw an error about locks.  mysqlcheck should be smarter. 
# Always show the log names, so that if another error comes up we know which 
# table it applies to. 
IGNORE  "^\s*(\S+:\s+)?Error\s*: You can't use locks with log tables.$" 
IGNORE  "^\s*\S+:\s+Remote job exited with return code 0 and signal 0$"
SHOW    "^\s*(\S+:\s+)?mysql.(slow|general)_log\s*$" 
#
