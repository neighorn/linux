#! /usr/bin/perl
#
# Copyright (c) 2010, Martin Consulting Services, Inc.
# Licensed under the Lesser Gnu Public License (LGPL).
# 
# ABSOLUTELY NO WARRENTIES EXPRESSED OR IMPLIED.  ANY USE OF THIS
# CODE IS STRICTLY AT YOUR OWN RISK.
#

#
# Configure a host at boot-up.
#
#   This script is used by cloned systems to adjust individual settings
#   such as the host name, services to start up at boot time, and
#   specific commands to execute at boot time.  With -c it can
#   also be used on a running system to check attributes for use in
#   conditionally running commands, perhaps in crontab.
#
use strict;
use warnings;
use lib '/usr/local/lib/perl5/site_perl';
use LogOutput;
use ProcessOptions;
use Text::ParseWords;
use FindBin qw($RealBin $RealScript);
use Sys::Hostname;
use feature 'switch';

# Initialize variables.
our $Prog=$RealScript;              	# Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
our $Errors=0;				# No errors so far.
our $Syslog='';				# Name of Syslog facility.  '' for none.
our $BaseDir=$RealBin;			# Set our base directory.
our $LogFile="";			# Name of the log file.
our $ConfigFile="$BaseDir/../etc/${Prog}.cfg";     # Name of config file.
our @Parms;				# Array of remaining cmdline parms.
our %Config;				# Our configuration options.
my $ExitCode;				# Code we'll exit with.
#
our $opt_c;				# -c (check) option.
our $opt_h;				# -h (help) option.
our $opt_H;				# -H (hostname) option.
our $opt_e;				# -e (error mail) option.
our $opt_m;				# -m (mail) option.
our $opt_p;				# -p (pager mail) option.
our $opt_P;				# -P (pager error mail) option.
our $opt_t;				# -t (test) option.
our $opt_v;				# -v (verbose) option.
#

# Note: general purpose script - don't change current directory.
#chdir $BaseDir || die "Unable to change directories to $BaseDir: $!\n";

# Set the ProcessOptions spec here.  This is just like Getopt::Mixed except:
#       1) We define a new type l (lowercase L), which is a list (i.e. if
#          specified multiple times, values are concatenated & blank separated.o
#          Normal =s and =i would replace values instead of concatenate.
#       2) We don't support long option names, except as aliases.
# These are the standard production options.  Add more options here as needed.
my $OptSpec='c=s e=l h H=s m=l O=s p=l P=l t v';

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=~tr/[a-z]/[A-Z]/ if ($name =~ /alljobs/i);
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Process the command line options, if any.
if (@ARGV) {
	# Process the command line arguments.
	ProcessOptions($OptSpec);
} else {
	# No command line options.  Run the default job.
	ProcessOptions($OptSpec,$Config{'DEFAULTJOB'})
		if (defined($Config{'DEFAULTJOB'}));
}
if ($Errors) {exit $ExitCode;}      # Exit if errors were detected.
	
# Set up our logging and output filtering.
LogOutput({
	ALWAYS_MAIL_LIST => $opt_m,
	ERROR_MAIL_LIST	=> $opt_e,
	ALWAYS_PAGE_LIST => $opt_p,
	ERROR_PAGE_LIST => $opt_P,
	NORMAL_RETURN_CODES => [0,1],
});

# Verify the command line.
die("Excessive parameters on the command line.  See \"$Prog -h\" for usage.")
	if (@Parms > 0);

my $FH;		# Config file filehandle.
my %MACs;	# Map MAC addresses to hostnames
my %Interfaces;	# Map MAC addresses to current interface names
my %Services;	# Map services to hostnames
my @BootCmds;	# List of commands to execute.
my %Attributes;	# List of attributes (used with -c to query whether we have an attrib);
open ($FH,'<',$ConfigFile) || die "Unable to open $ConfigFile";
my $line = 0;
while (<$FH>) {
	$line++;
	s/([\s,])+/$1/g;		# Normalize spacing.
	s/^\s*//;		# Strip leading space if any.
	next if (/^#|^\s*$/);
	my ($type,$conditional,$data)=split('\s+',$_,3);
	$type=lc($type);
	$type=~s/:$//;		# Strip optional trailing colon.
	$data =~ s/^\s*//;	# Strip leading spaces.
	$data =~ s/\s*$//;	# Strip trailing spaces.
	given($type) {
		when ('service') {$Services{$data}={line=>$line, conditional=>$conditional}; };
		when ('mac') {
			my $interface;
			($data,$interface) = split('\s++',$data);	# Split out optional data.
			$MACs{$data}="$conditional $interface";
		};
		when ('bootcmd') { push @BootCmds,"$line $conditional $data"; };
		when ('attrib') { $Attributes{lc($data)}={line=>$line, conditional=>$conditional}; };
		default {
			die qq<Unrecognized record type "$type" in hostcfg.cfg line $line\n>;
		}
	}
}
close $FH;

#
# Gather our network interface names and MACs.
#
open($FH,'ifconfig -a |') || die "Unable to get MAC addresses";
my $IFaceName;
my $MAC;
while (<$FH>) {
	next if (/^\S+:\S+/);	# Ignore device aliases.
	next unless (/^(\S+)\s.*HWaddr\s+(\S+)/);
	$Interfaces{$2}=$1;		# Remember the MAC Addr and interface name.
}
close $FH;


#
# Set our host name.  We use the following sources:
#	1) -H option.
#	2) Look up the MAC address in the list supplied in the config file.
#	3) Use the currently assigned host name.
#
if (! $opt_H and ! $opt_c) {
	# Try to determine our host name.
	foreach my $MACAddr (keys(%Interfaces)) {
		if (exists($MACs{$MACAddr})) {
			$opt_H = $MACs{$MACAddr};
			$opt_H =~ s/^\s+//;	# Strip leading spaces.
			$opt_H =~ s/\s+.*$//;	# Strip trailing spaces and data.
			RunDangerousCmd("hostname $opt_H");
			last;
		}
	}
}
$opt_H=hostname unless ($opt_H);
die "Unable to determine hostname" unless ($opt_H);

#
# Are we checking services/attributes?
#
if ($opt_c) {
	die "Unknown attribute $opt_c" unless (exists($Attributes{$opt_c}) or exists($Services{$opt_c}));
	if (
		(
			exists($Attributes{$opt_c})
			and CheckCond($Attributes{$opt_c}{line},$opt_H,$Attributes{$opt_c}{conditional}) 
		)
		or 
		(	exists($Services{$opt_c})
			and CheckCond($Services{$opt_c}{line},$opt_H,$Services{$opt_c}{conditional}) 
		)
	)
	{
		print qq<$opt_H has attribute "$opt_c"\n> if ($opt_v);
		exit 0;		# We have a match.
	}
	else {
		print qq<$opt_H does not have attribute "$opt_c"\n> if ($opt_v);
		exit 1;		# No match.
	}
}

# Set /etc/HOSTNAME if present.
if (-f '/etc/HOSTNAME') {
	open ($FH,'<','/etc/HOSTNAME') || die "Unable to open /etc/HOSTNAME for reading: $!";
	my @lines=<$FH>;
	close $FH;
	open ($FH,'>','/etc/HOSTNAME') || die "Unable to open /etc/HOSTNAME for writing: $!"
		unless ($opt_t);
	foreach my $line (@lines) {
		chomp $line;
		given ($line) {
			when (/^\S+\./)	{
				# Change first node in host.domain.domain.
				$line =~ s/^([^.])+/${opt_H}/;
			}
			when (/^[^#.]+$/) {
				# Just the host name.  Replace it completely.
				$line = "$opt_H";
			}
			default	{;}					# Don't know what this is.  Leave as-is.
		}
		if ($opt_t) {
			print "Test: would have written to /etc/HOSTNAME: $line\n";
		}
		else {
			print $FH "$line\n";
		}
	}
	close $FH;
}


#
# If desired, set the interface names based on the host name.
#
my $DeleteFlag=1;	# Delete the old rules if we get an update.
foreach my $MACAddr (sort(keys(%Interfaces))) {
	if (exists($MACs{$MACAddr})) {
		my($hostname,$NewName) = split(/\s+/,$MACs{$MACAddr},2);
		next unless ($hostname eq $opt_H);
		$ENV{MATCHADDR} = lc($MACAddr);
		$ENV{MATCHIFTYPE} = '1';
		$ENV{INTERFACE} = $Interfaces{$MACAddr};
		$ENV{INTERFACE_NAME} = $NewName;
		$ENV{COMMENT} = "File rewritten by $Prog";
		if ($DeleteFlag) {
			$DeleteFlag = 0;	# Only do this for the first one.
			RunDangerousCmd("rm /etc/udev/rules.d/*-persistent-net.rules");
		}
		my $Status = RunDangerousCmd("/lib/udev/write_net_rules");
	}
}


#
# Set services on or off based on the host name.
#
foreach (sort(keys(%Services))) {
	if (CheckCond($Services{$_}{line},$opt_H,$Services{$_}{conditional})) {
		my $Status = RunDangerousCmd("chkconfig -s $_ on");
		#$ExitCode = ($Status != 0?8:$ExitCode);
	}
	else {
		my $Status = RunDangerousCmd("chkconfig -s $_ off");
		#$ExitCode = ($Status != 0?8:$ExitCode);
	}
}

#
# Run boot commands.  Replace %HOST with our host name.
#
foreach (@BootCmds) {
	my($line,$hostlist,$command) = split(/\s+/,$_,3);
	if (CheckCond($line,$opt_H,$hostlist)) {
		$command =~ s/%HOST/$opt_H/g;	# %HOST to host name.
		my $Status = RunDangerousCmd($command);
		$ExitCode = ($Status != 0?8:$ExitCode);
	}
}

if ($ExitCode) {
	warn "$Prog failed.\n";
} else {
	#print "$Prog ended normally.\n";
}

$ExitCode=$Errors?10:0;
exit($ExitCode);


#
# CheckCond - see if this host matches this list, directly or indirectly.
#
sub CheckCond {

	my ($Line,$Host,$ConditionalList) = @_;

	foreach my $Conditional ((split(/\s*,\s*/,$ConditionalList))) {
		# Assume we're checking the host name unless otherwise specified.
		$Conditional="host=$Conditional" unless ($Conditional =~ /=/);

		if ($Conditional !~ /^\s*(\S+?)\s*(!=|==|=)\s*(\S+)\s*$/) {
			warn qq<Invalid conditional "$Conditional" in hostccfg.cfg line $Line -- ignored.\n>;
			next;
		}

		my($Type,$Operand,$Value) = ($1, $2, $3);
		$Type = uc($Type);			# Normalize case.
		$Operand='==' if ($Operand eq '=');	# Normalize = to ==
		given ($Type) {
			when ('HOST') {
				return 1 if (",$Value," =~ /,$Host,/  and $Operand eq '==');
				return 1 if (",$Value," !~ /,$Host,/  and $Operand eq '!=');
				return 1 if ($Value eq '*'	      and $Operand eq '==');
			}
			when ('ATTRIBUTE'|'ATTRIB') {
				return 0 if (!exists($Attributes{$Value}));	# No such attribute.
				return 1 if (",$Attributes{$Value}{conditional}," =~ /,$Host,/  and $Operand eq '==');
				return 1 if (",$Attributes{$Value}{conditional}," !~ /,$Host,/  and $Operand eq '!=');
			}
			default {
				warn "Unknown comparison type $Type\n";
			}
		}
	}
	return 0;
}
	
		
#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($opt_t) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($opt_v);
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_h: Usage
#
sub opt_h {

	my $Pagenater=$ENV{PAGENATER};
	$Pagenater="more" unless ($Pagenater);
	system("pod2text $RealScript | $Pagenater");
	exit(1);
}

=pod
=head1 $Prog - Set which services should be up or down based on the host name.

=head3 Usage:  
	$Prog [-e mailid] [-m mailid] [-p mailid] [-P mailid] [-O config] [-t|-v] 

	$Prog -h

=head3 Flags:
	-e mailid:      Error: Send an execution report to this e-mail address
			if errors are detected.
	-m mailid:      Mailid: Send an execution report to this e-mail address.
	-p mailid:      Page: Send a very brief message (suitable for a pager)
			to this e-mail address when this job completes.
	-P mailid:      Page error: Send a very brief message to this e-mail 
			address if errors are detected in this job.
	-O config:      Insert the "config" configuration options from
			$ConfigFile.
			the command line at this point.
	-t	:	Test: echo commands instead of running them.
	-v	:	Verbose: echo commands before running them.
	-h      :       Help: display this panel

=head3 Parameters:
	(none)

=head3 Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.

=cut
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
IGNORE  /^\s*$/
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \d+/\d+/\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW    "^\s*Job ended normally with status 0 and signal 0$"
SHOW    "^\s*Test:"
SHOW    "^\s*Executing:"
SHOW	"^\s*debug:"
SHOW	"^\s*insserv:"
SHOW	"^\s*/sbin/insserv"
SHOW	"^\s*\S+ (has|does not have) attribute"
IGNORE	"^\s*Job ended normally"
#
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
