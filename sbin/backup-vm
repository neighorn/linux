#!/usr/bin/perl

use strict;
use warnings;
use LogOutput;
#use ProcessOptions;
use Getopt::Long qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
use File::Find;
use File::FnMatch qw(:fnmatch);
use File::Path;
use File::Temp qw(mktemp);
use Fcntl qw(:flock :mode :DEFAULT);
use POSIX qw(strftime);
use IO::Socket;
use Data::Dumper::Simple;
$Data::Dumper::Pad = "Verbose:\t\t";

$ENV{PATH}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;                           # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
my $Errors=0;   	                # No errors so far.
#my $Syslog='user';                      # Name of Syslog facility.  '' for none.
my $BaseDir="/usr/local/etc";		# Set our base directory.
my $ConfigFile="$BaseDir/${Prog}.cfg";	# Name of config file.
our %Config;				# Data from the config file.
our %Options;				# Options settings.
our @Parms;				# List of non-option arguments.
our $Syslog = 'user';			# Log to the syslog.

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
our %OptionSpecifications=(
		'cd|b=s'		=>	\&opt_Value,
		'cycles|C=i'		=>	\&opt_Value,
		'debug|d'		=>	sub {$DB::AutoTrace=1;},
		'help|h|?!'		=>	\&opt_h,
		'always-mail|m=s'	=>	\&opt_Array,
		'error-mail|M=s'	=>	\&opt_Array,
		'after-state=s'		=>	\&opt_Value,
		'option-set|O=s'	=>	\&opt_O,
		'output|o=s'		=>	\&opt_Value,
		'always-page|p=s'	=>	\&opt_Array,
		'error-page|P=s'	=>	\&opt_Array,
		'test|t!'		=>	\&opt_Value,
		'verbose|v'		=>	sub {$Options{verbose} = (exists($Options{verbose})?$Options{verbose}+1:1)},
		'exclude|x=s'		=>	\&opt_Array,
);
#

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=uc($name);	# Name is not case sensitive.
		$settings=~s/\s+$//;	# Trim trailing spaces.
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
	if (!@ARGV && defined($Config{DEFAULTJOB}));

# Pre-process our command line, to get the options we need for LogOutput.
my @ARGVSave = @ARGV;		# Needed to reprocess command line later.
%Options=(verbose => 0);	# Initialize Options.
$Errors ++ unless (GetOptions(%OptionSpecifications));
if ($Errors) {
	print STDERR "Invalid command line options -- aborting.\n";
	exit 15;
}
if ($Options{output} and $Options{output} !~ m<^[a-zA-Z0-9_:.,%=, *?/-]+$>) {
	print STDERR "Invalid value \"$Options{output}\" for --output\n";
	exit 16;
}
if ($Options{cycles} and $Options{cycles} !~ /^[1-9]\d*$/) {
	print STDERR "Invalid value for --cycles\n";
	exit 17;
}

# If there aren't any parameters here, back up everything.
if (@ARGV == 0) {
	foreach (`virsh list --all`) {
		next unless (/^\s*[\d-]+\s+(\S+)\s+\S/);
		push @ARGVSave,$1;
	}
}

print Dumper(\%Config) if ($Options{verbose} >=3);

@ARGV = @ARGVSave;		# Restore @ARGV for LogOutput and second GetOptions.
	
# Set up our logging and output filtering.
my $RunDate=`date +%m/%d`;
chomp $RunDate;
my $Subject;
if ($Options{subject}) {
	$Subject="$Options{subject}" ;
} elsif (@Parms >= 1) {
	$Subject=
		  "%* %m/%d %C %N "
		. ($Options{test}?' - test -':'')
		. join(', ',@Parms)
		. " %E %*%*%*" ;
} else {
	$Subject="%* %m/%d %C %N %E %*%*%*" ;
};

# Make sure some key items exist;
foreach (qw(always-mail error-mail always-page error-page)) {
	@{$Options{$_}} = () unless (exists($Options{$_}));
}
$Options{verbose} = 0 unless (exists($Options{verbose}));
$Options{logfile} = '' unless (exists($Options{logfile}));
my $LogOutputVerbose = ($Options{verbose} > 4?$Options{verbose}-4:0);

LogOutput({
	SYSLOG_FACILITY		=> $Syslog,
	MAIL_FILE		=> $Options{logfile},
	MAIL_FILE_PERMS		=> 0644,
	ALWAYS_MAIL_LIST	=> \@{$Options{"always-mail"}},
	ERROR_MAIL_LIST		=> \@{$Options{"error-mail"}},
	ALWAYS_PAGE_LIST	=> \@{$Options{"always-page"}},
	ERROR_PAGE_LIST		=> \@{$Options{"error-page"}},
	MAIL_SUBJECT		=> $Subject,
	VERBOSE			=> $LogOutputVerbose,
});

# Make another pass through the parm list.  This time, actually
# run backups when we come across parms via <>.  Doing it this way lets
# the user turn options on and off for each kind of backup (e.g.
# change the exclude list per backup).
%Options = (
		"after-state" => 'same',
		cd => '/var/lib/libvirt/images',
		test => $Options{test},
		verbose => $Options{verbose}
);			# Reset Options to defaults for reprocessing.
$Errors ++ unless (GetOptions(%OptionSpecifications,'<>'=>\&ProcessBackup));

#
# Wrap up.
#
if ($Errors) {
	warn "$Prog failed.\n";
} else {
	print "$Prog ended normally.\n";
}

exit( ($Errors?10:0) );


#
# ProcessBackup - Backup a VM
#
sub ProcessBackup {

	my $Machine = shift;
	print strftime("Backing up $Machine at %Y-%m-%d %T\n",localtime());

	# Capture the XML for later, and to determine if the machine exists.
	my @XML;
	eval "\@XML = `virsh dumpxml $Machine`;";
	if ($@) {
		print STDERR "    Unable to dump XML for $Machine: $@\n";
		$Errors++;
		return 8;
	}

	# Load and machine-specific configuration data.
	local %Options = %::Options;
	if (my $MachineConfig = $Config{uc("NAME=$Machine")}) {
		$Errors ++ unless (
			GetOptionsFromString($MachineConfig,%OptionSpecifications)
		);
	}
	print Dumper(\%Options) if ($Options{verbose} >=3);

	# Figure out our output file name.
	$Options{output} = "$Options{cd}/%C-%Y%m%d.tar"
		unless $Options{output};
	my $Output = $Options{output};
	$Output =~ s/%C/$Machine/g;
	$Output = strftime($Output,localtime())
		if ($Output =~ /%[^p]/);
	$Output =~ s"/+$"";			# Remove trailing slashes.
	$Output =~ m"^(.*)/([^/]*)$";		# Split path from file name.
	my ($OutputDir,$OutputFile) = ($1, $2);
	if ($OutputDir =~ /[?*]/) {
		# Contains wild cards.
		my $OutputDirTest = glob $OutputDir;
		$OutputDir = $OutputDirTest if ($OutputDirTest and -d $OutputDirTest);
		$Output = "$OutputDir/$OutputFile";
	}
	if ( ! -d $OutputDir and ! $Options{test}) {
		# OutputDir doesn't exist.
		if (! mkpath($OutputDir,,0600)) {
			print STDERR "Unable to create $OutputDir: $@\n";
			$Errors++;
			return 9;
		}
	}

	# Clean up old backups if requested.
	if ($Options{cycles}) {
		my $BackupPattern = $Output;
		$BackupPattern =~ s/%C/$Machine/g;
		$BackupPattern =~ s/%[ymdHMSgGI]/../g;	# Two digit patterns.
		$BackupPattern =~ s/%[Y]/..../g;	# Four digit patterns.
		if (open(my $FHLS,"ls -dt $OutputDir 2>/dev/null |")) {
	        	my $Count=0;
	        	while (<$FHLS>) {
				chomp;
				next unless (m<$BackupPattern>o);
	                	$Count++;
	                	RunDangerousCmd("rm -rf $_") if ($Count >= $Options{cycles});
	        	}
	        	close $FHLS;
	        }
		else {
			warn "Unable to open ls command: $! -- obsolete backups may not be deleted.\n";
		}
	}

	# Remember if it's running.
	my $WasRunning=IsRunning($Machine);

	# If it's running, shut it down.
	if ( $WasRunning ) {
		# It's running.
		print "    Shutting down $Machine" . ($Options{test}?" (test)\n":"\n");
		my $Count = 0;
		while (! $Options{test} and IsRunning($Machine)) {
			last if ($Count++ > 24);
			RunDangerousCmd("virsh shutdown $Machine")
				if ($Count % 12 == 1);
			sleep 5
		}
	}
	else {
		print "    $Machine is already down.\n";
	}
	if (! $Options{test} and IsRunning($Machine)) {
		print STDERR "    $Machine failed to shutdown -- backup skipped\n";
		return 18;
	}

	# Write the XML to the tar file.
	my $XMLFile = "$OutputDir/$Machine.xml";
	my $TarCmd = "tar -cf $Output -C $OutputDir $Machine.xml";
	if ($Options{test}) {
		print "Test: $TarCmd\n";
	}
	else {
		my $FH;
		if (!open ($FH,'>',"$XMLFile") ) {
			print STDERR "Unable to create $XMLFile\n";
			$Errors++;
			return 10;
		}
		print $FH @XML;
		close $FH;
		RunDangerousCmd($TarCmd);
		if ($? != 0) {
			$Errors++;
			return 11;
		}
		unlink $XMLFile;
	}

	# Run the backup.
	print "    Backing up $Machine" . ($Options{test}?" (test)\n":"\n");
	my $BackupErrors = 0;
	LINE: foreach my $Line (@XML) {
		chomp $Line;
		next unless ($Line =~ /source file\s*=\s*'(.*?)'/i);
		my $SourcePath = $1;
		# Found a file.  Is it excluded?
		foreach my $Exclude (@{$Options{exclude}}) {
			next LINE if (fnmatch("$Exclude",$SourcePath));
		}
		$SourcePath =~ m"^(.*)/(.*?)$";
		my($SourceDir,$SourceFile) = ($1,$2);

		# Back it up.
		my $Status = RunDangerousCmd("tar -uf $Output -C $SourceDir $SourceFile");
		if ( $Status != 0 ) {
			print STDERR "    Backup of $SourceFile failed with status $Status\n";
			$BackupErrors++;
		}
	}
	if ($BackupErrors) {
		$Errors++;
	}
	else {
		print strftime("    Backup of $Machine completed normally at %Y-%m-%d %H:%M:%S\n",localtime());
	}

	# Set the machine in the desired after-state.
	$Options{"after-state"} = lc($Options{"after-state"});
	$Options{"after-state"} = 'same'
		unless ($Options{"after-state"} =~ /^(up|down|same)$/);
	if ( $Options{"after-state"} eq 'up' 
		or ($Options{"after-state"} eq 'same' and $WasRunning)
	) {
		print strftime(
			  "    Restarting $Machine at %Y-%m-%d %T"
				. ($Options{test}?" (test)\n":"\n")
				,localtime());
		foreach ((1,2,3)) {
			RunDangerousCmd("virsh start $Machine");
			sleep 10 unless ($Options{test});
			last if (IsRunning($Machine) or $Options{test});
		}
		if (IsRunning($Machine) or $Options{test}) {
			print strftime(
				  "    $Machine started at %Y-%m-%d %T"
				. ($Options{test}?" (test)\n":"\n")
				,localtime());
		}
		else {
			print STDERR "    $Machine failed to restart\n";
		}
	}
}


#
# IsRunning - is a VM running?
#
sub IsRunning {
	my $Target = shift;
	system("virsh list | grep -q ' $Target '");
	return ($?==0?1:0);
}


#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($Options{test}) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($Options{verbose});
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_Value - generic single-value option processing
#
sub opt_Value {
	my($Name,$Value) = @_;
	$Options{$Name} = $Value;
}


#
# opt_Array - generic multi-value optoin  processing
#
sub opt_Array {

	my($Name,$Value,undef) = @_;
	if (defined($Value) and length($Value)) {
		# Add this value to the array.
		push @{$Options{$Name}},$Value;
	}
	else {
		# Received "--opt=".  Empty this array.
		@{$Options{$Name}}=();
	}
}


#
# opt_O - Load an option set.
#
sub opt_O {
	my(undef,$Value) = @_;
	$Value = uc($Value);
	if (exists($Config{$Value})) {
		$Errors ++ unless GetOptionsFromString($Config{$Value},%OptionSpecifications);
	}
	else {
		warn qq<Warning: "$Value" not found in configuration file\n>;
	}
}


#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - desc

Usage:  $Prog [options] [virtname...] [options] [virtname...] ...
	$Prog -h

Options:

	--cd=path:			Change directories: virtual machine folders
					will be stored in this path.  Defaults to
					/var/lib/libvirt/images.
	--cycles|-C=n:			Cycles: keep n backups.
	--output="name":		Output: Where to write the output tar file.
					This may include % variables, which are 
					substituted as follows:
						%C - name of the virtual machine
						All others - as per strftime.
	--exclude=name			Exclude: exclude image files named
					"name" from backups.  Example:
						--exclude=swap.img
					Note that the directory is not 
					specified.  May be repeated.
	-m|--always-mail=mailid:	Mail: Send an execution report to this
					e-mail address.

	-M|--error-mail=mailid: 	Mail on error: Send an execution report
					to this e-mail address only if errors
					are detected.

	--after-state=(up|down|same):	Once the backup is complete, bring
					the machine up, leave it down, or
					return it to the same state it was
					in before the backup started (default).
	-p|--always-page=mailid: 	Page: Send a very brief message
					(suitable for a pager or text message)
					to this e-mail address when this job
					completes.

	-P|--error-page=mailid:		Page on error: Send a very brief message
					to this e-mail address if errors are
					detected in this job.

	-h|?|--help:			Help: display this panel

	-t|--test:			Test: echo commands instead of running
					them.

	-v|--verbose:			Verbose: echo commands before running
					them.  May be repeated to increase
					verbosity.  --test overrides --verbose.

					See "-s" above for unit specifications.

Parameters:
	virtname			One or more virtual machines names
					to backup.  If no virtual machines are
					listed, all virtual machines are
					backed up.

Example:

	$Prog 

Notes:
Bugs:

    1) The "--cycles" option creates a file name pattern to find prior backups.  
       This pattern has three limitations:

       a) When using % variables used by strftime to insert date/time information
          $Prog only knows how to make patterns for Y,y,m,d,H,M,S,G,g,I.  Backup files
          using other % specifications will not be deleted when they should.
       b) It's possible that non-backup files might match this pattern and be
          deleted.  For example, if your output specification is "--output=%H-%M.tar"
          (hour, dash, minute), the pattern will be ??-??.tar.  If you have
          a file called "xx-yy.tar" in the output directory, it will match the
          pattern and be deleted when it is the oldest backup and too many cycles
          are present.  This can be avoided by using a dedicated output directory
          to hold backups.
       c) Cycles don't work when the path includes a wildcard (e.g.
	  "--output=/media/main?/%H-%M.tar".

    2) The full path names of the files are removed in the tar file.  This can lead
       to a conflict if a virtual machine uses two different image file in different
       directory tries, but with the same file name (e.g. /var/lib/libvirt/data.img
       and /usr/local/vm/data.img).

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW	"^\s*Starting \S+ at \d+:\d+:\d+ on \S+, \d\d\d\d-\d\d-\d\d...\s*$"
SHOW    /^Job ended normally with status 0 and signal 0 - run time:/
SHOW    /^Test:/
SHOW    /^Executing:/
SHOW    /^Verbose:/
SHOW	/^\s*debug:/
SHOW	/^\s*$/
SHOW	"^\s*Backing up \S+ at \d\d\d\d-\d\d-\d\d \d+:\d\d:\d\d$"
SHOW	"^\s*Shutting down \S+"
IGNORE	"^\s*Domain \S+ is being shutdown$"
IGNORE	"^\s*Domain \S+ started$"
SHOW	"^\s*\S+ is already down.$"
SHOW	"^\s*Restarting \S+ at \d\d\d\d-\d\d-\d\d \d+:\d\d:\d\d"
SHOW	"^\s*\S+ started at \d\d\d\d-\d\d-\d\d \d+:\d\d:\d\d"
SHOW	"^\s*Backup of \S+ ended normally at \d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d$"
SHOW	"^\s*backup-vm ended normally.$"
IGNORE	"^\s*tar: \.: file changed as we read it$"
IGNORE	"^\s*WARNING: gnome-keyring:: couldn't connect to:"
SHOW	"^\s*error: Requested operation is not valid: USB device \S* is in use"
SHOW	"^\s*error: failed to start domain \S+$"
SHOW	"^\s*Backup of \S+ completed normally at ....-..-.. ..:..:..$"
# 
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
