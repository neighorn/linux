#!/usr/bin/perl

use strict;
use warnings;
use LogOutput;
#use ProcessOptions;
use Getopt::Long qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
use File::Find;
use Fcntl qw(:flock :mode :DEFAULT);
use File::Temp qw(mktemp);
use POSIX qw(strftime);
use IO::Socket;
use Data::Dumper;
$Data::Dumper::Pad = "Verbose:\t\t";

$ENV{PATH}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;                           # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
my $Errors=0;   	                # No errors so far.
#my $Syslog='user';                      # Name of Syslog facility.  '' for none.
my $BaseDir="/usr/local/etc";		# Set our base directory.
my $ConfigFile="$BaseDir/${Prog}.cfg";	# Name of config file.
our %Config;				# Data from the config file.
our %Options;				# Options settings.
our @Parms;				# List of non-option arguments.
our $Syslog = 'user';			# Log to the syslog.

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
our %OptionSpecifications=(
		'cd|b=s'		=>	\&opt_Value,
		'cycles|C=i'		=>	\&opt_Value,
		'debug|d'		=>	sub {$DB::AutoTrace=1;},
		'help|h|?!'		=>	\&opt_h,
		'always-mail|m=s'	=>	\&opt_Array,
		'error-mail|M=s'	=>	\&opt_Array,
		'option-set|O=s'	=>	\&opt_O,
		'always-page|p=s'	=>	\&opt_Array,
		'error-page|P=s'	=>	\&opt_Array,
		'test|t!'		=>	\&opt_Value,
		'verbose|v'		=>	sub {$Options{verbose} = (exists($Options{verbose})?$Options{verbose}+1:1)},
		'exclude|x=s'		=>	\&opt_Array,
);
#

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=uc($name);	# Name is not case sensitive.
		$settings=~s/\s+$//;	# Trim trailing spaces.
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
	if (!@ARGV && defined($Config{DEFAULTJOB}));

# Pre-process our command line, to get the options we need for LogOutput.
my @ARGVSave = @ARGV;		# Needed to reprocess command line later.
%Options=(verbose => 0);	# Initialize Options.
$Errors ++ unless (GetOptions(%OptionSpecifications));
if ($Errors) {
	print STDERR "Invalid command line options -- aborting.\n";
	exit 15;
}

# If there aren't any parameters here, back up everything.
if (@ARGV == 0) {
	foreach (`virsh list --all`) {
		next unless (/^\s*[\d-]+\s+(\S+)\s+\S/);
		push @ARGVSave,$1;
	}
}

@ARGV = @ARGVSave;		# Restore @ARGV for LogOutput and second GetOptions.
	
# Set up our logging and output filtering.
my $RunDate=`date +%m/%d`;
chomp $RunDate;
my $Subject;
if ($Options{subject}) {
	$Subject="$Options{subject}" ;
} elsif (@Parms >= 1) {
	$Subject="%* %m/%d %C %N " . join(', ',@Parms) . " %E %*%*%*" ;
} else {
	$Subject="%* %m/%d %C %N %E %*%*%*" ;
};

# Make sure some key items exist;
foreach (qw(always-mail error-mail always-page error-page)) {
	@{$Options{$_}} = () unless (exists($Options{$_}));
}
$Options{verbose} = 0 unless (exists($Options{verbose}));
$Options{logfile} = '' unless (exists($Options{logfile}));
my $LogOutputVerbose = ($Options{verbose} > 4?$Options{verbose}-4:0);

LogOutput({
	SYSLOG_FACILITY		=> $Syslog,
	MAIL_FILE		=> $Options{logfile},
	MAIL_FILE_PERMS		=> 0644,
	ALWAYS_MAIL_LIST	=> \@{$Options{"always-mail"}},
	ERROR_MAIL_LIST		=> \@{$Options{"error-mail"}},
	ALWAYS_PAGE_LIST	=> \@{$Options{"always-page"}},
	ERROR_PAGE_LIST		=> \@{$Options{"error-page"}},
	MAIL_SUBJECT		=> $Subject,
	VERBOSE			=> $LogOutputVerbose,
});

# Make another passh through the parm list.  This time, actually
# run backups when we come across parms.  Doing it this way lets
# the user turn options on and off for each kind of backup (e.g.
# change the exclude list per backup.
%Options = (
		cd => '/var/lib/libvirt/images',
		test => $Options{test},
		verbose => $Options{verbose}
);			# Reset Options to defaults for reprocessing.
$OptionSpecifications{'<>'} = \&ProcessBackup;
$Errors ++ unless (GetOptions(%OptionSpecifications));

#
# Wrap up.
#
if ($Errors) {
	warn "$Prog failed.\n";
} else {
	print "$Prog ended normally.\n";
}

exit( ($Errors?10:0) );


#
# ProcessBackup - Backup a VM
#
sub ProcessBackup {

	my $Target = shift;
	my $TargetDir = "$Options{cd}/$Target";
	print strftime("Starting $Target at %Y-%m-%d %T\n",localtime());

	# Can we find the directory?
	if ( ! -d "$TargetDir" ) {
		print "    Unable to locate $TargetDir -- backup skipped\n";
		return 16;
	}

	if (!chdir $TargetDir) {
		print STDERR "    Unable to cd to $TargetDir: $! -- backup skipped\n";
		return 15;
	}


	# Is it a known VM?
	RunDangerousCmd("virsh list --all | grep -q ' $Target '");
	print "debug: $?\n";
	if ( $? != 0 ) {
		print "    Unable to locate a virtual machine named $Target -- backup skipped\n";
		return 17;
	}

	# Clean up old backups if requested.
	if ($Options{cycles}) {
		if (open(my $FHLS,"ls -dt backup-[12][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9].tgz 2>/dev/null |")) {
	        	my $Count=0;
	        	while (<$FHLS>) {
				chomp;
	                	$Count++;
	                	RunDangerousCmd("rm -rf $_") if ($Count >= $Options{cycles});
	        	}
	        	close $FHLS;
	        }
		else {
			warn "Unable to open ls command: $! -- obsolete backups may not be deleted.\n";
		}
	}


	# Remember if it's running.
	my $WasRunning=IsRunning($Target);

	# If it's running, shut it down.
	if ( $WasRunning ) {
		# It's running.
		print "    Shutting down $Target" . ($Options{test}?" (test)\n":"\n");
		my $Count = 0;
		while (! $Options{test} and IsRunning($Target)) {
			last if ($Count++ > 24);
			RunDangerousCmd("virsh shutdown $Target")
				if ($Count % 12 == 1);
			sleep 5
		}
	}
	else {
		print "    $Target is already down.\n";
	}
	if (! $Options{test} and IsRunning($Target)) {
		print STDERR "    $Target failed to shutdown -- backup skipped\n";
		return 18;
	}

	# Run the backup.
	my $Cmd =
		  "tar -czf"
		. strftime(" backup-%Y-%m-%d.tgz",localtime())
		. " --exclude=*.tgz"
		. " --exclude=*.bak"
		. " --exclude=backup.*"
		;
	foreach (@{$Options{exclude}}) {
		$Cmd .= qq< --exclude "$_">;
	}
	$Cmd.=" .";
	RunDangerousCmd($Cmd);
	my $Status=$?;
	if ( $Status == 0 ) {
		print strftime("    Backup of $Target ended normally at %Y-%m-%d %T\n",localtime());
	}
	else {
		print STDERR "  Backup of $Target failed with status $Status\n";
	}

	# Start the VM back up if it was running.
	if ( $WasRunning ) {
		print strftime(
			  "    Restarting $Target at %Y-%m-%d %T"
				. ($Options{test}?" (test)\n":"\n")
				,localtime());
		RunDangerousCmd("virsh start $Target");
		sleep 10 unless ($Options{test});
		if (IsRunning($Target) or $Options{test}) {
			print strftime(
				  "    $Target started at %Y-%m-%d %T"
				. ($Options{test}?" (test)\n":"\n")
				,localtime());
		}
		else {
			print STDERR "    $Target failed to restart";
		}
	}
}



#
# IsRunning - is a VM running?
#
sub IsRunning {
	my $Target = shift;
	system("virsh list | grep -q ' $Target '");
	return ($?==0?1:0);
}


#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($Options{test}) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($Options{verbose});
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_Value - generic single-value option processing
#
sub opt_Value {
	my($Name,$Value) = @_;
	$Options{$Name} = $Value;
}


#
# opt_Array - generic multi-value optoin  processing
#
sub opt_Array {

	my($Name,$Value,undef) = @_;
	if (defined($Value) and length($Value)) {
		# Add this value to the array.
		push @{$Options{$Name}},$Value;
	}
	else {
		# Received "--opt=".  Empty this array.
		@{$Options{$Name}}=();
	}
}


#
# opt_O - Load an option set.
#
sub opt_O {
	my(undef,$Value) = @_;
	$Value = uc($Value);
	if (exists($Config{$Value})) {
		$Errors ++ unless GetOptionsFromString($Config{$Value},%OptionSpecifications);
	}
	else {
		warn qq<Warning: "$Value" not found in configuration file\n>;
	}
}


#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - desc

Usage:  $Prog [options] [virtname...] [options] [virtname...] ...
	$Prog -h

Options:

	--cd=path:			Change directories: virtual machine folders
					will be stored in this path.  Defaults to
					/var/lib/libvirt/images.
	--cycles|-C=n:			Cycles: keep n backups.
	--exclude=name			Exclude: exclude image files named
					"name" from backups.  Example:
						--exclude=swap.img
					Note that the directory is not 
					specified.  May be repeated.
	-m|--always-mail=mailid:	Mail: Send an execution report to this
					e-mail address.

	-M|--error-mail=mailid: 	Mail on error: Send an execution report
					to this e-mail address only if errors
					are detected.

	-p|--always-page=mailid: 	Page: Send a very brief message
					(suitable for a pager or text message)
					to this e-mail address when this job
					completes.

	-P|--error-page=mailid:		Page on error: Send a very brief message
					to this e-mail address if errors are
					detected in this job.

	-h|?|--help:			Help: display this panel

	-t|--test:			Test: echo commands instead of running
					them.

	-v|--verbose:			Verbose: echo commands before running
					them.  May be repeated to increase
					verbosity.  --test overrides --verbose.

					See "-s" above for unit specifications.

Parameters:
	virtname			One or more virtual machines names
					to backup.  If no virtual machines are
					listed, all virtual machines are
					backed up.

Example:

	$Prog 

Notes:

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW	"^\s*Starting \S+ at \d+:\d+:\d+ on \S+, \d\d\d\d-\d\d-\d\d...\s*$"
SHOW    /^Job ended normally with status 0 and signal 0 - run time:/
SHOW    /^Test:/
SHOW    /^Executing:/
SHOW    /^Verbose:/
SHOW	/^\s*debug:/
SHOW	/^\s*$/
SHOW	"^\s*Starting \S+ at \d\d\d\d-\d\d-\d\d \d+:\d\d:\d\d$"
SHOW	"^\s*Shutting down \S+"
IGNORE	"^\s*Domain \S+ is being shutdown$"
IGNORE	"^\s*Domain \S+ started$"
SHOW	"^\s*\S+ is already down.$"
SHOW	"^\s*Restarting \S+ at \d\d\d\d-\d\d-\d\d \d+:\d\d:\d\d"
SHOW	"^\s*\S+ started at \d\d\d\d-\d\d-\d\d \d+:\d\d:\d\d"
SHOW	"^\s*Backup of \S+ ended normally at \d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d$"
SHOW	"^\s*backup-vm ended normally.$"
IGNORE	"^\s*tar: \.: file changed as we read it$"
# 
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
