#!/usr/bin/perl

use strict;
use warnings;
use JobTools::LogOutput;
use Getopt::Long 2.38 qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
# override CORE::glob in current package
use File::Find;
use Fcntl qw(:flock :mode :DEFAULT);
use File::Temp qw(mktemp);
use POSIX qw(strftime);
use IO::Socket;
use Data::Dumper;
$Data::Dumper::Pad = "Verbose:        ";
use JobTools::Utils qw(:Opt LoadConfigFiles RunDangerousCmd Commify ExpandByteSize ExpandConfigList FormatElapsedTime);

$ENV{PATH}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;                           # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
my $Errors=0;   	                # No errors so far.
my $Syslog='user';                      # Name of Syslog facility.  '' for none.
my $BaseDir="/usr/local/etc";		# Set our base directory.
my @ConfigFiles=("$BaseDir/${Prog}.cfg");	# Name of config file.
our %Config;				# Data from the config file.
our %Options;				# Options settings.
our $OptionMode='';			# Are we preprocessing, or running for real?
my $MachineDirectory;			# Base directory for this dirvish item.
my %FileSystems;			# List of file systems we wrote to.
our @Parms;				# List of non-option arguments.

our $TotalSize;				# Global for Find/Found
our $TotalItems;			# Global for Find/Found
our $NewSize;				# Global for Find/Found
our $NewItems;				# Global for Find/Found

our $STATFH;
our $StatErrors = 0;			# Remember if we had stat errors.
my $JOBLOCK;				# File handle for a job lock file, if used.
my $SECTIONLOCK;			# File handle for a section lock file, if used.

our $StartTime = time();		# Primarily for ifbefore, imagename.
our $MaxVaultLength=0;			# Length of longest vault name, for formatting.
our @Banks;				# List of banks, from the config file.
our $CurrentMachine=0;			# nth machine being processed.
our $TotalMachines=0;			# How many machines will we back up?
our %ExcludeVaults;			# Hash of values provided by --exclude-vaults=xxx
our @Skipped;				# List of skipped machines.
our %JobDefs;				# Job definitions (target, options, sequence, etc.).
JobTools::Utils::init(config => \%Config, options => \%Options);

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
my %OptionSpecifications;
%OptionSpecifications=(
	'<>'			=>	sub {push @Parms,$_[0] if ($_[0]);},
	'always-page|p=s'	=>	\&OptArray,
	'always-mail|m=s'	=>	\&OptArray,
	'checksum|c!'		=>	\&OptFlag,
	'debug|d'		=>	sub {$DB::AutoTrace=1;},
	'dirvish|D=s'		=>	\&OptArray,
	'error-mail|M=s'	=>	\&OptArray,
	'error-page|P=s'	=>	\&OptArray,
	'exclude-vaults=s'	=>	\&OptArray,
	'expire=s'		=>	\&OptValue,
	'filter-file|F=s'	=>	\&OptArray,
	'help|h|?!'		=>	\&opt_h,
	'ifup!'			=>	\&OptFlag,
	'ifuptarget=s'		=>	\&OptValue,
	'ifbefore=s'		=>	\&OptValue,
	'imagename|image=s'	=>	\&OptValue,
	'ionice=s'		=>	\&OptValue,
	'jobinit|B=s'		=>	sub {OptArray(@_,'preserve-lists' => 1);},
	'joblockfile=s'		=>	\&OptValue,
	'logfile|L=s'		=>	\&OptValue,
	'min-size|s=s'		=>	\&opt_s,
	'max-size|S=s'		=>	\&opt_S,
	'max-fs-percent=i'	=>	\&OptValue,
	'option-set|O=s'	=>	sub {OptOptionSet(name => $_[1],optspec => \%OptionSpecifications);},
	'rename-vault=s'	=>	\&OptValue,
	'rerun|R:1'		=>	\&OptFlag,
	'retries|retry=i'	=>	\&OptValue,
	'sectionlockfile=s'	=>	\&OptSectionLockFile,
	'seq-default=i'		=>	\&OptValue,
	'seq-priority|seq-priorities=s'	=>	sub {OptValue(@_, append => 1);},
	'subject|N=s'		=>	\&OptValue,
	'statfile=s'		=>	\&OptValue,
	'test|t!'		=>	\&OptFlag,
	'verbose|v'		=>	\&OptFlag,
);

# Don't kill the job if the user disconnects.
$SIG{HUP} = "IGNORE";

# ---------------------------------------------------------
#
# Load the config file.
#
LoadConfigFiles(files => \@ConfigFiles);

# ---------------------------------------------------------
#
# Process the config file defaults if present.
#
# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
	if (!@ARGV && defined($Config{DEFAULTJOB}));

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));
@Banks = shellwords(($Config{BANKS}));	# Need this early for GetMachineDir.

# ---------------------------------------------------------
#
# Process the command line options.
#
my @ARGVSave = @ARGV;		# Needed to reprocess command line later.
$OptionMode = 'preprocess';	# Some options need to know if we're running or not.
%Options=(verbose => 0);	# Initialize Options.
$OptionSpecifications{'<>'}=\&GetNameLengths;	# Get max length of names.
$Errors ++ unless (GetOptions(%OptionSpecifications));
@ARGV = @ARGVSave;		# Restore @ARGV for LogOutput and second GetOptions.
$OptionMode = 'normal';		# We're done preprocessing.
foreach my $Vault (@{$Options{'exclude-vaults'}}) {
	foreach (split(/\s*,\s*/,$Vault)) {
		$ExcludeVaults{uc($_)}=1;
	}
}

# ---------------------------------------------------------
#
# Make sure some key items exist;
#
foreach (qw(always-mail error-mail always-page error-page)) {
	@{$Options{$_}} = () unless (exists($Options{$_}));
}
$Options{verbose} = 0 unless (exists($Options{verbose}));
$Options{logfile} = '' unless (exists($Options{logfile}));

# ---------------------------------------------------------
#
# Set our ionice value, if specified, so it applies to LogOutput's child too.
#
if ($Options{ionice}) {
	if ($Options{ionice} =~ /^(\d+)(\/\d+)?$/) {
		my ($Class,$ClassData) = ($1,$2);
		$ClassData =~ s/^\/// if (defined($ClassData) and $ClassData);
		RunDangerousCmd(
			"ionice -p $$ -c $Class" .
			($ClassData?" -n $ClassData":'')
		);
	}
	else {
		warn qq<Invalid value "$Options{ionice}" for --ionice -- ignored.\n>;
		$Errors++;
	}
}
	
# ---------------------------------------------------------
#
# Set up our logging and output filtering.
#
my $RunDate=`date +%m/%d`;
chomp $RunDate;
my $Subject;
if ($Options{subject}) {
	$Subject="$Options{subject}" ;
}
elsif (@Parms >= 1) {
	$Subject="%* %m/%d %C %N " . join(', ',@Parms) . " %E %*%*%*" ;
}
else {
	$Subject="%* %m/%d %C %N %E %*%*%*" ;
};

LogOutput({
	SYSLOG_FACILITY		=> $Syslog,
	MAIL_FILE		=> $Options{logfile},
	MAIL_FILE_PERMS		=> 0644,
	ALWAYS_MAIL_LIST	=> \@{$Options{"always-mail"}},
	ERROR_MAIL_LIST		=> \@{$Options{"error-mail"}},
	ALWAYS_PAGE_LIST	=> \@{$Options{"always-page"}},
	ERROR_PAGE_LIST		=> \@{$Options{"error-page"}},
	FILTER_FILE		=> $Options{"filter-file"},
	MAIL_SUBJECT		=> $Subject,
	VERBOSE			=> ($Options{verbose} > 4?$Options{verbose}-4:0),
});

# ---------------------------------------------------------
#
# Verify the command line.
#
unless (defined($Config{BANKS}) 
	and exists($Config{BANKS})
	and $Config{BANKS})
{
	warn "No BANKS defined in configuration file(s)\n";
	$Errors++;
}
if (!$TotalMachines) {
	warn "No machines specified for backup.\n";
	$Errors++;
}
exit 12 if ($Errors);

PrintStatsFile(strftime("%D %T $Prog started<br>",localtime()));
if ($Options{joblockfile}) {
	if ($Options{joblockfile} !~ /^[a-zA-Z\d._~+\/-]+$/) {
		print "Invalid character in job lock filename: $Options{joblockfile}\n";
		exit 3;
	}
	if (!open($JOBLOCK,'>>',$Options{joblockfile})) {
		print "Unable to create/open $Options{joblockfile}: $!\n";
		exit 11;
	}
	if (!flock($JOBLOCK, LOCK_EX | LOCK_NB)) {
		my @stat = stat($Options{joblockfile});
		my $mdate = strftime("%Y-%m-%d",localtime($stat[8]));
		$mdate = 'today' if ($mdate eq strftime("%Y-%m-%d",localtime(time())));
		print "Warning: Skipped this job due to a conflicting job in progress per "
			. qq<"$Options{joblockfile}" dated $mdate at >
			. strftime(
				"%H:%M:%S",
				localtime((stat($Options{joblockfile}))[8]))
			. "\n"
			;
		exit 11;
	}
}


foreach (@{$Options{jobinit}}) {
	# Run any initialization scripts.
	print "Running: $_\n";
	PrintStatsFile(strftime("%D %T Running initialization scripts<br>",localtime()));
	RunDangerousCmd($_) &&
		warn "$_ returned status $?: $!\n";
}

# Now we have to wipe the options (because we've collected things
# that may be sequence-sensitive), and reprocess them.  This time
# GetOptions will call QueueBackup for each non-option argument
# it finds, to gather the current back-up parameters and options for
# each vault, and place the collection on the queue.
%Options=(
	test		=> $Options{test},		# Make this global.
	verbose		=> $Options{verbose},		# Make this global.
	'seq-default'	=> $Options{'seq-default'},	# Make this global.
);
$Options{"max-fs-percent"} = 95 unless ($Options{"max-fs-percent"});
$Options{'seq-default'} = 32 unless ($Options{'seq-default'});

$OptionSpecifications{'<>'} = sub {QueueBackup(target => $_[0], config => \%Config, optspec => \%OptionSpecifications);};
$Errors++ unless GetOptions(%OptionSpecifications);

# Assign sequence priority overrides, if any.
my $Overrides = $Options{'seq-priority'};
while ($Overrides and $Overrides =~ /(\S+?)=(\d+)/) {
	my($TargetList,$Priority) = ($1,$2);
	$Overrides =~ s/^\S+?=\d+,*//;		# Trim off this one.
	foreach my $Target (split(',',$TargetList)) {
		if (exists($JobDefs{$Target})) {
			$JobDefs{$Target}{'seq-priority'} = $Priority;
			print "Verbose: Setting $Target sequence priority to $Priority\n" if ($Options{verbose} >= 4);
		}
		else {
			print "Ignoring sequence priority for $Target - target not part of this job.\n";
		}
	}
}
warn "Ignoring extraneous --seq-priority data: $Overrides\n" if ($Overrides);

# Now run the back-up in order based on entry sequence unless there were sequence overrides.
my @JobQueue = 
	sort{
		   $JobDefs{$a}{'seq-priority'} <=> $JobDefs{$b}{'seq-priority'}	# High-order sort on override priority.
		|| $JobDefs{$a}{'sequence'} <=> $JobDefs{$b}{'sequence'}		# Secondary sort on sequence.
	} keys(%JobDefs)
	;
print "Verbose: Job queue sequence: " . join(', ',@JobQueue) . "\n" if ($Options{verbose} >= 3);
foreach my $Target (@JobQueue) {
	my %SaveOptions = %Options;	# Back-up messes with this.  Make sure we can clean up afterwards.
	ProcessBackup($Target);
	%Options = %SaveOptions;	# Restore base options.
}

# List any skipped items.
print "$_" foreach (sort(@Skipped));

# Print the disk space report.
if (%FileSystems) {
	print "_"x60 . "\nDisk space report:\n";
	my $units = ($^O eq 'aix'?'g':'h');
	my $dfcmd="df -l -$units -P| grep -E '^(" . join('|',keys(%FileSystems)) . ")'";
	my @df = `$dfcmd`;
	foreach my $Line (@df) {
		if ( $Line =~ /^\s*Filesystem\s/) {
			# Header
			print $Line;
		}
		elsif ( $Line =~ /^\s*\S+\s+[\d.]+[TGMK]?\s+[\d.]+[TGMK]?\s+[\d.]+[TGMK]?\s+(\d+)%/ ) {
			# File system line:  /dev/mapper/system-dirvish  1.3T  1.1T  148G  89% /usr/local/dirvish
			if ($1 > $Options{"max-fs-percent"}) {
				# Over limit.  Add flag to end.
				chomp $Line;
				$Line = "$Line <- over " . $Options{"max-fs-percent"} . "%\n";
			}
			print $Line;
		}
		else {
			# This section alerts us to future bugs where the df output format has changed and
			# no longer triggers the file system percent tests.
			print "Unrecognized df line: $Line";
		}
	}	
	print "\n";
}

if ($Errors) {
	warn "$Prog failed.\n";
	PrintStatsFile(strftime("%D %T $Prog ended with errors.<br>",localtime()));
}
else {
	#print "$Prog ended normally.\n";
	PrintStatsFile(strftime("%D %T $Prog ended normally.<br>",localtime()));
}

close $STATFH if ($STATFH);
if ($JOBLOCK) {
	close $JOBLOCK;
	unlink $Options{joblockfile};
}
if ($SECTIONLOCK) {
	close $SECTIONLOCK;
	unlink $Options{sectionlockfile};
}

exit( ($Errors?10:0) );


#
# GetNameLengths - get the length of the longest vault for formatting purposes.
sub GetNameLengths {
	my $Vault = shift;
	$Vault = RenameVault($Vault);
	my $length = length($Vault);
	$MaxVaultLength = ($MaxVaultLength > $length?$MaxVaultLength:$length);
	$TotalMachines++;		# Count how many machines we'll back up.
}


#
# QueueBackup - gather all the options for this job and place them on the queue.
#
sub QueueBackup {

	my %Parms = @_;
	my $Target = $Parms{target};
	my %LocalOptSpec = %{$Parms{optspec}};	# Use local copy, so we can modify it.
	my $ConfigRef = $Parms{config};

        # Is this really a machine name, or a list of names?
	if ($ConfigRef->{$Target}) {
		foreach (ExpandConfigList($Target)) {
			QueueBackup(target => $_, config => $ConfigRef, optspec => \%LocalOptSpec);
		}
		return;
	}

	# Are we renaming the vault?
	$Target=RenameVault($Target);

	# Is this on our exclude list?
	if (exists($ExcludeVaults{uc($Target)})) {
		push @Skipped, sprintf("Skipped %-*s: found on exclude-vaults list.\n",$MaxVaultLength,$Target);
		return;
	};

	if (exists($JobDefs{$Target})) {
		push @Skipped, sprintf("Skipped %-*s: already queued for back-up in this job.\n",$MaxVaultLength,$Target);
		return;
	}

	# Load any machine-specific options from the config files.
	my $SeqDefault = $Options{'seq-default'};	# Get this before it potentially changes.
	my %SaveOptions = %Options;		# Need to save the current state, so we can put them back.
						# Can't just "local" %Option becacuase OptSpec already
						# has their addresses (apparently).
	delete $Options{'<>'};			# No recursive loops.
	my $VaultConfig = uc("vault=$Target");
	if ($ConfigRef->{$VaultConfig}) {
		$Errors ++ unless GetOptionsFromString($ConfigRef->{$VaultConfig},%LocalOptSpec);
	}

	$JobDefs{$Target} = {
		sequence	=> scalar(keys(%JobDefs)),	# Track the order queued - probably be the order run.
		options		=> {%Options},			# Store copy of current options.
		'seq-priority'	=> $SeqDefault,				# Set default sequence priority, in case we're resequencing.
	};

	%Options = %SaveOptions;		# Restore the options.	Don't want to include vault-specifics for next vault.
	return;
}


#
# ProcessBackup - run a particular backup
#
sub ProcessBackup {

	my $Target = shift;
	%Options = %{$JobDefs{$Target}{options}};

	my %NoRetries = (		# List of status codes where we don't retry on failure.
		224 => 1,		#    Image already exists.
	);

	PrintStatsFile(strftime("\n%D %T Starting $Target\n",localtime()));
	if ($Options{verbose} >= 4) {
		print "Verbose:	$Target options:\n";
		print Dumper(\%Options);
	}

	$MachineDirectory=GetMachineDirectory($Target,0);
	if (!$MachineDirectory) {
		return
	}

	# Document that we're starting a new target.
	$CurrentMachine++;
	print strftime("Starting $Target [$CurrentMachine/$TotalMachines] at %H:%M:%S on %A, %Y-%m-%d...\n",localtime());

	if (!chdir $MachineDirectory) {
		warn "Unable to CD to $MachineDirectory: $!\n";
		$Errors++;
		return;
	}
	
	# Check time-constraints.
	if ($Options{ifbefore}) {
		# We're only supposed to back this target up if it's before a certain time.
		if ($Options{ifbefore} =~ /^(\+)?(\d|[01]\d|2[0-3]):([0-5]\d)\s*$/) {
			my ($relative,$hours,$minutes) = ($1,$2,$3);
			if (
			       ($relative and time() > $StartTime+$hours*3600+$minutes*60)
				or (!$relative and strftime("%H:%M",localtime()) gt sprintf("%02d:%02d",$hours,$minutes))
			) {
				push @Skipped, sprintf(qq<Skipped %-*s: -- outside "--ifbefore" time constraints.\n>,$MaxVaultLength,$Target);
				return;
			}
		}
		else {
			warn "Invalid --ifbefore specification (\"$Options{ifbefore}\") -- ignored.\n";
			$Errors++;
			$Options{ifbefore}='';
		}
	} 

	# Check section locks if requested.
        if ($Options{sectionlockfile} and ! $SECTIONLOCK) {
		if (!open($SECTIONLOCK,'>>',$Options{sectionlockfile})) {
 	               print "Unable to create/open section lock file $Options{sectionlockfile}: $!\n";
			$Errors++;
                	return;
		}
        	if (!flock($SECTIONLOCK, LOCK_EX | LOCK_NB)) {
                	print qq<Warning: Skipped $Target due to a conflicting section in progress per "$Options{sectionlockfile}"\n>;
			$Errors++;
                	return;
		}
        }

	# Check host-up condition if requested.
	if ($Options{ifup}) {
		# We're only supposed to back this target up if it's reachable.
		# Did not supply one explicitly.  Use the client from the dirvish .conf file.
		my $branch = ($Target=~/\S+:(\S+%)/?$1:'default');
		my $CONFFH;
		my $ConfFile = "$MachineDirectory/dirvish/$branch.conf";
		my $Client;
		my $Tree;
		if (open($CONFFH,'<',$ConfFile)) {
			while (<$CONFFH>) {
				if ( /^\s*client:\s*(\S*@)?(\S+)/i ) {
					$Client=$2;
				}
				elsif ( /^\s*tree:\s*(\S+)/i ) {
					$Tree=$1;
				}
				last if ($Client and $Tree);
			}
		}
		else {
			warn "Unable to open $ConfFile: $!\n";
			$Errors++;
		}
		close $CONFFH;
		my $SOCKET;
		$Options{ifuptarget} = $Client unless ($Options{ifuptarget});	# Use client unless override if specified.
		if ($Client =~ /^(localhost|127.0.0.1)$/i) {
			# Localhost.  Make sure tree exists, to support automounts.
			if (! -e "$Tree/.") {
				push @Skipped, sprintf("Skipped %-*s: $Tree is not accessible.\n",$MaxVaultLength,$Target);
				return;
			}
			elsif ($Options{verbose}) {
				print "Verbose: Found $Client is up.  Proceeding with $Target backup.\n";
			}
		}
		elsif ($Options{ifuptarget}) {
			if ($SOCKET = IO::Socket::INET->new(PeerHost=>$Options{ifuptarget},PeerPort=>'ssh',Timeout=>5)) {
				print "Verbose:  $Options{ifuptarget} is accessible via ssh\n" if ($Options{verbose});
				close $SOCKET;
			}
			elsif ($SOCKET = IO::Socket::INET->new(PeerHost=>$Options{ifuptarget},PeerPort=>'rsync',Timeout=>5)) {
				print "Verbose:  $Options{ifuptarget} is accessible via rsync\n" if ($Options{verbose});
				close $SOCKET;
			}
			else {
				push @Skipped, sprintf("Skipped %-*s: $Options{ifuptarget} is unreachable.\n",$MaxVaultLength,$Target);
				return;
			}
		}
		else {
			warn "Unable to identify client for $Target -- assuming it is reachable\n";		
		}
	}
				

	# Make sure there's not another copy of us running against this.
	my $LockFile = "$MachineDirectory/dirvish/$Prog.lock";
	my $LOCK;
	if (!open($LOCK,'>>',$LockFile)) {
		warn "Unable to create/open $LockFile: $!";
		$Errors++;
		return;
	}
	if (!flock($LOCK, LOCK_EX | LOCK_NB)) {
		warn qq<Warning: Skipped $Target due to a conflicting backup in progress per "$LockFile"\n>;
		$Errors++;
		return;
	}

	# Is this a rerun?
	if ($Options{rerun}) {
		my $LS;
		if (open($LS,'ls -t |')) {
			# Find the newest directory that isn't dirvish.
			while (my $dir = <$LS>) {
				chomp $dir;
				next if ( $dir =~ /^dirvish$/);
				my $mode = (lstat($dir))[2];		# Get the mode. lstat detects symlinks.
				next unless (S_ISDIR($mode));		# Skip non-directories.
				next unless (-M "$dir" <= $Options{rerun});		# Skip older backups.
				next unless (-d "$dir/tree" || -f "$dir/log" || -f "$dir/log.tmp");
				my $trash = mktemp("./trash.XXXX");
				RunDangerousCmd("mv $dir $trash") && warn "Unable to rename '$dir' in response to -R: $!";
				RunDangerousCmd("echo rm -rf ./$trash | at now");
				last;
			}
			close $LS;
		}
		else {
			warn "Unable to launch ls to delete prior backup: $!";
		}
	}

	# Do we need to initialize this disk?  Need at least 1 tree and a hist file.
	my $Status = system('/bin/ls ./*/tree > /dev/null 2>&1');
	$Status = system('/bin/ls ./dirvish/*.hist > /dev/null 2>&1') if ($Status eq 0);
	my $Init = ($Status eq 0?'':'--init "--expire=+3 months"');	# Add --init if no trees.

	# Manage pass-through and other options.
	my $AdditionalOptions = '';
	$AdditionalOptions .= " --image=" . strftime($Options{imagename},localtime($StartTime))
		if ($Options{imagename});
	$AdditionalOptions .= " --expire=$Options{expire}"
		if ($Options{expire});
	$AdditionalOptions .= " --checksum"
		if ($Options{checksum});
	$AdditionalOptions .= ' ' . join(' ',@{$Options{dirvish}})
		if (exists($Options{dirvish}));

	# Run the back-up.
	my $TargetStartTime = time();
	$Status = RunDangerousCmd("dirvish --vault $Target $Init $AdditionalOptions");
	if ($Status == 0) {
		foreach (`ls -tr $MachineDirectory`) {
			chomp;
			my $Dir = "$MachineDirectory/$_";
			if (/^dirvish$/) {
				print "Verbose: skipping $_ - dirvish definitions\n" if ($Options{verbose} > 2);
			}
			elsif ( (! -d "$Dir") or ( -l "$Dir")) {
				print "Verbose: skipping $_ - not a directory\n" if ($Options{verbose} > 2);
			}
			elsif ( ! -f "$Dir/summary") {
				print "Verbose: skipping $_ - missing summary file\n" if ($Options{verbose} > 2);
			}
			elsif ((stat("$Dir/summary"))[9] < $TargetStartTime) {
				print "Verbose: skipping $_ - older backup\n" if ($Options{verbose} > 2);
			}
			else {
				Summarize($Target, $Dir, $TargetStartTime);
			}
		}
	}
	else {
		my $Signal = $Status & 127;
		my $RetCode = $Status >> 8;
		# Should we retry this job
		if (
			     !$Signal					# Don't retry on kills, segfaults, etc.
			and !$NoRetries{$Status}			# It's not on our don't-retry list
			and $Options{retries}				# We still have more retrys permitted
		) {
			push @JobQueue,$Target;
			my $times = $JobDefs{$Target}{options}->{retries};
			$times .= ($times == 1?' time':' times');	# Add "time" or "times" as appropriate.
			print "dirvish $Target backup failed with return code $RetCode and signal $Signal - will requeue up to $times\n";
			$JobDefs{$Target}{options}->{retries}--;	# Reduce count.
			$TotalMachines++;				# We just added another task.  Increase count.
			$JobDefs{$Target}{options}->{rerun}=.9		# Delete the prior run.
		}
		else {
			print "dirvish $Target backup failed with return code $RetCode and signal $Signal\n";
		}
		$Errors++;
	}

	# Clean up the lock file.
	unlink($LockFile);

	# Clean up the .hist file, so it doesn't grow forever.  This is non-critical.
	my $HistFile = `ls -t $MachineDirectory/dirvish/*.hist 2> /dev/null | head -1`;
	chomp $HistFile;
	my($OLDHIST,$NEWHIST);
	if (	    open($OLDHIST,'<',$HistFile) 
		and open($NEWHIST,'>',"$HistFile.tmp")
	) {
		while (<$OLDHIST>) {
		 	#2012-11-25-Sun	2012-11-20 18:41:28	daily	+3 months == 2013-02-20 17:02:45
			if (/^(\S+)\s+\d\d\d\d-\d\d-\d\d\s+\d\d:\d\d:\d\d\s+/) {
				# This is an image name.
				print $NEWHIST $_ if (-e "$MachineDirectory/$1");	# Write it if dir exists.
			}
			else {
				# This is a comment or something else.  Just keep it.
				print $NEWHIST $_;
			}
		}
		if (close $OLDHIST and close $NEWHIST) {
			RunDangerousCmd(qq<mv -f "$HistFile.tmp" "$HistFile">);
		};
	}
	close $OLDHIST if defined($OLDHIST);		# Failed open may still need close.
	close $NEWHIST if defined($NEWHIST);		# Failed open may still need close.
	
	# Remember this file system device for our space report.
	my $fs=`df -l -P $MachineDirectory | tail -1`;
	$fs =~ s/\s.*$//;	# Just need the device name.
	chomp $fs;
	$FileSystems{$fs}=1;
}


#
# RenameVault - modify the vault name if desired
#
sub RenameVault {
	my $Target = shift;
	if ($Options{'rename-vault'}) {
		# Yes.  Modify the target name.
		my $NewName = $Options{'rename-vault'};
		$NewName =~ s/%NAME%/$Target/g;
		return $NewName;
	}
	else {
		return $Target;
	}
}


#
# GetMachineDirectory - find the machine directory for a target.
#
sub GetMachineDirectory {
	my($Target,$Quiet) = @_;
	my $MachineDirectory = '';
	# Make sure they gave us a valid vault.
	if ($Target =~ m"^/") {
		# They gave us a full path.  See if it's valid.
		($MachineDirectory=$Target) =~ s":"/";
		$MachineDirectory =~ s"^(.*)[^/]*$"$1";
		$Target =~ s"^.*([^/]*$)"$1";
		if (! -d $MachineDirectory & ! $Quiet) {
			warn "$MachineDirectory not found\n";
			$Errors++;
		};
	}
	else {
		# No full path.  Hunt for it.
		foreach (@Banks) {
			if (-d "$_/$Target/dirvish") {
				$MachineDirectory = "$_/$Target";
				last;
			}
		}
		if (! $MachineDirectory & ! $Quiet) {
			warn "Unable to locate $Target in dirvish banks.\n";
			$Errors++;
		}
	}
	return $MachineDirectory;
}


#
# PrintStatsFile - write an HTML stats file for easy monitoring.
#
sub PrintStatsFile {

	return if ($StatErrors or ! $Options{statfile});
	if (defined($STATFH)) {
		# Rewind to the beginning.
		seek($STATFH,0,0);
	}
	else {
		# Not open yet.  Need to open and lock it.
		if (sysopen($STATFH,$Options{statfile},O_WRONLY|O_TRUNC|O_CREAT,0644)) {
			# Lock file.
			if (!flock($STATFH, LOCK_EX | LOCK_NB)) {
				warn qq<Unable to lock stat file "$Options{statfile}": $!\n>;
				close $STATFH;
				$STATFH=undef;
				$StatErrors++;
				return;
			}
		}
		else {
			warn "Unable to open $Options{statfile}: $!\n";
			close $STATFH;
			$STATFH=undef;
			$StatErrors++;
			return;
		}
	}
	chmod 0644,$Options{statfile};	# Sysopen doesn't change perms on existing files.

	# Write the header.  Use syswrite to avoid buffering, since we don't
	# close the file until the job is done.
	syswrite $STATFH,qq[
		<html>
			<head>
				<title>$Prog status</title>
				<meta HTTP-EQUIV="refresh" CONTENT="60">
			</head>
			<body>
				<font face="COURIER NEW" size=2>
];
	foreach (@_) {
		s/^\s*//;
		syswrite $STATFH,"$_<br><br>\n";
	}
	syswrite $STATFH,"\t\t\t\t</font>\n\t\t\t</body>\n\t\t</html>\n";
}


#
# Summarize - write a summary about this backup.
#
sub Summarize {
	my($Target,$Directory,$VaultStartTime) = @_;			# Current directory we're processing.
	# Document any errors in the execution report.
	if (!open(SUMMARY,'<', "$Directory/summary")) {
		warn "Unable to open $Directory/summary: $!\n";
	}
	else {
		my $LastLine='';
		while (<SUMMARY>) {
			$LastLine = $_ if (!/^\s*$/);
		}
		close SUMMARY;
		$LastLine =~ s/\s*Status:\s*//;
		$LastLine =~ s/\s*$//;
		if ($LastLine =~ /^success$|file vanished on sender/) {
			print "Status: $LastLine\n"
		}
		else {
			print "Unexpected summary status: $LastLine\n"
		}
	}
		
	# Calculate totals.
	$TotalItems=0;
	$TotalSize=0;
	$NewItems=0;
	$NewSize=0;
	find(\&FoundItem,"$Directory/tree");
	my $WarnText='';
	if ($Options{minsize} and $NewSize < $Options{minsize}) {
		$WarnText .= "    New item size of " . FormatSize($NewSize) . " falls below the alert threshold of " . FormatSize($Options{minsize}) . ".\n";
	}
	if ($Options{maxsize} and $NewSize > $Options{maxsize}) {
		$WarnText .= "    New item size of " . FormatSize($NewSize) . " exceeds the alert threshold of " . FormatSize($Options{maxsize}) . ".\n";
	}
	$TotalSize=FormatSize($TotalSize);
	$NewSize=FormatSize($NewSize);
	my $RunTime=FormatElapsedTime(time()-$VaultStartTime);
	my $length = length($Directory);
	printf "    %-*s : " . 
		"Total Items: %11s =%7s, " .
		"New Items: %9s =%7s, " .
		"Run Time: %8ss, " .
		"%s\n",
		$MaxVaultLength, $Target,
		Commify($TotalItems), $TotalSize ,
		Commify($NewItems), $NewSize , 
		$RunTime,
		$Directory,
		;
	print $WarnText if ($WarnText);
}


#
# FoundItem - process a found file
#
sub FoundItem {
	
	my($Links);			# Number of hardlinks.
	my($Size);			# Number of bytes.
	my($Name)=$File::Find::name;	# Name of tile.
	chomp;
	($Links,$Size)=(lstat($Name))[3,12];
	$Size = (defined($Size)?$Size*512:0);
	$TotalItems++;
	$TotalSize+=$Size;
	if (defined($Links) && $Links == 1) {
		$NewItems++;
		$NewSize+=$Size;
	}
}


#
# FormatSize - standardize formatting size.
#
sub FormatSize {

	my $Size = shift;
	my $Unit = 'B';
	foreach (qw(K M G T)) {
		if ($Size >= 1024) {
			$Size = $Size/1024;
			$Unit = $_;
		}
		else {
			last;
		}
	}
	$Size = sprintf("%.1f%s",$Size,$Unit);
	#$Size =~ s/\.0// if ($Size =~ /\d+\.0.$/);	# Normalize number.
	return $Size;
}


#
# opt_SectionLockFile - acquire a lock for subsequent vaults.
#
sub opt_SectionLockFile {
	my(undef,$Value) = @_;

	return if ($OptionMode eq 'preprocess');	# Not really running, yet.

	if ($SECTIONLOCK) {
		# Release any prior lock.
		close $SECTIONLOCK;
		unlink $Options{sectionlockfile};
	}

        if ($Value !~ /^[a-zA-Z\d._~+\/-]+$/) {
                print "Invalid character in section lock filename: $Value - ignored\n";
		$Options{sectionlockfile} = '';
		$Errors++;
        }
	else {
		$Options{sectionlockfile} = $Value;
	}
}


#
# opt_s - minimum size threshold
#
sub opt_s {
	my(undef,$Value) = @_;
	$Options{minsize} = ExpandByteSize($Value);
	if (! defined($Options{minsize}) ) {
		warn qq<Invalid value "$Value" for -s/--min-size.\n>;
		$Options{minsize} = 0;
	}
}



#
# opt_S - size threshold
#
sub opt_S {
	my(undef,$Value) = @_;
	$Options{maxsize} = ExpandByteSize($Value);
	if (! defined($Options{maxsize}) ) {
		warn qq<Invalid value "$Value" for -S/--max-size.\n>;
		$Options{maxsize} = 0;
	}
}



#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Run dirvish jobs

Usage:  $Prog [options] vault... [options] vault... ...
	$Prog -h

Options may be intermixed with vault names.  The following list of options
is divided into "Universal Options" and "Vault Options".  Universal options
are used at initialization time, and therefore affect all vaults regardless of
where the universal options appear in the command line.  Vault options apply
to ALL following vaults until changed.

Universal Options:
	-B|--jobinit=script:		Begin: Execute "script" before running
					the first vault backups.

        --exclude-vaults=list:		Exclude Vault: exclude a comma-separated
					list of vaults from back-ups.  When 
					the "vault" listed on the command line
					is actually an externally defined list
					of vaults, this option can be to drop
					selected items from that list.

	--joblockfile=filename		Prevent multiple runs of conflicting
					jobs by acquiring a lock on the
					specified file.
	-L|--logfile=filename
	-m|--always-mail=mailid:	Mail: Send an execution report to this
					e-mail address.

	-M|--error-mail=mailid: 	Mail on error: Send an execution report
					to this e-mail address only if errors
					are detected.

	-N|--subject=text:		Name: Set subject line to this.  Accepts
					variable subst.

	-p|--always-page=mailid: 	Page: Send a very brief message
					(suitable for a pager or text message)
					to this e-mail address when this job
					completes.

	-P|--error-page=mailid:		Page on error: Send a very brief message
					to this e-mail address if errors are
					detected in this job.

	--max-fs-percent=num		At the end of job, flag any file systems
					written to by the job that now exceed
					num % of capacity.  Defaults to 95.

	--seq-default=value		Default sequence prioritys.  Used by
					seq-priority.  Defaults to 32.
	--seq-priority=priorities	Resequence the order in which the vaults
					are backed up according to these 
					priorities.  "priorities" consists of
					one or more comma-separated strings of
					the form "X=Y".  X is one or more 
					vault names, separated by commas. Y is
					a number indicating the priority of 
					these vaults relative to others.  Vaults
					with lower values will run before vaults
					with higher values.  Default priority
					is 32 (or per --seq-default).  Example:
					  --seq-priority=a,b=50,c=750
					Running vaults a-f would result in the
					sequence a,b,d,e,f,c.  This option is
					used when the vault list comes from an
					external source (e.g. a standard "servers"
					list) that doesn't reflect the desired
					back-up order.

	-h|?|--help:			Help: display this panel

	-t|--test:			Test: echo commands instead of running
					them.

Vault Options:
	-c|--checksum:			Checksum: Pass "--checksum" through to
					the dirvish command.
	-D|--dirvish=parms:		Dirvish: Pass the following parameters
					and options directly to dirvish. 
					Spaces need to be escaped or quoted.
	--expire=value			Expire: pass "--expire=value" through
					to the dirvish command.
	-F|--filterfile=file		Filter file: use the following filter
					file to distinguish normal messages
					from errors.  The default is to use 
					the internal list.  See LogOutput.pm
					for a description of filter files
					and reserved file names.
	--ifbefore=[+]hh:mm:		Only run this backup if the 
					current time is before hh:mm.  Prefix
					the time with a + to restrict targets
					to times relative to the start of 
					dirvish-run.

	--ifup/--noifup			Only run this backup if the host is
					reachable.  Otherwise, note that the
					host was unreachable but don't generate
					an error.  For remote hosts, the host 
					is up if we can connect via ssh or rsync.
					For the local host, the host is up if the
					source directory tree exists, to support
					automount access to remote systems.
					--noifup cancels a prior --ifup.
	--ifuptarget=target		When used with --ifup, check if "target"
					is up.  The default is to use the
					"client" as specified in the vault's
					Dirvish .conf file.  Note: this should
					probably be used in the dirvish-run.cfg
                                        vault=xxx record rather than the command
                                        line.  Using it on the command line would
                                        then apply to all subsequent vaults until
                                        it is reset, which is not typically desired.
	--imagename=name		Interpret "name" with strftime and
	--image=name			the job start time, and then pass the
					resulting value to dirvish as
					--image=value.  This is used to 
					specify image names with the dirvish-run
					start date and time rather than that
					of the individual dirvish job.  This
					option avoids backup name collisions when
					a job unexpectedly runs across midnight.
					Use "-D '--imagename=value' to use
					dirvish job start times instead.

	--ionice=class(/classdata):	Run the backup with in ionice class
					"class", optionally specifying a
					class data value of "classdata".
						Ex: --ionice=2/4

	-O|--option-set=config:		Insert the "config" configuration
					options from the configuration files.

	--rename-vault=string:		Replace the supplied vault name with
					string.  Any occurrences of "%NAME%"
					within the string are replace with the
					originally supplied vault name.
						Ex: --rename-vault=%NAME%-offsite
					This is used primarily to allow a single
					list of names to be reused in various
					similarly named backup vaults.  For
					example, a configuration file containing:
						Servers: alpha beta 
					and a command line using it:
						dirvish-run -O servers --rename-vault=%NAME%-offsite -O servers
					would back up alpha, beta, alpha-offsite, beta-offsite
						
	-R|--rerun=[days]:		Rerun: delete the most recent backup, 
					provided that it is no more than "days"
					days old.  Days is optional, and 
					defaults to 1.

	--retry|retries=n		Retry: If the back-up fails, retry
					it n times (for a total of n+1
					attempts).  If multiple vaults
					are being backed up, retries
					will be attempted last.  Default is
					not to retry.

	-s|--min-size=size:		minimum Size: Issue a warning if the
					size of the new items are less than
					"size".  "size" is measured in bytes,
					but may be followed by a unit of "k",
					"m", "g", or "t" (case-insensitive)
					for kilo-, mega-, giga-, or tera-bytes.

	-S|--max-size=size:		maximum Size: Issue a warning if the
					size of the new items exceeds "size".
					See "-s" above for unit specifications.

        --sectionlockfile=file          Any subsequent vaults are skipped if 
                                        the specified lock file can't be
                                        locked.  The lockfile is released and
                                        deleted when this option is used
                                        again later in the command line (even
                                        if the file name is empty), and at the
                                        end of the job.

	-v|--verbose:			Verbose: echo commands before running
					them.  May be repeated to increase
					verbosity.  --test overrides --verbose.

Parameters:
	vault...:	One or more vault names.  Vault names may be fully 
			qualified, or else the directories listed in the 
			"BANKS:" setting in the configuration file are
			searched in sequence.  A branch name may be included.

Example:

	$Prog -s 10G -S 30G vault1 vault2 -S 20G vault3

In this example, -s 10G applies to all three vaults.  -S 30G applies to
vault1 and vault2, but is changed to -S20G for vault3.

Notes:

1) Options that take multiple values may be reset to an empty list by using
the long form of the name followed by an equal sign and a space.  For example:

    "dirvish-run --dirvish --checksum vault1 --dirvish= vault2".  

Vault1 will be run with the "--checksum" option passed to dirvish, but 
vault2 will be run without the --checksum option.

Configuration file:

The configuration file is located in /usr/local/etc/$Prog.cfg.  The file
syntax is a series of lines in the format:

name: data

"name" is an arbitrary name, is case insensitive, and starts in column 1.
data is a case-sensitivie string containing values associated with "name".

Reserved names are:
	Alljobs:	"data" is a list of command line options and paramters
			that are prepended to the command line.
	DefaultJob:	"data" is a list of command line options and parameters
			that are used if no command line options or parameters
			are specified.
	Banks:		"data" is a list of directories containing dirvish 
			backups.
	vault=<target>:	Any backup target may have specific command line
			options by listing its name as a "vault=name" value in
			a configuration file, and the options as the "data"
			portion.  Note that any option is accepted, but 
			only the vault options are effective.

Configuration File Example:
Alljobs:	-m sysadmin --subject "dirvish-run job report"
DefaultJob:	sys1 sys2 sys3
Banks:		/usr/local/dirvish /mnt/offsite/dirvish
vault=sys1:	-vvv

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
	11      :       Job file locked.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
IGNORE	"^\s*(file|directory) has vanished: "
IGNORE	"^\s*\*\*\* Execution cycle \d \*\*\*\s*$"
IGNORE	"^\s*\S+:\S+\s+.*\s+==\s+\d{4}-\d\d-\d\d \d\d:\d\d\s*$"
IGNORE	"^\s*All access is prohibited unless expressly authorized.$"
IGNORE	"^\s*cannot expire .* No unexpired good images$"
IGNORE	"^\s*Copyright \(c\) \d\d\d\d Water Technologies Inc.\s*$"
IGNORE	"^\s*Expiring\s"
IGNORE	"^\s*Ignoring sequence priority for \S+ - target not part of this job.$"
IGNORE	"^\s*job \d+ at "
IGNORE	"^\s*Job \S+.a will be run at ... ... .. ........ ... ....\.$"
IGNORE	"^\s*rsync error: unexplained error \(code 24\) at main.c\(1045\)\s*$"
IGNORE	"^\s*rsync warning: some files vanished before they could be transferred"
IGNORE	"^\s*rsync: open.* failed: No such file or directory"
IGNORE	"^\s*Starting \S+ \[\d+/\d+\] at \d+:\d+:\d+ on \S+, \d\d\d\d-\d\d-\d\d...\s*$"
IGNORE	"^\s*Status: success$"
IGNORE	"^\s*Status: warning \(24\) -- file vanished on sender$"
IGNORE	"^\s*VAULT:BRANCH\s+IMAGE\s+CREATED\s+EXPIRED\s*$"
IGNORE	"^\s*warning: commands will be executed using /bin/sh$"
LOGONLY	"^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY	/^Command: /
SHOW	"^\s*[-_]+\s*$"
SHOW	"^\s*\S+ skipped -- "
SHOW	"^\s*\S+\s*:\s+Total Items:\s+[\d,]+\s*=\s*\d+(\.\d)?[BKGMT],\s+New Items:\s+[\d,]+\s*=\s*\d+(\.\d)?[BKGMT],\s+Run Time:\s+[\d:]*\ds, \S"
SHOW	"^\s*\S+\s+[\d.]+[TGMK]\s+[\d.]+[TGMK]\s+[\d.]+[TGMK]\s+\d+%\s+\S+$"
SHOW	"^\s*dirvish error: branch \S+image \S+ failed$"
SHOW	"^\s*dirvish \S+ backup failed with return code \d+ and signal \d+ - will requeue up to \d+ times?$"
SHOW	"^\s*Disk space report:$"
SHOW	"^\s*Filesystem\s+Size\s+Used\s+Avail\s+Use%\s+Mounted on\s*$"
SHOW	"^\s*Running offsite back-ups to disk #\d+"
SHOW	"^\s*Running:"
SHOW	"^\s*Skipped \S+\s*:"
SHOW	/^\s*[a-zA-Z:]+ \d+ items backed up; \d+ are new.$/
SHOW	/^\s*debug:/
SHOW	/^\s*Unable to lock (stat|mail) file "\S+": Resource temporarily unavailable/
SHOW	/^\S+ ended normally with status 0 and signal 0 - run time:/
SHOW	/^Executing:/
SHOW	/^Test:/
SHOW	/^Verbose:/
SHOW  /^\s*$/
