#!/usr/bin/perl

use strict;
use warnings;
use LogOutput;
#use ProcessOptions;
use Getopt::Long 2.38 qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
# override CORE::glob in current package
use File::Find;
use Fcntl qw(:flock :mode :DEFAULT);
use File::Temp qw(mktemp);
use POSIX qw(strftime);
use IO::Socket;
use Data::Dumper;
$Data::Dumper::Pad = "Verbose:        ";

$ENV{PATH}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;                           # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
my $Errors=0;   	                # No errors so far.
my $Syslog='user';                      # Name of Syslog facility.  '' for none.
my $BaseDir="/usr/local/etc";		# Set our base directory.
my @ConfigFiles=("$BaseDir/${Prog}.cfg");	# Name of config file.
our %Config;				# Data from the config file.
our %Options;				# Options settings.
our $OptionMode='';			# Are we preprocessing, or running for real?
my $MachineDirectory;			# Base directory for this dirvish item.
my %FileSystems;			# List of file systems we wrote to.
our @Parms;				# List of non-option arguments.

our $TotalSize;				# Global for Find/Found
our $TotalItems;			# Global for Find/Found
our $NewSize;				# Global for Find/Found
our $NewItems;				# Global for Find/Found

our $STATFH;
our $StatErrors = 0;			# Remember if we had stat errors.
my $JOBLOCK;				# File handle for a job lock file, if used.
my $SECTIONLOCK;			# File handle for a section lock file, if used.

our $StartTime = time();		# Primarily for ifbefore, imagename.
our $MaxVaultLength=0;			# Length of longest vault name, for formatting.
our @Banks;				# List of banks, from the config file.
our $CurrentMachine=0;			# nth machine being processed.
our $TotalMachines=0;			# How many machines will we back up?
our %MachinesDone;			# List of machines we did, so we don't try them twice.

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
our %OptionSpecifications=(
		'<>'			=>	sub {push @Parms,shift;},
		'always-page|p=s'	=>	\&opt_Array,
		'always-mail|m=s'	=>	\&opt_Array,
		'debug|d'		=>	sub {$DB::AutoTrace=1;},
		'dirvish|D=s'		=>	\&opt_Array,
		'error-mail|M=s'	=>	\&opt_Array,
		'error-page|P=s'	=>	\&opt_Array,
		'expire=s'		=>	\&opt_Value,
		'filter-file|F=s'	=>	\&opt_Array,
		'help|h|?!'		=>	\&opt_h,
		'ifup!'			=>	\&opt_Value,
		'ifbefore=s'		=>	\&opt_Value,
		'imagename|image=s'		=>	\&opt_Value,
		'ionice=s'		=>	\&opt_Value,
		'jobinit|B=s'		=>	\&opt_Array,
		'joblockfile=s'		=>	\&opt_Value,
		'logfile|L=s'		=>	\&opt_Value,
		'min-size|s=s'		=>	\&opt_s,
		'max-size|S=s'		=>	\&opt_S,
		'max-fs-percent=i'	=>	\&opt_Value,
		'option-set|O=s'	=>	\&opt_O,
		'rerun|R:1'		=>	\&opt_Value,
		'sectionlockfile=s'	=>	\&opt_SectionLockFile,
		'subject|N=s'		=>	\&opt_Value,
		'statfile=s'		=>	\&opt_Value,
		'test|t!'		=>	\&opt_Value,
		'verbose|v'		=>	sub {$Options{verbose} = (exists($Options{verbose})?$Options{verbose}+1:1)},
);

# Don't kill the job if the user disconnects.
$SIG{HUP} = "IGNORE";

# Load the config file.
foreach (@ConfigFiles) {
	LoadConfigFile($_);
}
foreach (%Config) {s/\s*$//;};	# Trim off trailing spaces.

# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
	if (!@ARGV && defined($Config{DEFAULTJOB}));

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));
@Banks = shellwords(($Config{BANKS}));	# Need this early for GetMachineDir.

# Pre-process our command line, to get the options we need for LogOutput.
my @ARGVSave = @ARGV;		# Needed to reprocess command line later.
$OptionMode = 'preprocess';	# Some options need to know if we're running or not.
%Options=(verbose => 0);	# Initialize Options.
$OptionSpecifications{'<>'}=\&GetNameLengths;	# Get max length of names.
$Errors ++ unless (GetOptions(%OptionSpecifications));
@ARGV = @ARGVSave;		# Restore @ARGV for LogOutput and second GetOptions.
$OptionMode = 'normal';		# We're done preprocessing.

# Set our ionice value, if specified, so it applies to LogOutput's child too.
if ($Options{ionice}) {
	if ($Options{ionice} =~ /^(\d+)(\/\d+)?$/) {
		my ($Class,$ClassData) = ($1,$2);
		$ClassData =~ s/^\/// if (defined($ClassData) and $ClassData);
		RunDangerousCmd(
			"ionice -p $$ -c $Class" .
			($ClassData?" -n $ClassData":'')
		);
	}
	else {
		warn qq<Invalid value "$Options{ionice}" for --ionice -- ignored.\n>;
		$Errors++;
	}
}
	
# Set up our logging and output filtering.
my $RunDate=`date +%m/%d`;
chomp $RunDate;
my $Subject;
if ($Options{subject}) {
	$Subject="$Options{subject}" ;
}
elsif (@Parms >= 1) {
	$Subject="%* %m/%d %C %N " . join(', ',@Parms) . " %E %*%*%*" ;
}
else {
	$Subject="%* %m/%d %C %N %E %*%*%*" ;
};

# Make sure some key items exist;
foreach (qw(always-mail error-mail always-page error-page)) {
	@{$Options{$_}} = () unless (exists($Options{$_}));
}
$Options{verbose} = 0 unless (exists($Options{verbose}));
$Options{logfile} = '' unless (exists($Options{logfile}));
my $LogOutputVerbose = ($Options{verbose} > 4?$Options{verbose}-4:0);

LogOutput({
	SYSLOG_FACILITY		=> $Syslog,
	MAIL_FILE		=> $Options{logfile},
	MAIL_FILE_PERMS		=> 0644,
	ALWAYS_MAIL_LIST	=> \@{$Options{"always-mail"}},
	ERROR_MAIL_LIST		=> \@{$Options{"error-mail"}},
	ALWAYS_PAGE_LIST	=> \@{$Options{"always-page"}},
	ERROR_PAGE_LIST		=> \@{$Options{"error-page"}},
	FILTER_FILE		=> $Options{"filter-file"},
	MAIL_SUBJECT		=> $Subject,
	VERBOSE			=> $LogOutputVerbose,
});
die "No BANKS defined in configuration file(s)" 
	unless (defined($Config{BANKS}) 
		and exists($Config{BANKS})
		and $Config{BANKS});

PrintStatsFile(strftime("%D %T $Prog started<br>",localtime()));
if ($Options{joblockfile}) {
	if ($Options{joblockfile} !~ /^[a-zA-Z\d._~+\/-]+$/) {
		print "Invalid character in job lock filename: $Options{joblockfile}\n";
		exit 3;
	}
	if (!open($JOBLOCK,'>>',$Options{joblockfile})) {
		print "Unable to create/open $Options{joblockfile}: $!\n";
		exit 11;
	}
	if (!flock($JOBLOCK, LOCK_EX | LOCK_NB)) {
		my @stat = stat($Options{joblockfile});
		my $mdate = strftime("%Y-%m-%d",localtime($stat[8]));
		$mdate = 'today' if ($mdate eq strftime("%Y-%m-%d",localtime(time())));
		print "Skipped this job due to a conflicting job in progress per "
			. qq<"$Options{joblockfile}" dated $mdate at >
			. strftime(
				"%H:%M:%S",
				localtime((stat($Options{joblockfile}))[8]))
			. "\n"
			;
		exit 11;
	}
}

foreach (@{$Options{jobinit}}) {
	# Run any initialization scripts.
	print "Running: $_\n";
	PrintStatsFile(strftime("%D %T Running initialization scripts<br>",localtime()));
	RunDangerousCmd($_) &&
		warn "$_ returned status $?: $!\n";
}

# Now we have to wipe the options (because we've collected things
# that may be sequence-sensitive), and reprocess them.  This time
# GetOptions will call ProcessBackup for each non-option argument
# it finds, effectively running the backups.
%Options=(
	test => $Options{test},		# Make this global.
	verbose => $Options{verbose},	# Make this global.
);
$Options{"max-fs-percent"} = 95 unless ($Options{"max-fs-percent"});

$OptionSpecifications{'<>'} = \&ProcessBackup;
$Errors++ unless GetOptions(%OptionSpecifications);

# Print the disk space report.
if (%FileSystems) {
	print "_"x60 . "\nDisk space report:\n";
	my $units = ($^O eq 'aix'?'g':'h');
	my $dfcmd="df -$units -P| grep -E '^(" . join('|',keys(%FileSystems)) . ")'";
	my @df = `$dfcmd`;
	foreach my $Line (@df) {
		if ( $Line =~ /^\s*Filesystem\s/) {
			# Header
			print $Line;
		}
		elsif ( $Line =~ /^\s*\S+\s+[\d.]+[TGMK]?\s+[\d.]+[TGMK]?\s+[\d.]+[TGMK]?\s+(\d+)%/ ) {
			# File system line:  /dev/mapper/system-dirvish  1.3T  1.1T  148G  89% /usr/local/dirvish
			if ($1 > $Options{"max-fs-percent"}) {
				# Over limit.  Add flag to end.
				chomp $Line;
				$Line = "$Line <- over " . $Options{"max-fs-percent"} . "%\n";
			}
			print $Line;
		}
		else {
			# This section alerts us to future bugs where the df output format has changed and
			# no longer triggers the file system percent tests.
			print "Unrecognized df line: $Line";
		}
	}	
	print "\n";
}

if ($Errors) {
	warn "$Prog failed.\n";
	PrintStatsFile(strftime("%D %T $Prog ended with errors.<br>",localtime()));
} else {
	#print "$Prog ended normally.\n";
	PrintStatsFile(strftime("%D %T $Prog ended normally.<br>",localtime()));
}

close $STATFH if ($STATFH);
if ($JOBLOCK) {
	close $JOBLOCK;
	unlink $Options{joblockfile};
}
if ($SECTIONLOCK) {
	close $SECTIONLOCK;
	unlink $Options{sectionlockfile};
}

exit( ($Errors?10:0) );


#
# LoadConfigFile - load a configuration file
#
sub LoadConfigFile {
	my $ConfigFile = shift;
	if (-e $ConfigFile) {
		my $CONFIGFH;
		open($CONFIGFH,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
		# Build a hash of settings found in the config file.
		while (<$CONFIGFH>) {
			next if (/^\s*#/);      # Comment.
			next if (/^\s*$/);      # Blank line.
			chomp;
			my ($name,$settings)=split(/:?\s+/,$_,2);
			$name=uc($name);	# Name is not case sensitive.
			$settings='' unless ($settings);  # Avoid undef warnings.
			if ($name eq 'INCLUDE') {
				LoadConfigFile($settings);
			}
			else {
				$settings=~s/\s+$//;	# Trim trailing spaces.
				$Config{$name}.=$settings . ' ' ;
			}
		}
		close $CONFIGFH;
	}
}


#
# GetNameLengths - get the length of the longest vault for formatting purposes.
sub GetNameLengths {
	my $Vault = shift;
	my $length = length($Vault);
	$MaxVaultLength = ($MaxVaultLength > $length?$MaxVaultLength:$length);
	$TotalMachines++;		# Count how many machines we'll back up.
}


#
# ProcessBackup - run a particular backup
#
sub ProcessBackup {

	my $Target = shift;
	my $VaultStartTime = time();

	# Load any machine-specific options from the config files.
	my %TmpOptions = %Options;
	my %TmpOptSpec = %OptionSpecifications;
	local(%Options,%OptionSpecifications);
	%Options = %TmpOptions;
	%OptionSpecifications = %TmpOptSpec;
	$OptionSpecifications{'<>'} = '';	# No recursive loops.
	if ($Config{$Target}) {
		$Errors ++ unless GetOptionsFromString($Config{$Target},%OptionSpecifications);
	}

	if ($Options{verbose} >= 3) {
		print "Verbose:	Beginning backup of $Target.  Options:\n";
		print Dumper(\%Options);
	}
	PrintStatsFile(strftime("\n%D %T Starting $Target\n",localtime()));

	return unless($MachineDirectory=GetMachineDirectory($Target,0));

	if (exists($MachinesDone{$MachineDirectory})) {
		print qq<    $Target skipped -- already backed once in this job.\n>;
		return;
	}

	# Document that we're starting a new target.
	$CurrentMachine++;
	print strftime("Starting $Target [$CurrentMachine/$TotalMachines] at %H:%M:%S on %A, %Y-%m-%d...\n",localtime());

	if (!chdir $MachineDirectory) {
		warn "Unable to CD to $MachineDirectory: $!\n";
		$Errors++;
		return;
	}
	
	# Check time-constraints.
	if ($Options{ifbefore}) {
		# We're only supposed to back this target up if it's before a certain time.
		if ($Options{ifbefore} =~ /^(\+)?(\d|[01]\d|2[0-3]):([0-5]\d)\s*$/) {
			my ($relative,$hours,$minutes) = ($1,$2,$3);
			if (
			       ($relative and time() > $StartTime+$hours*3600+$minutes*60)
				or (!$relative and strftime("%H:%M",localtime()) gt sprintf("%02d:%02d",$hours,$minutes))
			) {
				print qq<    $Target skipped -- outside "--ifbefore" time constraints.\n>;
				return;
			}
		}
		else {
			warn "Invalid --ifbefore specification (\"$Options{ifbefore}\") -- ignored.\n";
			$Errors++;
			$Options{ifbefore}='';
		}
	} 

	# Check section locks if requested.
        if ($Options{sectionlockfile} and ! $SECTIONLOCK) {
		if (!open($SECTIONLOCK,'>>',$Options{sectionlockfile})) {
 	               print "Unable to create/open section lock file $Options{sectionlockfile}: $!\n";
			$Errors++;
                	return;
		}
        	if (!flock($SECTIONLOCK, LOCK_EX | LOCK_NB)) {
                	print qq<Skipped $Target due to a conflicting section in progress per "$Options{sectionlockfile}"\n>;
			$Errors++;
                	return;
		}
        }

	# Check host-up condition if requested.
	if ($Options{ifup}) {
		# We're only supposed to back this target up if it's reachable.
		my $branch = ($Target=~/\S+:(\S+%)/?$1:'default');
		my $CONFFH;
		my $ConfFile = "$MachineDirectory/dirvish/$branch.conf";
		my $Client;
		my $Tree;
		if (open($CONFFH,'<',$ConfFile)) {
			while (<$CONFFH>) {
				if ( /^\s*client:\s*(\S*@)?(\S+)/i ) {
					$Client=$2;
				}
				elsif ( /^\s*tree:\s*(\S+)/i ) {
					$Tree=$1;
				}
				last if ($Client and $Tree);
			}
		}
		else {
			warn "Unable to open $ConfFile: $!\n";
			$Errors++;
		}
		close $CONFFH;
		my $SOCKET;
		if ($Client =~ /^(localhost|127.0.0.1)$/i) {
			# Localhost.  Make sure tree exists, to support automounts.
			if (! -e $Tree) {
				print "Skipped $Target -- $Tree is not accessible.\n";
				return;
			}
		}
		elsif ($Client) {
			if ($SOCKET = IO::Socket::INET->new(PeerHost=>$Client,PeerPort=>'ssh',Timeout=>5)) {
				close $SOCKET;
			}
			elsif ($SOCKET = IO::Socket::INET->new(PeerHost=>$Client,PeerPort=>'rsync',Timeout=>5)) {
				close $SOCKET;
			}
			else {
				print "    $Target skipped -- $Client is unreachable.\n";
				return;
			}
		}
		else {
			warn "Unable to identify client for $Target -- assuming it is reachable\n";		
		}
	}
				

	# Make sure there's not another copy of us running against this.
	my $LockFile = "$MachineDirectory/dirvish/$Prog.lock";
	my $LOCK;
	if (!open($LOCK,'>>',$LockFile)) {
		warn "Unable to create/open $LockFile: $!";
		$Errors++;
		return;
	}
	if (!flock($LOCK, LOCK_EX | LOCK_NB)) {
		warn qq<Skipped $Target due to a conflicting backup in progress per "$LockFile"\n>;
		$Errors++;
		return;
	}

	# Is this a rerun?
	if ($Options{rerun}) {
		my $LS;
		if (open($LS,'ls -t |')) {
			# Find the newest directory that isn't dirvish.
			while (my $dir = <$LS>) {
				chomp $dir;
				next if ( $dir =~ /^dirvish$/);
				my $mode = (lstat($dir))[2];		# Get the mode. lstat detects symlinks.
				next unless (S_ISDIR($mode));		# Skip non-directories.
				next unless (-M "$dir" <= $Options{rerun});		# Skip older backups.
				next unless (-d "$dir/tree" || -f "$dir/log" || -f "$dir/log.tmp");
				my $trash = mktemp("./trash.XXXX");
				RunDangerousCmd("mv $dir $trash") && warn "Unable to rename '$dir' in response to -R: $!";
				RunDangerousCmd("echo rm -rf ./$trash | at now");
				last;
			}
			close $LS;
		}
		else {
			warn "Unable to launch ls to delete prior backup: $!";
		}
	}

	# Do we need to initialize this disk?  Need at least 1 tree and a hist file.
	my $Status = system('/bin/ls ./*/tree > /dev/null 2>&1');
	$Status = system('/bin/ls ./dirvish/*.hist > /dev/null 2>&1') if ($Status eq 0);
	my $Init = ($Status eq 0?'':'--init "--expire=+3 months"');	# Add --init if no trees.

	# Manage pass-through and other options.
	my $AdditionalOptions = '';
	$AdditionalOptions .= " --image=" . strftime($Options{imagename},localtime($StartTime))
		if ($Options{imagename});
	$AdditionalOptions .= " --expire=$Options{expire}"
		if ($Options{expire});
	$AdditionalOptions .= ' ' . join(' ',@{$Options{dirvish}})
		if (exists($Options{dirvish}));

	# Run the back-up.
	my $TargetStartTime = time();
	$Status = RunDangerousCmd("dirvish --vault $Target $Init $AdditionalOptions");
	if ($Status == 0) {
		foreach (`ls -tr $MachineDirectory`) {
			chomp;
			my $Dir = "$MachineDirectory/$_";
			if (/^dirvish$/) {
				print "Verbose: skipping $_ - dirvish definitions\n" if ($Options{verbose} > 2);
			}
			elsif ( (! -d "$Dir") or ( -l "$Dir")) {
				print "Verbose: skipping $_ - not a directory\n" if ($Options{verbose} > 2);
			}
			elsif ( ! -f "$Dir/summary") {
				print "Verbose: skipping $_ - missing summary file\n" if ($Options{verbose} > 2);
			}
			elsif ((stat("$Dir/summary"))[9] < $TargetStartTime) {
				print "Verbose: skipping $_ - older backup\n" if ($Options{verbose} > 2);
			}
			else {
				Summarize($Target, $Dir, $VaultStartTime);
			}
		}
	} else {
		print "dirvish failed with status $Status\n";
		$Errors++;
	}

	# Clean up the lock file.
	unlink($LockFile);

	# Remember we did this one.
	$MachinesDone{$MachineDirectory} = 1;
	
	# Remember this file system device for our space report.
	my $fs=`df -P $MachineDirectory | tail -1`;
	$fs =~ s/\s.*$//;	# Just need the device name.
	chomp $fs;
	$FileSystems{$fs}=1;
}


#
# GetMachineDirectory - find the machine directory for a target.
#
sub GetMachineDirectory {
	my($Target,$Quiet) = @_;
	my $MachineDirectory = '';
	# Make sure they gave us a valid vault.
	if ($Target =~ m"^/") {
		# They gave us a full path.  See if it's valid.
		($MachineDirectory=$Target) =~ s":"/";
		$MachineDirectory =~ s"^(.*)[^/]*$"$1";
		$Target =~ s"^.*([^/]*$)"$1";
		if (! -d $MachineDirectory & ! $Quiet) {
			warn "$MachineDirectory not found\n";
			$Errors++;
		};
	} else {
		# No full path.  Hunt for it.
		foreach (@Banks) {
			if (-d "$_/$Target/dirvish") {
				$MachineDirectory = "$_/$Target";
				last;
			}
		}
		if (! $MachineDirectory & ! $Quiet) {
			warn "Unable to locate $Target in dirvish banks.\n";
			$Errors++;
		}
	}
	return $MachineDirectory;
}


#
# PrintStatsFile - write an HTML stats file for easy monitoring.
#
sub PrintStatsFile {

	return if ($StatErrors or ! $Options{statfile});
	if (defined($STATFH)) {
		# Rewind to the beginning.
		seek($STATFH,0,0);
	}
	else {
		# Not open yet.  Need to open and lock it.
		if (sysopen($STATFH,$Options{statfile},O_WRONLY|O_TRUNC|O_CREAT,0644)) {
			# Lock file.
			if (!flock($STATFH, LOCK_EX | LOCK_NB)) {
				warn qq<Unable to lock stat file "$Options{statfile}": $!\n>;
				close $STATFH;
				$STATFH=undef;
				$StatErrors++;
				return;
			}
		}
		else {
			warn "Unable to open $Options{statfile}: $!\n";
			close $STATFH;
			$STATFH=undef;
			$StatErrors++;
			return;
		}
	}
	chmod 0644,$Options{statfile};	# Sysopen doesn't change perms on existing files.

	# Write the header.  Use syswrite to avoid buffering, since we don't
	# close the file until the job is done.
	syswrite $STATFH,qq[
		<html>
			<head>
				<title>$Prog status</title>
				<meta HTTP-EQUIV="refresh" CONTENT="60">
			</head>
			<body>
				<font face="COURIER NEW" size=2>
];
	foreach (@_) {
		s/^\s*//;
		syswrite $STATFH,"$_<br><br>\n";
	}
	syswrite $STATFH,"\t\t\t\t</font>\n\t\t\t</body>\n\t\t</html>\n";
}


#
# Summarize - write a summary about this backup.
#
sub Summarize {
	my($Target,$Directory,$VaultStartTime) = @_;			# Current directory we're processing.
	# Document any errors in the execution report.
	if (!open(SUMMARY,'<', "$Directory/summary")) {
		warn "Unable to open $Directory/summary: $!\n";
	}
	else {
		my $LastLine='';
		while (<SUMMARY>) {
			$LastLine = $_ if (!/^\s*$/);
		}
		close SUMMARY;
		$LastLine =~ s/\s*Status:\s*//;
		$LastLine =~ s/\s*$//;
		if ($LastLine =~ /^success$|file vanished on sender/) {
			print "Status: $LastLine\n"
		}
		else {
			print "Unexpected summary status: $LastLine\n"
		}
	}
		
	# Calculate totals.
	$TotalItems=0;
	$TotalSize=0;
	$NewItems=0;
	$NewSize=0;
	find(\&FoundItem,"$Directory/tree");
	my $WarnText='';
	if ($Options{minsize} and $NewSize < $Options{minsize}) {
		$WarnText .= "    New item size of " . FormatSize($NewSize) . " falls below the alert threshold of " . FormatSize($Options{minsize}) . ".\n";
	}
	if ($Options{maxsize} and $NewSize > $Options{maxsize}) {
		$WarnText .= "    New item size of " . FormatSize($NewSize) . " exceeds the alert threshold of " . FormatSize($Options{maxsize}) . ".\n";
	}
	$TotalSize=FormatSize($TotalSize);
	$NewSize=FormatSize($NewSize);
	my $RunTime=time()-$VaultStartTime;
	if ($RunTime == 0) {
		$RunTime = '       0';
	}
	else {
		my $RunHours=int($RunTime/3600);
		my $RunMin=int(($RunTime-$RunHours*3600)/60);
		my $RunSec=$RunTime%60;
		$RunTime = sprintf("%02d:%02d:%02d",$RunHours,$RunMin,$RunSec);
		$RunTime =~ s/^\s*[0:]+//g;
	}
	my $length = length($Directory);
	printf "    %-*s : " . 
		"Total Items: %9s =%7s, " .
		"New Items: %9s =%7s, " .
		"Run Time: %8ss, " .
		"%s\n",
		$MaxVaultLength, $Target,
		commify($TotalItems), $TotalSize ,
		commify($NewItems), $NewSize , 
		$RunTime,
		$Directory,
		;
	print $WarnText if ($WarnText);
}


#
# FoundItem - process a found file
#
sub FoundItem {
	
	my($Links);			# Number of hardlinks.
	my($Size);			# Number of bytes.
	my($Name)=$File::Find::name;	# Name of tile.
	chomp;
	($Links,$Size)=(lstat($Name))[3,12];
	$Size = (defined($Size)?$Size*512:0);
	$TotalItems++;
	$TotalSize+=$Size;
	if (defined($Links) && $Links == 1) {
		$NewItems++;
		$NewSize+=$Size;
	}
}


#
# FormatSize - standardize formatting size.
#
sub FormatSize {

	my $Size = shift;
	my $Unit = 'B';
	foreach (qw(K M G T)) {
		if ($Size >= 1024) {
			$Size = $Size/1024;
			$Unit = $_;
		}
		else {
			last;
		}
	}
	$Size = sprintf("%.1f%s",$Size,$Unit);
	#$Size =~ s/\.0// if ($Size =~ /\d+\.0.$/);	# Normalize number.
	return $Size;
}


#
# commify - insert commas in numbers.
#
sub commify {
	local $_ = shift;
	1 while s/^(-?\d+)(\d{3})/$1,$2/;
	return $_;
}

#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($Options{test}) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($Options{verbose});
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_Value - generic single-value option processing
#
sub opt_Value {
	my($Name,$Value) = @_;
	$Options{$Name} = $Value;
}


#
# opt_Array - generic multi-value option processing
#
sub opt_Array {

	my($Name,$Value,undef) = @_;
	if (defined($Value) and length($Value)) {
		# Add this value to the array.
		push @{$Options{$Name}},$Value;
	}
	else {
		# Received "--opt=".  Empty this array.
		@{$Options{$Name}}=();
	}
}


#
# opt_O - Load an option set.
#
sub opt_O {
	my(undef,$Value) = @_;
	$Value = uc($Value);
	if (exists($Config{$Value})) {
		$Errors ++ unless GetOptionsFromString($Config{$Value},%OptionSpecifications);
	}
	else {
		warn qq<Warning: "$Value" not found in configuration file\n>;
	}
}


#
# opt_SectionLockFile - acquire a lock for subsequent vaults.
#
sub opt_SectionLockFile {
	my(undef,$Value) = @_;

	return if ($OptionMode eq 'preprocess');	# Not really running, yet.

	if ($SECTIONLOCK) {
		# Release any prior lock.
		close $SECTIONLOCK;
		unlink $Options{sectionlockfile};
	}

        if ($Value !~ /^[a-zA-Z\d._~+\/-]+$/) {
                print "Invalid character in section lock filename: $Value - ignored\n";
		$Options{sectionlockfile} = '';
		$Errors++;
        }
	else {
		$Options{sectionlockfile} = $Value;
	}
}


#
# opt_s - minimum size threshold
#
sub opt_s {
	my(undef,$Value) = @_;
	$Options{minsize} = ExpandSize($Value);
	if (! defined($Options{minsize}) ) {
		warn qq<Invalid value "$Value" for -s/--min-size.\n>;
		$Options{minsize} = 0;
	}
}



#
# opt_S - size threshold
#
sub opt_S {
	my(undef,$Value) = @_;
	$Options{maxsize} = ExpandSize($Value);
	if (! defined($Options{maxsize}) ) {
		warn qq<Invalid value "$Value" for -S/--max-size.\n>;
		$Options{maxsize} = 0;
	}
}



#
# ExpandSize - convert various number formats to an integer.
#
sub ExpandSize {
	my $Value = shift;
        $Value =~ s/,//g;               # Ignore commas.
        if ($Value =~ /^(\d+)$/i) {
                return $1;
        }
        elsif ($Value =~ /^(\d+)K$/i) {
                return $1*1024;
        }
        elsif ($Value =~ /^(\d+)M$/i) {
                return $1*1024*1024;
        }
        elsif ($Value =~ /^(\d+)G$/i) {
                return $1*1024*1024*1024;
        }
        elsif ($Value =~ /^(\d+)T$/i) {
                return $1*1024*1024*1024*1024;
        }
        else {
                return undef;
        }
}



#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Run dirvish jobs

Usage:  $Prog [options] vault... [options] vault... ...
	$Prog -h

Options may be intermixed with vault names.  The following list of options
is divided into "Universal Options" and "Vault Options".  Universal options
are used at initialization time, and therefore affect all vaults regardless of
where the universal options appear in the command line.  Vault options apply
to ALL following vaults until changed.

Universal Options:
	-B|--jobinit=script:		Begin: Execute "script" before running
					the first vault backups.

	--joblockfile=filename		Prevent multiple runs of conflicting
					jobs by acquiring a lock on the
					specified file.
	-L|--logfile=filename
	-m|--always-mail=mailid:	Mail: Send an execution report to this
					e-mail address.

	-M|--error-mail=mailid: 	Mail on error: Send an execution report
					to this e-mail address only if errors
					are detected.

	-N|--subject=text:		Name: Set subject line to this.  Accepts
					variable subst.

	-p|--always-page=mailid: 	Page: Send a very brief message
					(suitable for a pager or text message)
					to this e-mail address when this job
					completes.

	-P|--error-page=mailid:		Page on error: Send a very brief message
					to this e-mail address if errors are
					detected in this job.

	--max-fs-percent=num		At the end of job, flag any file systems
					written to by the job that now exceed
					num % of capacity.  Defaults to 95.

	-h|?|--help:			Help: display this panel

	-t|--test:			Test: echo commands instead of running
					them.

Vault Options:
	-D|--dirvish=parms:		Dirvish: Pass the following parameters
					and options directly to dirvish. 
					Spaces need to be escaped or quoted.
	--expire=value			Expire: pass "--expire=value" through
					to the dirvish command.
	-F|--filterfile=file		Filter file: use the following filter
					file to distinguish normal messages
					from errors.  The default is to use 
					the internal list.  See LogOutput.pm
					for a description of filter files
					and reserved file names.
	--ifbefore=[+]hh:mm:	Only run this backup if the 
					current time is before hh:mm.  Prefix
					the time with a + to restrict targets
					to times relative to the start of 
					dirvish-run.

	--ifup/--noifup			Only run this backup if the host is
					reachable.  Otherwise, note that the
					host was unreachable but don't generate
					an error.  For remote hosts, the host 
					is up if we can connect via ssh or rsync.
					For the local host, the host is up if the
					source directory tree exists, to support
					automount access to remote systems.
					--noifup cancels a prior --ifup.

	--imagename=name		Interpret "name" with strftime and
	--image=name			the job start time, and then pass the
					resulting value to dirvish as
					--image=value.  This is used to 
					specify image names with the dirvish-run
					start date and time rather than that
					of the individual dirvish job.  This
					option avoids backup name collisions when
					a job unexpectedly runs across midnight.
					Use "-D '--imagename=value' to use
					dirvish job start times instead.

	--ionice=class(/classdata):	Run the backup with in ionice class
					"class", optionally specifying a
					class data value of "classdata".
						Ex: --ionice=2/4

	-O|--option-set=config:		Insert the "config" configuration
					options from the configuration files.

	-R|--rerun=[days]:		Rerun: delete the most recent backup, 
					provided that it is no more than "days"
					days old.  Days is optional, and 
					defaults to 1.

	-s|--min-size=size:		minimum Size: Issue a warning if the
					size of the new items are less than
					"size".  "size" is measured in bytes,
					but may be followed by a unit of "k",
					"m", "g", or "t" (case-insensitive)
					for kilo-, mega-, giga-, or tera-bytes.

	-S|--max-size=size:		maximum Size: Issue a warning if the
					size of the new items exceeds "size".
					See "-s" above for unit specifications.

        --sectionlockfile=file          Any subsequent vaults are skipped if 
                                        the specified lock file can't be
                                        locked.  The lockfile is released and
                                        deleted when this option is used
                                        again later in the command line (even
                                        if the file name is empty), and at the
                                        end of the job.

	-v|--verbose:			Verbose: echo commands before running
					them.  May be repeated to increase
					verbosity.  --test overrides --verbose.

Parameters:
	vault...:	One or more vault names.  Vault names may be fully 
			qualified, or else the directories listed in the 
			"BANKS:" setting in the configuration file are
			searched in sequence.  A branch name may be included.

Example:

	$Prog -s 10G -S 30G vault1 vault2 -S 20G vault3

In this example, -s 10G applies to all three vaults.  -S 30G applies to
vault1 and vault2, but is changed to -S20G for vault3.

Notes:

1) Options that take multiple values may be reset to an empty list by using
the long form of the name followed by an equal sign and a space.  For example:

    "dirvish-run --dirvish --checksum vault1 --dirvish= vault2".  

Vault1 will be run with the "--checksum" option passed to dirvish, but 
vault2 will be run without the --checksum option.

Configuration file:

The configuration file is located in /usr/local/etc/$Prog.cfg.  The file
syntax is a series of lines in the format:

name: data

"name" is an arbitrary name, is case insensitive, and starts in column 1.
data is a case-sensitivie string containing values associated with "name".

Reserved names are:
	Alljobs:	"data" is a list of command line options and paramters
			that are prepended to the command line.
	DefaultJob:	"data" is a list of command line options and parameters
			that are used if no command line options or parameters
			are specified.
	Banks:		"data" is a list of directories containing dirvish 
			backups.
	<target>:	Any backup target may have specific command line
			options by listing its name as a "name" value in
			a configuration file, and the options as the "data"
			portion.  Note that any option is accepted, but 
			only the vault options are effective.

Configuration File Example:
Alljobs:	-m sysadmin --subject "dirvish-run job report"
DefaultJob:	sys1 sys2 sys3
Banks:		/usr/local/dirvish /mnt/offsite/dirvish
sys1:		-vvv

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
	11      :       Job file locked.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW	"^\s*[-_]+\s*$"
IGNORE	"^\s*Starting \S+ \[\d+/\d+\] at \d+:\d+:\d+ on \S+, \d\d\d\d-\d\d-\d\d...\s*$"
SHOW	/^\s*Unable to lock (stat|mail) file "\S+": Resource temporarily unavailable/
# Ignore dirvish-expire messages
IGNORE	"^\s*Expiring\s"
IGNORE	"^\s*VAULT:BRANCH\s+IMAGE\s+CREATED\s+EXPIRED\s*$"
IGNORE	"^\s*cannot expire .* No unexpired good images$"
IGNORE	"^\s*\S+:\S+\s+.*\s+==\s+\d{4}-\d\d-\d\d \d\d:\d\d\s*$"
#
SHOW	"^\s*\S+\s*:\s+Total Items:\s+[\d,]+\s*=\s*\d+(\.\d)?[BKGMT],\s+New Items:\s+[\d,]+\s*=\s*\d+(\.\d)?[BKGMT],\s+Run Time:\s+[\d:]*\ds, \S"
SHOW	/^\s*[a-zA-Z:]+ \d+ items backed up; \d+ are new.$/
# The disk space report is normal unless capacity reaches 90% full.
SHOW	"^\s*Disk space report:$"
SHOW	"^\s*Filesystem\s+Size\s+Used\s+Avail\s+Use%\s+Mounted on\s*$"
#/dev/mapper/system-dirvish  1.3T  1.1T  148G  89% /usr/local/dirvish
SHOW	"^\s*\S+\s+[\d.]+[TGMK]\s+[\d.]+[TGMK]\s+[\d.]+[TGMK]\s+\d+%\s+\S+$"
IGNORE	"^\s*\*\*\* Execution cycle \d \*\*\*\s*$"
IGNORE	"^\s*Copyright \(c\) \d\d\d\d Water Technologies Inc.\s*$"
IGNORE	"^\s*All access is prohibited unless expressly authorized.$"
# Unexplained error 24 is "file vanished".  Ok if remote files are deleted while we run.
IGNORE	"^\s*rsync error: unexplained error \(code 24\) at main.c\(1045\)\s*$"
IGNORE	"^\s*rsync warning: some files vanished before they could be transferred"
IGNORE	"^\s*rsync: open.* failed: No such file or directory"
IGNORE	"^\s*(file|directory) has vanished: "
IGNORE	"^\s*Status: warning \(24\) -- file vanished on sender$"
IGNORE	"^\s*Status: success$"
SHOW	"^\s*Skipped \S+ -- .* is not accessible.$"
SHOW	"^\s*\S+ skipped -- "
SHOW	"^\s*Running:"
SHOW	"^\s*Running offsite back-ups to disk #\d+"
IGNORE	"^\s*warning: commands will be executed using /bin/sh$"
IGNORE	"^\s*job \d+ at "
IGNORE  "^\s*Job \S+.a will be run at ... ... .. ........ ... ....\.$"
SHOW    /^\S+ ended normally with status 0 and signal 0 - run time:/
SHOW    /^Test:/
SHOW    /^Executing:/
SHOW    /^Verbose:/
SHOW	/^\s*debug:/
SHOW  /^\s*$/
# 
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
