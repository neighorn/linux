#!/usr/bin/perl

use strict;
use warnings;
use LogOutput;
#use ProcessOptions;
use Getopt::Long qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
# override CORE::glob in current package
use File::Find;
use Fcntl qw(:flock :mode :DEFAULT);
use File::Temp qw(mktemp);
use POSIX qw(strftime);
use Data::Dumper;
$Data::Dumper::Pad = "Verbose:\t\t";

$ENV{PATH}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;                           # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
my $Errors=0;   	                # No errors so far.
my $Syslog='user';                      # Name of Syslog facility.  '' for none.
my $BaseDir="/usr/local/etc";		# Set our base directory.
my $ConfigFile="$BaseDir/${Prog}.cfg";	# Name of config file.
our %Config;				# Data from the config file.
our %Options;				# Options settings.
my $MachineDirectory;			# Base directory for this dirvish item.
my %FileSystems;			# List of file systems we wrote to.
our @Parms;				# List of non-option arguments.

our $TotalSize;				# Global for Find/Found
our $TotalItems;			# Global for Find/Found
our $NewSize;				# Global for Find/Found
our $NewItems;				# Global for Find/Found

our $STATFH;
our $StatErrors = 0;			# Remember if we had stat errors.

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
our %OptionSpecifications=(
		'<>'			=>	sub {push @Parms,shift;},
		'debug|d'		=>	sub {$DB::AutoTrace=1;},
		'dirvish|D=s'		=>	\&opt_Array,
		'jobinit|B=s'		=>	\&opt_Array,
		'help|h|?!'		=>	\&opt_h,
		'always-mail|m=s'	=>	\&opt_Array,
		'error-mail|M=s'	=>	\&opt_Array,
		'subject|N=s'		=>	sub {$Options{subject}=$_[1];},
		'option-set|O=s'	=>	\&opt_O,
		'always-page|p=s'	=>	\&opt_Array,
		'error-page|P=s'	=>	\&opt_Array,
		'rerun|R:1'		=>	sub {$Options{rerun}=$_[1];},
		'min-size|s=s'		=>	\&opt_s,
		'max-size|S=s'		=>	\&opt_S,
		'statfile=s'		=>	sub {$Options{statfile}=$_[1];},
		'test|t!'		=>	sub {$Options{test}=$_[1];},
		'logfile|L=s'		=>	sub {$Options{logfile}=$_[1];},
		'verbose|v'		=>	sub {$Options{verbose} = (exists($Options{verbose})?$Options{verbose}+1:1)},
);
#

# Note: general purpose script - don't change current directory.
#chdir $BaseDir || die "Unable to change directories to $BaseDir: $!\n";

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=uc($name);	# Name is not case sensitive.
		$settings=~s/\s+$//;	# Trim trailing spaces.
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
	if (!@ARGV && defined($Config{DEFAULTJOB}));

# Pre-process our command line, to get the options we need for LogOutput.
my @ARGVSave = @ARGV;		# Needed to reprocess command line later.
%Options=(verbose => 0);	# Initialize Options.
$Errors ++ unless (GetOptions(%OptionSpecifications));
@ARGV = @ARGVSave;		# Restore @ARGV for LogOutput and second GetOptions.
	
# Set up our logging and output filtering.
my $RunDate=`date +%m/%d`;
chomp $RunDate;
my $Subject;
if ($Options{subject}) {
	$Subject="$Options{subject}" ;
} elsif (@Parms >= 1) {
	$Subject="%* %m/%d %C %N " . join(', ',@Parms) . " %E %*%*%*" ;
} else {
	$Subject="%* %m/%d %C %N %E %*%*%*" ;
};

# Make sure some key items exist;
foreach (qw(always-mail error-mail always-page error-page)) {
	@{$Options{$_}} = () unless (exists($Options{$_}));
}
$Options{verbose} = 0 unless (exists($Options{verbose}));
$Options{logfile} = '' unless (exists($Options{logfile}));

LogOutput({
	SYSLOG_FACILITY		=> $Syslog,
	MAIL_FILE		=> $Options{logfile},
	ALWAYS_MAIL_LIST	=> \@{$Options{"always-mail"}},
	ERROR_MAIL_LIST		=> \@{$Options{"error-mail"}},
	ALWAYS_PAGE_LIST	=> \@{$Options{"always-page"}},
	ERROR_PAGE_LIST		=> \@{$Options{"error-page"}},
	MAIL_SUBJECT		=> $Subject,
});
die "No BANKS defined in configuration file(s)" 
	unless (defined($Config{BANKS}) 
		and exists($Config{BANKS})
		and $Config{BANKS});
my @Banks = shellwords(($Config{BANKS}));

PrintStatsFile(strftime("%D %T $Prog started<br>",localtime()));

foreach (@{$Options{jobinit}}) {
	# Run any initialization scripts.
	print "Running: $_\n";
	PrintStatsFile(strftime("%D %T Running initialization scripts<br>",localtime()));
	RunDangerousCmd($_) &&
		die "$_ returned status $?: $!\n";
}

# Now we have to wipe the options (because we've collected things
# that may be sequence-sensitive), and reprocess them.  This time
# GetOptions will call ProcessBackup for each non-option argument
# it finds, effectively running the backups.
%Options=(verbose => 0);	# Reinitialize Options.
$OptionSpecifications{'<>'} = \&ProcessBackup;
$Errors++ unless GetOptions(%OptionSpecifications);

# Print the disk space report.
if (%FileSystems) {
	print "_"x60 . "\nDisk space report:\n";
	my $units = ($^O eq 'aix'?'g':'h');
	RunDangerousCmd("df -$units -P| grep -E '^(" . join('|',keys(%FileSystems)) . ") '");
	print "\n";
}

if ($Errors) {
	warn "$Prog failed.\n";
	PrintStatsFile(strftime("%D %T $Prog ended with errors.<br>",localtime()));
} else {
	#print "$Prog ended normally.\n";
	PrintStatsFile(strftime("%D %T $Prog ended normally.<br>",localtime()));
}

close $STATFH if ($STATFH);
exit( ($Errors?10:0) );


#
# ProcessBackup - run a particular backup
#
sub ProcessBackup {

	my $Target = shift;
	if ($Options{verbose} >= 3) {
		print "Verbose:	Beginning backup of $Target.  Options:\n";
		print Dumper(\%Options);
	}
	PrintStatsFile(strftime("\n%D %T Starting $Target\n",localtime()));

	# Make sure they gave us a valid vault.
	if ($Target =~ m"^/") {
		# They gave us a full path.  See if it's valid.
		($MachineDirectory=$Target) =~ s":"/";
		$MachineDirectory =~ s"^(.*)[^/]*$"$1";
		$Target =~ s"^.*([^/]*$)"$1";
		if (! -d $MachineDirectory) {
			warn "$MachineDirectory not found\n";
			$Errors++;
			return;
		};
	} else {
		# No full path.  Hunt for it.
		$MachineDirectory='';
		foreach (@Banks) {
			if (-d "$_/$Target/dirvish") {
				$MachineDirectory = "$_/$Target";
				last;
			}
		}
		if (! $MachineDirectory) {
			warn "Unable to locate $Target in dirvish banks.\n";
			$Errors++;
			return;
		}
	}

	# Insert separators between tasks.
	print "_"x60 . "\n";
	print strftime("Starting $Target at %H:%M:%S on %A, %Y-%m-%d...\n",localtime());

	if (!chdir $MachineDirectory) {
		warn "Unable to CD to $MachineDirectory: $!\n";
		$Errors++;
		return;
	}

	# Make sure there's not another copy of us running against this.
	my $LockFile = "$MachineDirectory/dirvish/$Prog.lock";
	my $LOCK;
	if (!open($LOCK,'>>',$LockFile)) {
		warn "Unable to create/open $LockFile: $!";
		$Errors++;
		return;
	}
	if (!flock($LOCK, LOCK_EX | LOCK_NB)) {
		warn qq<Unable to lock lock file "$LockFile": $!\n>;
		$Errors++;
		return;
	}

	# Is this a rerun?
	if ($Options{rerun}) {
		my $LS;
		if (open($LS,'ls -t |')) {
			# Find the newest directory that isn't dirvish.
			while (my $dir = <$LS>) {
				chomp $dir;
				next if ( $dir =~ /^dirvish$/);
				my $mode = (lstat($dir))[2];		# Get the mode. lstat detects symlinks.
				next unless (S_ISDIR($mode));		# Skip non-directories.
				next unless (-M "$dir" <= $Options{rerun});		# Skip older backups.
				next unless (-d "$dir/tree" || -d "$dir/log" || -d "$dir/log.tmp");
				my $trash = mktemp("./trash.XXXX");
				RunDangerousCmd("mv $dir $trash") && warn "Unable to rename '$dir' in response to -R: $!";
				RunDangerousCmd("echo rm -rf ./$trash | at now");
				last;
			}
			close $LS;
		}
		else {
			warn "Unable to launch ls to delete prior backup: $!";
		}
	}

	# Do we need to initialize this disk?  Need at least 1 tree and a hist file.
	my $Status = system('/bin/ls ./*/tree > /dev/null 2>&1');
	$Status = system('/bin/ls ./dirvish/*.hist > /dev/null 2>&1') if ($Status eq 0);
	my $Init = ($Status eq 0?'':'--init "--expire=+3 months"');	# Add --init if no trees.

	# Run the back-up.
	my $AdditionalOptions = (exists($Options{dirvish})?join(' ',@{$Options{dirvish}}):'');
	my $TargetStartTime = time();
	$Status = RunDangerousCmd("dirvish --vault $Target $Init $AdditionalOptions");
	if ($Status == 0) {
		foreach (`ls -tr $MachineDirectory`) {
			chomp;
			next if (/^dirvish$/);
			my $Dir = "$MachineDirectory/$_";
			next unless ( -d "$Dir" and ! -l "$Dir");		# Skip symbolic links ("latest"), etc.
			next unless ( -f "$Dir/summary");			# Skip stray non-backup folders.
			next unless ((stat($Dir))[9] > $TargetStartTime);	# Skip older backups.
			Summarize($Target, $Dir);
		}
	} else {
		print "dirvish failed with status $Status\n";
		$Errors++;
	}

	# Clean up the lock file.
	unlink($LockFile);
	
	# Remember this file system device for our space report.
	my $fs=`df -P $MachineDirectory | tail -1`;
	$fs =~ s/\s.*$//;	# Just need the device name.
	chomp $fs;
	$FileSystems{$fs}=1;
}


#
# PrintStatsFile - write an HTML stats file for easy monitoring.
#
sub PrintStatsFile {

	return if ($StatErrors or ! $Options{statfile});
	if (defined($STATFH)) {
		# Rewind to the beginning.
		seek($STATFH,0,0);
	}
	else {
		# Not open yet.  Need to open and lock it.
		if (sysopen($STATFH,$Options{statfile},O_WRONLY|O_TRUNC|O_CREAT,0644)) {
			# Lock file.
			if (!flock($STATFH, LOCK_EX | LOCK_NB)) {
				warn qq<Unable to lock stat file "$Options{statfile}": $!\n>;
				close $STATFH;
				$STATFH=undef;
				$StatErrors++;
				$Errors++;
				return;
			}
		}
		else {
			warn "Unable to open $Options{statfile}: $!\n";
			close $STATFH;
			$STATFH=undef;
			$StatErrors++;
			$Errors++;
			return;
		}
	}
	chmod 0644,$Options{statfile};	# Sysopen doesn't change perms on existing files.

	# Write the header.  Use syswrite to avoid buffering, since we don't
	# close the file until the job is done.
	syswrite $STATFH,qq[
		<html>
			<head>
				<title>$Prog status</title>
				<meta HTTP-EQUIV="refresh" CONTENT="60">
			</head>
			<body>
				<font face="COURIER NEW" size=2>
];
	foreach (@_) {
		s/^\s*//;
		syswrite $STATFH,"$_<br>\n";
	}
	syswrite $STATFH,"\t\t\t\t</font>\n\t\t\t</body>\n\t\t</html>\n";
}


#
# Summarize - write a summary about this backup.
#
sub Summarize {
	my($Target,$Directory) = @_;			# Current directory we're processing.
	# Document any errors in the execution report.
	if (!open(SUMMARY,'<', "$Directory/summary")) {
		warn "Unable to open $Directory/summary: $!\n";
	}
	else {
		my $LastLine='';
		while (<SUMMARY>) {
			$LastLine = $_ if (!/^\s*$/);
		}
		$LastLine =~ s/\s*Status:\s*//;
		$LastLine =~ s/\s*$//;
		print "Unexpected summary status: $LastLine\n"
			unless ($LastLine =~ /^success$|file vanished on sender/);
	}
		
	system("tail -1 $Directory/summary");

	# Calculate totals.
	$TotalItems=0;
	$TotalSize=0;
	$NewItems=0;
	$NewSize=0;
	find(\&FoundItem,"$Directory/tree");
	my $WarnText='';
	if ($Options{minsize} and $NewSize < $Options{minsize}) {
		$WarnText = "New item size of " . FormatSize($NewSize) . " falls below the alert threshold of " . FormatSize($Options{minsize}) . ".\n";
	}
	if ($Options{maxsize} and $NewSize > $Options{maxsize}) {
		$WarnText = "New item size of " . FormatSize($NewSize) . " exceeds the alert threshold of " . FormatSize($Options{maxsize}) . ".\n";
	}
	$TotalSize=FormatSize($TotalSize);
	$NewSize=FormatSize($NewSize);
	printf "%s %s: " . 
		"Total Items: %s (%s), " .
		"New Items: %s (%s)\n",
		$Target,              $Directory,
		commify($TotalItems), $TotalSize,
		commify($NewItems),   $NewSize;
	print $WarnText if ($WarnText);
}


#
# FoundItem - process a found file
#
sub FoundItem {
	
	my($Links);			# Number of hardlinks.
	my($Size);			# Number of bytes.
	my($Name)=$File::Find::name;	# Name of tile.
	chomp;
	($Links,$Size)=(lstat($Name))[3,7];
	$TotalItems++;
	$TotalSize+=$Size if (defined($Size) && $Size != 0);
	if (defined($Links) && $Links == 1) {
		$NewItems++;
		$NewSize+=$Size;
	}
}


#
# FormatSize - standardize formatting size.
#
sub FormatSize {

	my $Size = shift;
	my $Unit = 'B';
	foreach (qw(K M G T)) {
		if ($Size >= 1024) {
			$Size = $Size/1024;
			$Unit = $_;
		}
		else {
			last;
		}
	}
	$Size = sprintf("%.1f%s",$Size,$Unit);
	$Size =~ s/\.0// if ($Size =~ /\d+\.0.$/);	# Normalize number.
	return $Size;
}


#
# commify - insert commas in numbers.
#
sub commify {
	local $_ = shift;
	1 while s/^(-?\d+)(\d{3})/$1,$2/;
	return $_;
}

#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($Options{test}) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($Options{verbose});
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}


#
# opt_Array - generic array processing
#
sub opt_Array {

	my($Name,$Value,undef) = @_;
	if (defined($Value) and length($Value)) {
		# Add this value to the array.
		push @{$Options{$Name}},$Value;
	}
	else {
		# Received "--opt=".  Empty this array.
		@{$Options{$Name}}=();
	}
}


#
# opt_O - Load an option set.
#
sub opt_O {
	my(undef,$Value) = @_;
	$Value = uc($Value);
	if (exists($Config{$Value})) {
		$Errors ++ unless GetOptionsFromString($Config{$Value},%OptionSpecifications);
	}
	else {
		warn qq<Warning: "$Value" not found in configuration file\n>;
	}
}



#
# opt_s - minimum size threshold
#
sub opt_s {
	my(undef,$Value) = @_;
	if ($Value =~ /^(\d+)$/i) {
		$Options{minsize} = $1;
	}
	elsif ($Value =~ /^(\d+)K$/i) {
		$Options{minsize} = $1*1024;
	}
	elsif ($Value =~ /^(\d+)M$/i) {
		$Options{minsize} = $1*1024*1024;
	}
	elsif ($Value =~ /^(\d+)G$/i) {
		$Options{minsize} = $1*1024*1024*1024;
	}
	elsif ($Value =~ /^(\d+)T$/i) {
		$Options{minsize} = $1*1024*1024*1024*1024;
	}
	else {
		die qq<Invalid value "$Value" for -s/--min-size.\n>;
	}
}



#
# opt_S - size threshold
#
sub opt_S {
	my(undef,$Value) = @_;
	if ($Value =~ /^(\d+)$/i) {
		$Options{maxsize} = $1;
	}
	elsif ($Value =~ /^(\d+)K$/i) {
		$Options{maxsize} = $1*1024;
	}
	elsif ($Value =~ /^(\d+)M$/i) {
		$Options{maxsize} = $1*1024*1024;
	}
	elsif ($Value =~ /^(\d+)G$/i) {
		$Options{maxsize} = $1*1024*1024*1024;
	}
	elsif ($Value =~ /^(\d+)T$/i) {
		$Options{maxsize} = $1*1024*1024*1024*1024;
	}
	else {
		die qq<Invalid value "$Value" for -S/--max-size.\n>;
	}
}


#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Run dirvish jobs

Usage:  $Prog [options] vault... [options] vault... ...
	$Prog -h

Options may be intermixed with vault names.  The following list of options
is divided into "Universal Options" and "Vault Options".  Universal options
are used at initialization time, and therefore affect all vaults regardless of
where the universal options appear in the command line.  Vault options apply
to any following options.

Universal Options:
	-B|--jobinit=script:		Begin: Execute "script" before running
					the first vault backups.

	-L|--logfile=filename
	-m|--always-mail=mailid:	Mail: Send an execution report to this
					e-mail address.

	-M|--error-mail=mailid: 	Mail on error: Send an execution report
					to this e-mail address only if errors
					are detected.

	-N|--subject=text:		Name: Set subject line to this.  Accepts
					variable subst.

	-p|--always-page=mailid: 	Page: Send a very brief message
					(suitable for a pager or text message)
					to this e-mail address when this job
					completes.

	-P|--error-page=mailid:		Page on error: Send a very brief message
					to this e-mail address if errors are
					detected in this job.

	-h|?|--help:			Help: display this panel

Vault Options:
	-D|--dirvish=parms:		Dirvish: Pass the following parameters
					and options directly to dirvish. 
					Spaces need to be escaped or quoted.

	-O|--option-set=config:		Insert the "config" configuration
					options from $ConfigFile.

	-R|--rerun=[days]:		Rerun: delete the most recent backup, 
					provided that it is no more than "days"
					days old.  Days is optional, and 
					defaults to 1.

	-s|--min-size=size:		minimum Size: Issue a warning if the
					size of the new items are less than
					"size".  "size" is measured in bytes,
					but may be followed by a unit of "k",
					"m", "g", or "t" (case-insensitive)
					for kilo-, mega-, giga-, or tera-bytes.

	-S|--max-size=size:		maximum Size: Issue a warning if the
					size of the new items exceeds "size".
					See "-s" above for unit specifications.
	-t|--test:			Test: echo commands instead of running
					them.
	-v|--verbose:			Verbose: echo commands before running
					them.  May be repeated to increase
					verbosity.  --test overrides --verbose.

Parameters:
	vault...:	One or more vault names.  Vault names may be fully 
			qualified, or else the directories listed in the 
			"BANKS:" setting in the configuration file ares
			searched in sequence.  A branch name may be included.

Example:

	$Prog -s 10G -S 30G vault1 vault2 -S 20G vault3

In this example, -s 10G applies to all three vaults.  -S 30G applies to
vault1 and vault2, but is changed to -S20G for vault3.

Notes:

1) Options that take multiple values may be reset to an empty list by using
the long form of the name followed by an equal sign and a space.  For example:

    "dirvish-run --dirvish --checksum vault1 --dirvish= vault2".  

Vault1 will be run with the "--checksum" option passed to dirvish, but 
vault2 will be run without the --checksum option.

Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW	"^\s*[-_]+\s*$"
SHOW	"^\s*Starting \S+ at \d+:\d+:\d+ on \S+, \d\d\d\d-\d\d-\d\d...\s*$"
# Ignore dirvish-expire messages
SHOW	/^\s*Unable to lock stat file "\S+": Resource temporarily unavailable/
IGNORE	"^\s*Expiring\s"
IGNORE	"^\s*VAULT:BRANCH\s+IMAGE\s+CREATED\s+EXPIRED\s*$"
IGNORE	"^\s*cannot expire .* No unexpired good images$"
IGNORE	"^\s*\S+:\S+\s+.*\s+==\s+\d{4}-\d\d-\d\d \d\d:\d\d\s*$"
#
SHOW	"^\S+ \S+: Total Items: [\d,]+ \(\d+(\.\d)?[BKGMT]\), New Items: [\d,]+ \(\d+(\.\d)?[BKGMT]\)$"
SHOW	/^\s*[a-zA-Z:]+ \d+ items backed up; \d+ are new.$/
# The disk space report is normal unless capacity reaches 90% full.
SHOW	"^\s*Disk space report:$"
SHOW	"^\s*Filesystem\s+Size\s+Used\s+Avail\s+Use%\s+Mounted on\s*$"
#SHOW	"^\s*(/dev/|\S+:)\S+\s+\d+[TGMK]\s+\d+[TGMK]\s+\d+[TGMK]\s+(\d|[1-8])%"
SHOW	"^\s*(/dev/|\S+:)\S+\s+[0-9.]+[TGMK]?\s+[0-9.]+[TGMK]?\s+[0-9.]+[TGMK]?\s+(\d|[1-8]\d|9[0-5])%"
IGNORE	"^\s*\*\*\* Execution cycle \d \*\*\*\s*$"
IGNORE	"^\s*Copyright \(c\) \d\d\d\d Water Technologies Inc.\s*$"
IGNORE	"^\s*All access is prohibited unless expressly authorized.$"
# Unexplained error 24 is "file vanished".  Ok if remote files are deleted while we run.
IGNORE	"^\s*rsync error: unexplained error \(code 24\) at main.c\(1045\)\s*$"
IGNORE	"^\s*rsync warning: some files vanished before they could be transferred"
IGNORE	"^\s*rsync: open.* failed: No such file or directory"
IGNORE	"^\s*(file|directory) has vanished: "
IGNORE	"^\s*Status: warning \(24\) -- file vanished on sender$"
IGNORE	"^\s*Status: success$"
SHOW	"^\s*Running:"
SHOW	"^\s*Running offsite back-ups to disk #\d+"
IGNORE	"^\s*warning: commands will be executed using /bin/sh$"
IGNORE	"^\s*job \d+ at "
IGNORE  "^\s*Job \S+.a will be run at ... ... .. ........ ... ....\.$"
SHOW    /^Job ended normally with status 0 and signal 0 - run time:/
SHOW    /^Test:/
SHOW    /^Executing:/
SHOW    /^Verbose:/
SHOW	/^\s*debug:/
SHOW  /^\s*$/
# 
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
