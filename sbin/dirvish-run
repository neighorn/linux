#!/usr/bin/perl

use strict;
use warnings;
use LogOutput;
#use ProcessOptions;
use Getopt::Long qw(GetOptionsFromString :config gnu_compat permute bundling);
use Text::ParseWords;
# override CORE::glob in current package
use File::Find;
use Fcntl qw(:flock :mode);
use File::Temp qw(mktemp);
use POSIX qw(strftime);
use Data::Dumper;
$Data::Dumper::Pad = "Verbose:\t\t";

$ENV{PATH}='/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/usr/bin:/bin';

# Initialize variables.
our $Prog=$0;                           # Get our name, for messages.
$Prog=~s/\.pl$|\.bat$//;            	# Trim off the suffix, if present.
$Prog=~s".*[/\\]"";     	    	# Trim off the path, if present.
my $Errors=0;   	                # No errors so far.
my $Syslog='user';                      # Name of Syslog facility.  '' for none.
my $BaseDir="/usr/local/etc";		# Set our base directory.
my $LogFile="";				# Name of the log file.
my $ConfigFile="$BaseDir/${Prog}.cfg";	# Name of config file.
our %Config;				# Data from the config file.
our %Options;				# Options settings.
my $MachineDirectory;			# Base directory for this dirvish item.
my %FileSystems;			# List of file systems we wrote to.
our @Parms;				# List of non-option arguments.

our $TotalSize;				# Global for Find/Found
our $TotalItems;			# Global for Find/Found
our $NewSize;				# Global for Find/Found
our $NewItems;				# Global for Find/Found

# Define our command-line options.  I use sub for everything, because
# GetOptions doesn't work right on a second call to it (which we need
# to do) with the conventional approach.
$DB::AutoTrace=$DB::AutoTrace;		# Suppress spurious warning.
our %OptionSpecifications=(
		'<>'			=>	sub {push @Parms,shift;},
		'd|debug'		=>	sub {$DB::AutoTrace=1;},
		'D|dirvish=s'		=>	sub {push @{$Options{Dirvish}},$_[1];},
		'B|begin=s'		=>	sub {push @{$Options{PreRun}},$_[1];},
		'h|help|?!'		=>	\&opt_h,
		'm|mail-always=s'	=>	sub {push @{$Options{Always_Mail}},$_[1];},
		'M|mail-errors=s'	=>	sub {push @{$Options{Error_Mail}},$_[1];},
		'N|subject=s'		=>	sub {$Options{Subject}=$_[1];},
		'O|option-set=s'	=>	\&opt_O,
		'p|page-always=s'	=>	sub {push @{$Options{Always_Page}},$_[1];},
		'P|page-errors=s'	=>	sub {push @{$Options{Error_Page}},$_[1];},
		'R|rerun:1'		=>	sub {$Options{Rerun}=$_[1];},
		's|min-size=s'		=>	\&opt_s,
		'S|max-size=s'		=>	\&opt_S,
		't|test!'		=>	sub {$Options{Test}=$_[1];},
		'v|verbose'		=>	sub { $Options{Verbose} = (exists($Options{Verbose})?$Options{Verbose}+1:1)},
);
#

# Note: general purpose script - don't change current directory.
#chdir $BaseDir || die "Unable to change directories to $BaseDir: $!\n";

# Load the config file.
if (-e $ConfigFile) {
	open(CONFIG,$ConfigFile) || die("Unable to open $ConfigFile: $!\n");
	# Build a hash of settings found in the config file.
	while (<CONFIG>) {
		next if (/^\s*#/);      # Comment.
		next if (/^\s*$/);      # Blank line.
		chomp;
		my ($name,$settings)=split(/:?\s+/,$_,2);
		$name=uc($name);	# Name is not case sensitive.
		$settings=~s/\s+$//;	# Trim trailing spaces.
		$Config{$name}.=$settings . ',' ;
	}
	close CONFIG;
	foreach (keys(%Config)) {
		$Config{$_} =~ s/,$//;	# Remove trailing comma
	}
}
foreach (keys(%Config)) { s/,$//;};	# Trim off trailing commas.

# Process the config file defaults if present.
unshift @ARGV, quotewords(" ",0,$Config{'ALLJOBS'})
	if (defined($Config{'ALLJOBS'}));

# Use the default job if it's defined and we didn't get anything on 
# the command line.
push @ARGV,(shellwords($Config{DEFAULTJOB}))
	if (!@ARGV && defined($Config{DEFAULTJOB}));

# Pre-process our command line, to get the options we need for LogOutput.
my @ARGVSave = @ARGV;			# Needed to reprocess command line later.
%Options=(Verbose => 0);	# Initialize Options.
$Errors ++ unless (GetOptions(%OptionSpecifications));
	
# Set up our logging and output filtering.
my $RunDate=`date +%m/%d`;
chomp $RunDate;
my $Subject;
if ($Options{Subject}) {
	$Subject="$Options{Subject}" ;
} elsif (@Parms >= 1) {
	$Subject="%* %m/%d %C %N " . join(', ',@Parms) . " %E %*%*%*" ;
} else {
	$Subject="%* %m/%d %C %N %E %*%*%*" ;
};

# Make sure some key items exist;
foreach (qw(Always_Mail Error_Mail Always_Page Error_Page)) {
	@{$Options{$_}} = () unless (exists($Options{$_}));
}
$Options{Verbose} = 0 unless (exists($Options{Verbose}));

LogOutput({
	SYSLOG_FACILITY		=> $Syslog,
	MAIL_FILE		=> $LogFile,
	ALWAYS_MAIL_LIST	=> \@{$Options{Always_Mail}},
	ERROR_MAIL_LIST		=> \@{$Options{Error_Mail}},
	ALWAYS_PAGE_LIST	=> \@{$Options{Always_Page}},
	ERROR_PAGE_LIST		=> \@{$Options{Error_Page}},
	MAIL_SUBJECT		=> $Subject,
});
die "No BANKS defined in configuration file(s)" 
	unless (defined($Config{BANKS}) 
		and exists($Config{BANKS})
		and $Config{BANKS});
my @Banks = shellwords(($Config{BANKS}));

foreach (@{$Options{PreRun}}) {
	# Run any initialization scripts.
	print "Running: $_\n";
	RunDangerousCmd($_) &&
		die "$_ returned status $?: $!\n";
}

# Now we have to wipe the options (because we've collected things
# that may be sequence-sensitive), and reprocess them.  This time
# GetOptions will call ProcessBackup for each non-option argument
# it finds, effectively running the backups.
@ARGV=@ARGVSave;		# Restore command line.
%Options=(Verbose => 0);	# Reinitialize Options.
$OptionSpecifications{'<>'} = \&ProcessBackup;
$Errors++ unless GetOptions(%OptionSpecifications);

# Print the disk space report.
if (%FileSystems) {
	print "_"x60 . "\nDisk space report:\n";
	my $units = ($^O eq 'aix'?'g':'h');
	RunDangerousCmd("df -$units -P| grep -E '^(" . join('|',keys(%FileSystems)) . ") '");
	print "\n";
}

if ($Errors) {
	warn "$Prog failed.\n";
} else {
	#print "$Prog ended normally.\n";
}

exit( ($Errors?10:0) );


#
# ProcessBackup - run a particular backup
#
sub ProcessBackup {

	my $Target = shift;
	if ($Options{Verbose} >= 3) {
		print "Verbose:	Beginning backup of $Target.  Options:\n";
		print Dumper(\%Options);
	}

	# Make sure they gave us a valid vault.
	if ($Target =~ m"^/") {
		# They gave us a full path.  See if it's valid.
		($MachineDirectory=$Target) =~ s":"/";
		$MachineDirectory =~ s"^(.*)[^/]*$"$1";
		$Target =~ s"^.*([^/]*$)"$1";
		if (! -d $MachineDirectory) {
			warn "$MachineDirectory not found\n";
			$Errors++;
			return;
		};
	} else {
		# No full path.  Hunt for it.
		$MachineDirectory='';
		foreach (@Banks) {
			if (-d "$_/$Target/dirvish") {
				$MachineDirectory = "$_/$Target";
				last;
			}
		}
		if (! $MachineDirectory) {
			warn "Unable to locate $Target in dirvish banks.\n";
			$Errors++;
			return;
		}
	}

	# Insert separators between tasks.
	print "_"x60 . "\n";
	print strftime("Starting $Target at %H:%M:%S on %A, %Y-%m-%d...\n",localtime());

	if (!chdir $MachineDirectory) {
		warn "Unable to CD to $MachineDirectory: $!\n";
		$Errors++;
		return;
	}

	# Make sure there's not another copy of us running against this.
	my $LockFile = "$MachineDirectory/dirvish/$Prog.lock";
	my $LOCK;
	if (!open($LOCK,'>>',$LockFile)) {
		warn "Unable to create/open $LockFile: $!";
		$Errors++;
		return;
	}
	if (!flock($LOCK, LOCK_EX | LOCK_NB)) {
		warn "Unable to lock $LockFile: $!";
		$Errors++;
		return;
	}

	# Is this a rerun?
	if ($Options{Rerun}) {
		my $LS;
		if (open($LS,'ls -t |')) {
			# Find the newest directory that isn't dirvish.
			while (my $dir = <$LS>) {
				chomp $dir;
				next if ( $dir =~ /^dirvish$/);
				my $mode = (lstat($dir))[2];		# Get the mode. lstat detects symlinks.
				next unless (S_ISDIR($mode));		# Skip non-directories.
				next unless (-M "$dir" <= $Options{Rerun});		# Skip older backups.
				next unless (-d "$dir/tree" || -d "$dir/log" || -d "$dir/log.tmp");
				my $trash = mktemp("./trash.XXXX");
				RunDangerousCmd("mv $dir $trash") && warn "Unable to rename '$dir' in response to -R: $!";
				RunDangerousCmd("echo rm -rf ./$trash | at now");
				last;
			}
			close $LS;
		}
		else {
			warn "Unable to launch ls to delete prior backup: $!";
		}
	}

	# Do we need to initialize this disk?  Need at least 1 tree and a hist file.
	my $Status = system('/bin/ls ./*/tree > /dev/null 2>&1');
	$Status = system('/bin/ls ./dirvish/*.hist > /dev/null 2>&1') if ($Status eq 0);
	my $Init = ($Status eq 0?'':'--init "--expire=+3 months"');	# Add --init if no trees.

	# Run the back-up.
	my $AdditionalOptions = (exists($Options{Dirvish})?join(' ',@{$Options{Dirvish}}):'');
	my $TargetStartTime = time();
	$Status = RunDangerousCmd("dirvish --vault $Target $Init $AdditionalOptions");
	if ($Status == 0) {
		foreach (`ls -tr $MachineDirectory`) {
			chomp;
			next if (/^dirvish$/);
			my $Dir = "$MachineDirectory/$_";
			next unless ( -d "$Dir" and ! -l "$Dir");		# Skip symbolic links ("latest"), etc.
			next unless ( -f "$Dir/summary");			# Skip stray non-backup folders.
			next unless ((stat($Dir))[9] > $TargetStartTime);	# Skip older backups.
			Summarize($Target, $Dir);
		}
	} else {
		print "dirvish failed with status $Status\n";
		$Errors++;
	}

	# Clean up the lock file.
	unlink($LockFile);
	
	# Remember this file system device for our space report.
	my $fs=`df -P $MachineDirectory | tail -1`;
	$fs =~ s/\s.*$//;	# Just need the device name.
	chomp $fs;
	$FileSystems{$fs}=1;
}



#
# Summarize - write a summary about this backup.
#
sub Summarize {
	my($Target,$Directory) = @_;			# Current directory we're processing.
	# Document any errors in the execution report.
	if (!open(SUMMARY,'<', "$Directory/summary")) {
		warn "Unable to open $Directory/summary: $!\n";
	}
	else {
		my $LastLine='';
		while (<SUMMARY>) {
			$LastLine = $_ if (!/^\s*$/);
		}
		$LastLine =~ s/\s*Status:\s*//;
		$LastLine =~ s/\s*$//;
		print "Unexpected summary status: $LastLine\n"
			unless ($LastLine =~ /^success$|file vanished on sender/);
	}
		
	system("tail -1 $Directory/summary");

	# Calculate totals.
	$TotalItems=0;
	$TotalSize=0;
	$NewItems=0;
	$NewSize=0;
	find(\&FoundItem,"$Directory/tree");
	my $WarnText='';
	if ($Options{MinSize} and $NewSize < $Options{MinSize}) {
		$WarnText = "New item size of " . FormatSize($NewSize) . " falls below the alert threshold of " . FormatSize($Options{MinSize}) . ".\n";
	}
	if ($Options{MaxSize} and $NewSize > $Options{MaxSize}) {
		$WarnText = "New item size of " . FormatSize($NewSize) . " exceeds the alert threshold of " . FormatSize($Options{MaxSize}) . ".\n";
	}
	$TotalSize=FormatSize($TotalSize);
	$NewSize=FormatSize($NewSize);
	printf "%s %s: " . 
		"Total Items: %d (%s), " .
		"New Items: %d (%s)\n",
		$Target,     $Directory,
		$TotalItems, $TotalSize,
		$NewItems,   $NewSize;
	print $WarnText if ($WarnText);
}


#
# FoundItem - process a found file
#
sub FoundItem {
	
	my($Links);			# Number of hardlinks.
	my($Size);			# Number of bytes.
	my($Name)=$File::Find::name;	# Name of tile.
	chomp;
	($Links,$Size)=(lstat($Name))[3,7];
	$TotalItems++;
	$TotalSize+=$Size if (defined($Size) && $Size != 0);
	if (defined($Links) && $Links == 1) {
		$NewItems++;
		$NewSize+=$Size;
	}
}


#
# FormatSize - standardize formatting size.
#
sub FormatSize {

	my $Size = shift;
	my $Unit = 'B';
	foreach (qw(K M G T)) {
		if ($Size >= 1024) {
			$Size = $Size/1024;
			$Unit = $_;
		}
		else {
			last;
		}
	}
	$Size = sprintf("%.1f%s",$Size,$Unit);
	$Size =~ s/\.0// if ($Size =~ /\d+\.0.$/);	# Normalize number.
	return $Size;
}


#
# commify - insert commas in numbers.
#
sub commify {
	local $_ = shift;
	1 while s/^(-?\d+)(\d{3})/$1,$2/;
	return $_;
}

#
# RunDangerousCmd - run a command, or suppress it if -t specified.
#
sub RunDangerousCmd {
	my ($Cmd,$FH,$Line);
	$Cmd=join(' ',@_);
	if ($Options{Test}) {
		print "Test: $Cmd\n";
		return 0;
	} else {
		print "Executing: $Cmd\n" if ($Options{Verbose});
		if (open($FH,"$Cmd 2>&1 |")) {
			while ($Line=<$FH>) {
				$Line=~s/[
]//g;
				chomp $Line;
				print "$Line\n";
			};
			close $FH;
			return $?;
		} else {
			warn qq(Unable to start process for "$Cmd": $!\n");
			return 8<<8;
		}
	}
}



#
# opt_O - Load an option set.
#
sub opt_O {
	my(undef,$Value) = @_;
	$Value = uc($Value);
	if (exists($Config{$Value})) {
		$Errors ++ unless GetOptionsFromString($Config{$Value},%OptionSpecifications);
	}
	else {
		warn qq<Warning: "$Value" not found in configuration file\n>;
	}
}



#
# opt_s - minimum size threshold
#
sub opt_s {
	my(undef,$Value) = @_;
	if ($Value =~ /^(\d+)$/i) {
		$Options{MinSize} = $1;
	}
	elsif ($Value =~ /^(\d+)K$/i) {
		$Options{MinSize} = $1*1024;
	}
	elsif ($Value =~ /^(\d+)M$/i) {
		$Options{MinSize} = $1*1024*1024;
	}
	elsif ($Value =~ /^(\d+)G$/i) {
		$Options{MinSize} = $1*1024*1024*1024;
	}
	elsif ($Value =~ /^(\d+)T$/i) {
		$Options{MinSize} = $1*1024*1024*1024*1024;
	}
	else {
		die qq<Invalid value "$Value" for -s/--min-size.\n>;
	}
}



#
# opt_S - size threshold
#
sub opt_S {
	my(undef,$Value) = @_;
	if ($Value =~ /^(\d+)$/i) {
		$Options{MaxSize} = $1;
	}
	elsif ($Value =~ /^(\d+)K$/i) {
		$Options{MaxSize} = $1*1024;
	}
	elsif ($Value =~ /^(\d+)M$/i) {
		$Options{MaxSize} = $1*1024*1024;
	}
	elsif ($Value =~ /^(\d+)G$/i) {
		$Options{MaxSize} = $1*1024*1024*1024;
	}
	elsif ($Value =~ /^(\d+)T$/i) {
		$Options{MaxSize} = $1*1024*1024*1024*1024;
	}
	else {
		die qq<Invalid value "$Value" for -S/--max-size.\n>;
	}
}


#
# opt_h: Usage
#
sub opt_h {

	open (PAGENATER,"| more") || die("Unable to start pagenater: $!\n");
	print PAGENATER <<"ENDUSAGE";
$Prog - Run dirvish jobs

Usage:  $Prog [options] vault... [options] vault... ...
	$Prog -h

Options:
	-B|--begin script:		Begin: Execute "script" before running
					any vault backups.

	-D|--dirvish parms:		Dirvish: Pass the following parameters
					and options directly to dirvish. 
					Spaces need to be escaped or quoted.

	-m|--always-mail mailid:	Mail: Send an execution report to this
					e-mail address.

	-M|--error-mail mailid: 	Mail on error: Send an execution report
					to this e-mail address only if errors
					are detected.

	-N|--subject text:		Name: Set subject line to this.  Accepts
					variable subst.

	-O|--option-set config:		Insert the "config" configuration
					options from $ConfigFile.

	-p|--always-page mailid: 	Page: Send a very brief message
					(suitable for a pager or text message)
					to this e-mail address when this job
					completes.

	-P|--error-page mailid:		Page on error: Send a very brief message
					to this e-mail address if errors are
					detected in this job.

	-R|--rerun [days]:		Rerun: delete the most recent backup, 
					provided that it is no more than "days"
					days old.  Days is optional, and 
					defaults to 1.

	-s|--min-size size:		minimum Size: Issue a warning if the
					size of the new items are less than
					"size".  "size" is measured in bytes,
					but may be followed by a unit of "k",
					"m", "g", or "t" (case-insensitive)
					for kilo-, mega-, giga-, or tera-bytes.

	-S|--max-size size:		maximum Size: Issue a warning if the
					size of the new items exceeds "size".
					See "-s" above for unit specifications.
	-t|--test:			Test: echo commands instead of running
					them.
	-v|--verbose:			Verbose: echo commands before running
					them.  May be repeated to increase
					verbosity.  --test overrides --verbose.

	-h|?|--help:			Help: display this panel

Parameters:
	vault...:	One or more vault names.  Vault names may be fully 
			qualified, or else the directories listed in the 
			"BANKS:" setting in the configuration file ares
			searched in sequence.  A branch name may be included.

Notes:
1) Options and vault names may be interspersed, and are applied in the 
sequence listed.  As a result, most options apply to any vaults that follow.
For example:

	$Prog -s 10G -S 30G vault1 vault2 -S 20G vault3

In this example, -s 10G applies to all three vaults.  -S 30G applies to
vault1 and vault2, but is changed to -S20G for vault3.

Some options are used to initialize the program, and as such reply to 
all vaults, regardless of where they appear.  These are the options that
configure e-mail notification (-m, -M, -p, -P, -N), run any external
initialization processes (-B), and the help panel (-h).


Return codes:
	0       :       Normal termination
	1       :       Help panel displayed.
	2       :       Invalid or unrecognized command line options.
	3       :       Invalid or unrecognized command line option value.
	4       :       Incorrect command line parameters.
	5       :       Unexpected message found in output.
	10      :       Some delete's failed.
ENDUSAGE
close PAGENATER;
exit 1;
}
__END__
#
# Output filters.  The syntax is: type pattern
#
#  Type:        Ignore - Don't display this message, it's not interesting.
#               LogOnly - Write this message to the syslog and log file, but
#                       don't display it on STDOUT.
#               Show - Display this message, but it's not an error condition.
#               # - This is a comment, ignore it.
#
#  Pattern:     an ordinary perl pattern.  All patterns for a given score
#               are joined by logical OR conditions.
#
#  Notes:
#       1) The "Type" parameter may be specified in upper, lower, or mixed case.
#       2) All messages go to the syslog, regardless of this filter.
#
#
# The following are normal messages we don't need to see.
#
#
# These are normal messages that we want to see in the e-mail log only.
#
LOGONLY "^\S+ started on \S+ on \S+, \d+/\d+/\d+ at \d+:\d+:\d+"
LOGONLY /^Command: /
#
# These are normal messages that we want to see.
#
SHOW	"^\s*[-_]+\s*$"
SHOW	"^\s*Starting \S+ at \d+:\d+:\d+ on \S+, \d\d\d\d-\d\d-\d\d...\s*$"
# Ignore dirvish-expire messages
IGNORE	"^\s*Expiring\s"
IGNORE	"^\s*VAULT:BRANCH\s+IMAGE\s+CREATED\s+EXPIRED\s*$"
IGNORE	"^\s*cannot expire .* No unexpired good images$"
IGNORE	"^\s*\S+:\S+\s+.*\s+==\s+\d{4}-\d\d-\d\d \d\d:\d\d\s*$"
#
SHOW	"^\S+ \S+: Total Items: \d+ \(\d+(\.\d)?[BKGMT]\), New Items: \d+ \(\d+(\.\d)?[BKGMT]\)$"
SHOW	/^\s*[a-zA-Z:]+ \d+ items backed up; \d+ are new.$/
# The disk space report is normal unless capacity reaches 90% full.
SHOW	"^\s*Disk space report:$"
SHOW	"^\s*Filesystem\s+Size\s+Used\s+Avail\s+Use%\s+Mounted on\s*$"
#SHOW	"^\s*(/dev/|\S+:)\S+\s+\d+[TGMK]\s+\d+[TGMK]\s+\d+[TGMK]\s+(\d|[1-8])%"
SHOW	"^\s*(/dev/|\S+:)\S+\s+[0-9.]+[TGMK]?\s+[0-9.]+[TGMK]?\s+[0-9.]+[TGMK]?\s+(\d|[1-8]\d|9[0-5])%"
IGNORE	"^\s*\*\*\* Execution cycle \d \*\*\*\s*$"
IGNORE	"^\s*Copyright \(c\) \d\d\d\d Water Technologies Inc.\s*$"
IGNORE	"^\s*All access is prohibited unless expressly authorized.$"
# Unexplained error 24 is "file vanished".  Ok if remote files are deleted while we run.
IGNORE	"^\s*rsync error: unexplained error \(code 24\) at main.c\(1045\)\s*$"
IGNORE	"^\s*rsync warning: some files vanished before they could be transferred"
IGNORE	"^\s*rsync: open.* failed: No such file or directory"
IGNORE	"^\s*(file|directory) has vanished: "
IGNORE	"^\s*Status: warning \(24\) -- file vanished on sender$"
IGNORE	"^\s*Status: success$"
SHOW	"^\s*Running:"
SHOW	"^\s*Running offsite back-ups to disk #\d+"
IGNORE	"^\s*warning: commands will be executed using /bin/sh$"
IGNORE	"^\s*job \d+ at "
IGNORE  "^\s*Job \S+.a will be run at ... ... .. ........ ... ....\.$"
SHOW    /^Job ended normally with status 0 and signal 0 - run time:/
SHOW    /^Test:/
SHOW    /^Executing:/
SHOW    /^Verbose:/
SHOW	/^\s*debug:/
SHOW  /^\s*$/
# 
# Anything that doesn't match one of these three sets of patterns is considered
# an error.
