#! /usr/bin/perl
package ProcessOptions;
require Exporter;
use strict;
no strict "refs";

our @ISA        = qw(Exporter);
our @EXPORT     = qw(ProcessOptions);
our @EXPORT_OK  = qw($Verbose);
our $Version    = 1.1;

#
# ProcessOptions - process command line and config file options.
#
# Calling arguments:
#	OptionSpec:	This is a description of the valid options.  It 
#			uses the same syntax as GetOpt::Mixed (i.e.
#			"x y=s" defines x as an option, y as an option that
#			requires a string arg).  It also supports lists (
#			"y=l"), which sets $opt_y to multiple values (i.e.
#			"-y abc -y def" sets $opt_y to "abc def"), and
#			creates a matching array (i.e. @opt_y).
#	Options	:	This is either a command-line like string (i.e.
#			"-m jjones -x ssmith"), or a null string to
#			use the contents of @ARGV.
#
# Standard command line options are:
#	-h	:	Help - call Usage.
#	-d	:	Diagnostics - run with trace
#	-m mailid:	Append mailid to $MailList.  May be repeated.
#	+m	:	Erase current contents of $MailList.
#	-e mailid:	Append mailid to $ErrorList.  May be repeated.
#	+e	:	Erase current contents of $ErrorList.
#	-p mailid:	Append mailid to $PageList. May be repeated.  -p
#			is comparable to -m, but the e-mail is very brief
#			(suitable for a pager).
#	+p	:	Erase current contents of $PageList.
#	-P mailid:	Append mailid to $PageErrorList.  May be repeated.
#			-P is the pager equivalent to -e.
#	+P	:	Erase current contents of $PageErrorList.
#	-O config:	Insert options from the "config" line of the
#			configuration file.
#
# For any option "x" if a subroutine called main::opt_x exists, it will
# be called each time -x or +x is found in the option list.  It will be
# passed the new value from the command line.  This is most commonly used
# to implement -h (help panel), but can be used for any option.
#
# On exit, and remaining command line parameters (not options) are appended
# to $Parms and listed in @Parms.  Note that this means multiple calls to this
# routine can each have their own mix of options and parms, and all the options
# will be processed, and all the Parms will be collected into $Parms and
# @Parms in order.
#
sub ProcessOptions {

	use Text::ParseWords;	# For parsing data from the config file.

	# Declare local variables.
	my(@Args);			# Temporary hold area for args.
	my($Option);			# Option letter (i.e. "a" in "-a")
	my($Value);			# Option parm (i.e. "x" in "-m x")
	my($FullOption);		# Option letter with prefix (i.e. "+k")
	my($OptName);			# opt_$Option
	my($YesNoOpts)='';		# List of simple options (i.e. -h).
	my($ValueOpts)='';		# List of options taking one value.
	my($ListOpts)='';		# List of options taking multiple vals.
	my($OptType)='';		# Used to parse option desc.
	my($OptFunc)='';		# Used to parse option desc.
	my($Verbose);			# Show diagnostic data.
	my($opt_name);			# Name of current option.
	my($ErrorFlag)=0;			# Flag to indicate errors were detected.

	my($OptDesc,$Args)=@_;	# Get our calling args
	if (defined($Args)) {
		# They provided a pseudo-command line.  Turn it into an ARGV
		# array.  This code stolen from "perldoc -q delimited".
		$Args =~ s/^\s+//;	# Strip leading blanks.
		$Args =~ s/\s+$//;	# Strip trailing blanks.
		@Args = quotewords(" ",0,$Args);
		print "ProcessOptions: Option Specification=$OptDesc\nProcessOptions: Args=$Args\n"
			if ($Verbose);
	} else {
		# They didn't supply anything.  Just copy ARGV.
		@Args = @main::ARGV;
		print "ProcessOptions: Option Specification=$OptDesc\nProcessOptions: Args=$Args\n"
			if ($Verbose);
	}
	if ($Verbose) {
		print "ProcessOptions: \@Args:\n";
		foreach(@Args) {print qq(\t"$_"\n);};
	}

	local(@ARGV)=@Args;		# Load up a private copy of our argv.

	# Build our patterns.
	foreach (split(/\s+/,$OptDesc)) {
		($OptName,$OptFunc,$OptType)=m/([^=:>])+([=:>])(\S*)/;
		$OptName=$_ if (!defined($OptName));
		$OptFunc='' if (!defined($OptFunc));
		$OptType='' if (!defined($OptType));
		next if ($OptFunc eq '>');	# Alias.
		if ($OptType eq '')	{$YesNoOpts.=$OptName; next};
		if ($OptType=~/[is]/)	{$ValueOpts.=$OptName; next};
		if ($OptType eq 'l')	{$ListOpts.=$OptName; next};
		die("Invalid option type '$OptType' for $OptName in ProcessOptions");
	}
	print "ProcessOptions: Boolean flags:$YesNoOpts, Value flags:$ValueOpts, List flags:$ListOpts\n"
		if ($Verbose);

	# Convert our new lists into patterns.  Space handles null lists.
	$YesNoOpts=qr/^[ ${YesNoOpts}]$/;
	$ValueOpts=qr/^[ ${ValueOpts}]$/;
	$ListOpts=qr/^[ ${ListOpts}]$/;

	# Now clean up OptDesc, since Getopt doesn't understand =l or :l.
	$OptDesc=~s/([=:])l/${1}s/g;

	# Start processing the options.
	use Getopt::Mixed 'nextOption';
	Getopt::Mixed::init('-+',$OptDesc);
	while (($Option, $Value, $FullOption) = nextOption()) {
		print "ProcessOptions: Option=$Option, Value=$Value, FullOption=$FullOption\n"
			if ($Verbose);
		$opt_name="main::opt_$Option";
		if ($Option eq 'd') {
			# Debug flag set.
			if ($ENV{'PERLDB_OPTS'} !~ /NonStop/)	{
				# Rerun ourselves with an autotrace.
				$ENV{'PERLDB_OPTS'}='AutoTrace NonStop=1';
				exec join(' ','perl -d',$0,@Args);
				die("exec returned $? executing @Args: $!\n");
			} else {
				# NonStop set.  This *IS* the traced version.
				next;	# Nothing to do -- ignore the -d.
			}
		}
		if ($Option eq 'O')	{
			# Load a special option set from the options file.
			$Value=~tr/[a-z]/[A-Z]/;
			if (defined($main::Config{$Value})) {
				unshift @ARGV,
					quotewords(" ",0,$main::Config{$Value});
			} else {
				warn "$Value configuration not found in $main::ConfigFile.\n";
				$ErrorFlag=3;
			}
			next;
		}
		if ($Option =~ /${YesNoOpts}/) {
			# Handle our binary options en masse.
			$Value=($FullOption =~ /^\+/)?0:1;
			&$opt_name($Value) if defined(&$opt_name);
			$$opt_name=$Value if (defined($Value));
			next;
		}
		if ($Option =~ /${ValueOpts}/) {
			# Handle simple settings en masse.
			&$opt_name($Value) if defined(&$opt_name);
			#eval "\$$opt_name='$Value';" if(defined($Value));
			$$opt_name=$Value if(defined($Value));
			next;
		};
		if ($Option =~ /${ListOpts}/)	{
			# Handle list en masse, & strip lead/trailing blanks.
			if ($FullOption =~ /^\+/) {
				# Delete list so far.
				$Value='';	# Set to anything.
				&$opt_name($Value) if defined(&$opt_name);
				#eval "\$$opt_name='';" if (defined($Value));
				$$opt_name='' if (defined($Value));
				undef @$opt_name;	# Make list go away.
				# Work around the fact that +list needs no
				# parms, but Getopt can't handle that. Note
				# that this means +list can't be last.
				unshift @ARGV, $Value;
			} else {
				# Append new item to existing list.
				&$opt_name($Value) if defined(&$opt_name);
				$$opt_name .= " $Value" if (defined($Value));
				push @$opt_name,$Value;
				# Strip leading and trailing spaces off of options.
				#eval "\$$opt_name=~s/^\\s*(.*)\\s*\$/\$1/;";
				$$opt_name=~s/^\s+//;
				$$opt_name=~s/\s+$//;
			}
			next;
		}
		print STDERR "Unrecognized option: \"$FullOption\".  Enter \"$main::Prog -h\" " .
			"for usage information.\n";
		$ErrorFlag=2;
	}

	# Anything left is part of our parms.
	Getopt::Mixed::cleanup();
	$main::Parms.=join(" ",@ARGV);
	push @main::Parms,@ARGV;

	my($Trash)=$main::ConfigFile;	# Dummy ref to suppress -w msg.
	$Trash=$main::Parms;		# Dummy ref to suppress -w msg.
	$Trash=$main::Prog;		# Dummy ref to suppress -w msg.
	print "ProcessOptions: On exit: \$Parms=$main::Parms, \@Parms=" . join(", ", @main::Parms) . "\n"
		if ($Verbose);
	return $ErrorFlag;
}
